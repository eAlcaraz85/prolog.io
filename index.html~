<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-12-01 lun 09:33 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Apuntes Programación Lógica Funcional</title>
<meta name="author" content="Eduardo Alcaraz" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="src/readtheorg_theme/css/readtheorg.css"/>
<script type="text/javascript" src="src/lib/js/jquery.min.js"></script>
<script type="text/javascript" src="src/lib/js/bootstrap.min.js"></script>
<script type="text/javascript" src="src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="src/readtheorg_theme/js/readtheorg.js"></script>
<style> #content{max-width:1800px;}</style>
<style>pre.src {background-color: #303030; color: #e5e5e5;}</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Apuntes Programación Lógica Funcional</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org4c8f2b6">Conceptos Fundamentales</a>
<ul>
<li><a href="#org1ecab57">Diferentes Estilos de Programación</a>
<ul>
<li><a href="#orgf0ddf59">Estilos de Programación</a></li>
<li><a href="#orgb61d021">Características del Estilo</a></li>
<li><a href="#org04fae47">Nombres de Variable Apropiadas.</a></li>
<li><a href="#org9bf557d">Estilo de indentación</a></li>
<li><a href="#orga27ddaa">Bucles y estructuras de control</a></li>
<li><a href="#org47d8a3b">Espaciado</a></li>
<li><a href="#org21199dd">Evaluación de expresiones</a></li>
</ul>
</li>
<li><a href="#org92a5ac2">Analizando diferentes estilos de Programación</a></li>
<li><a href="#org51881de">Paradigma de Programación</a>
<ul>
<li><a href="#org8732436">Tipos más comunes de paradigmas de programación</a></li>
</ul>
</li>
<li><a href="#org6f74aa3">Evaluación de expresiones</a></li>
<li><a href="#orgac43bf1">Tipos de datos</a></li>
<li><a href="#orga9f34c1">Disciplina de tipos</a></li>
<li><a href="#orgfd148cf">Funciones</a></li>
</ul>
</li>
<li><a href="#org2606c9a">Programación Funcional</a></li>
<li><a href="#org7a21e4b">Lisp</a>
<ul>
<li><a href="#org2552bbe">Historia</a></li>
<li><a href="#org81545c2">Programación en Lisp</a></li>
<li><a href="#org08acd8b">Expresiones</a></li>
<li><a href="#org7b421b1">Datos</a></li>
<li><a href="#orgf8121ed">Evaluación</a></li>
<li><a href="#orgf4a6457">Funciones en Lisp</a></li>
<li><a href="#org750aa24">Listas</a></li>
<li><a href="#orge0c5ad5">Cons</a></li>
<li><a href="#orgd4be993">Funciones CAR y CDR</a>
<ul>
<li><a href="#org0a3ed98">Ejercicios car cdr</a></li>
</ul>
</li>
<li><a href="#orgf8becc4">Entradas y salidas</a>
<ul>
<li><a href="#orgb86754c">Funciones de Entrada:</a></li>
</ul>
</li>
<li><a href="#orgf0278cb">Condicionales en Lisp</a>
<ul>
<li><a href="#orgeba4b20">Condicionales Básicas</a></li>
<li><a href="#org1fc0df5">Condicionales Anidadas</a></li>
<li><a href="#org54a7dcc">Condicionales Complejas</a></li>
<li><a href="#org1a30ba9">Referencias</a></li>
</ul>
</li>
<li><a href="#orgeb77d72">Listas de Asociación en Lisp</a>
<ul>
<li><a href="#orga2dc8c4">1. Acceder a un valor <b>*</b></a></li>
<li><a href="#org63db5b3">2. Agregar un nuevo par clave-valor <b>*</b></a></li>
<li><a href="#orgcbd6857">3. Modificar un valor existente <b>*</b></a></li>
<li><a href="#orgdacec1e">4. Eliminar un par clave-valor <b>*</b></a></li>
</ul>
</li>
<li><a href="#orgc74ea1e">Casi-Quoting en Lisp</a>
<ul>
<li><a href="#org05fc342">Introducción</a></li>
<li><a href="#org668e05b">1. Operador `quote`</a></li>
<li><a href="#org3db40b8">2. Operador `backquote`</a></li>
<li><a href="#org4ba2e13">3. Evaluación con la coma (`,`)</a></li>
<li><a href="#orgac59cca">4. Expansión de listas con `,@`</a></li>
<li><a href="#org1f40cc9">5. Combinación de `backquote`, `,` y `,@`</a></li>
<li><a href="#org0c934b4">6. Ejemplos adicionales</a></li>
<li><a href="#orgaf03a9b">8. Ejemplo completo</a></li>
</ul>
</li>
<li><a href="#orgca99e9c">mapcar en Lisp</a>
<ul>
<li><a href="#org96d9fde">Introducción</a></li>
<li><a href="#org3a9c4d8">Sintaxis básica de mapcar</a></li>
<li><a href="#orge713e5e">Ejemplos básicos</a></li>
<li><a href="#org8fb031a">Ejemplos</a></li>
</ul>
</li>
<li><a href="#org5c00a5b">Comparaciones en Lisp</a>
<ul>
<li><a href="#org1bfc410">1. <b>eq</b></a></li>
<li><a href="#orgdfeaa26">2. <b>eql</b></a></li>
<li><a href="#org3711b58">3. <b>equal</b></a></li>
<li><a href="#org8a2d3ca">4. <b>equalp</b></a></li>
<li><a href="#org8645e17">5. <b>=</b></a></li>
<li><a href="#org3428279">6. <b>/=</b></a></li>
<li><a href="#org07911ff">7. <b>string=</b></a></li>
<li><a href="#org8a27c40">8. <b>string-equal</b></a></li>
<li><a href="#orgc2596cb">9. <b>char=</b> y <b>char-equal</b></a></li>
<li><a href="#org560e122">Resumen</a></li>
<li><a href="#orgb135474">Ejemplo completo</a></li>
</ul>
</li>
<li><a href="#org04771f7">Funciones lambda en Lisp</a>
<ul>
<li><a href="#org42811e6">Introducción</a></li>
<li><a href="#orga41bf8d">Definición básica de una función lambda</a></li>
<li><a href="#orgc1c2fef">Ejemplos de uso de lambdas</a></li>
<li><a href="#org439abfa">Ámbito de las lambdas</a></li>
<li><a href="#org07a4634">Lambdas como valores de retorno</a></li>
<li><a href="#org53e429d">Usos comunes de lambdas</a></li>
<li><a href="#orgf8b8407">Ejemplos</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6579720">Prolog</a>
<ul>
<li><a href="#org525da57">Lógica de primer orden</a>
<ul>
<li><a href="#org0cde51d">1. La Tierra es un planeta.</a></li>
<li><a href="#orgde0f5c5">2. La Luna no es un planeta.</a></li>
<li><a href="#org5e18608">3. La Luna es un satélite.</a></li>
<li><a href="#org5ff74d9">4. La Tierra gira alrededor del Sol.</a></li>
<li><a href="#orge11b617">5. Todo planeta es un satélite.</a></li>
<li><a href="#org367c7c7">6. Todo planeta gira alrededor del Sol.</a></li>
<li><a href="#org78829a0">7. Algún planeta gira alrededor de la Luna.</a></li>
<li><a href="#org84d4a3e">8. Hay por lo menos un satélite.</a></li>
<li><a href="#org5027305">9. Todos los perros del vecindario muerden a algún cartero.</a></li>
<li><a href="#org476aa00">10. Hay un cartero al que lo muerden todos los perros.</a></li>
<li><a href="#org2a8fbc6">11. Todos los carteros son mordidos por algún perro.</a></li>
<li><a href="#org9f7fb6d">12. Hay un perro que muerde a todos los carteros.</a></li>
<li><a href="#org4e84228">13. Todos los perros que asustan a algún cartero, lo muerden.</a></li>
<li><a href="#orgc154abb">14. Hay un perro que muerde a todos los perros que muerden a algún cartero.</a></li>
<li><a href="#org94770e6">15. Hay un solo perro que se muerde a sí mismo.</a></li>
</ul>
</li>
<li><a href="#org437f8fb">Hechos, Átomos y Reglas</a>
<ul>
<li><a href="#org0f3d7ef">1. Hechos</a></li>
<li><a href="#org3717106">2. Átomos</a></li>
<li><a href="#org4b7c6a1">3. Reglas</a></li>
<li><a href="#org8af1caf">4. Ejemplos adicionales para comprender hechos, átomos y reglas</a></li>
<li><a href="#org6c930fb">5. Ejecución de consultas en Prolog</a></li>
</ul>
</li>
<li><a href="#org1c7ba1f">Unificación en Prolog</a>
<ul>
<li><a href="#orgf02124b">1. ¿Qué es la unificación?</a></li>
<li><a href="#org4208c46">2. Reglas de unificación</a></li>
<li><a href="#org3ca444c">3. Ejemplos de unificación</a></li>
<li><a href="#org4c3bbe1">5. Importancia de la unificación en Prolog</a></li>
<li><a href="#org6a07707">6. Ejemplo práctico</a></li>
<li><a href="#org102491e">Resumen</a></li>
</ul>
</li>
<li><a href="#org534266f">Corte</a>
<ul>
<li><a href="#org693bce3">Usos del corte</a></li>
<li><a href="#orgf5af999">Corte y fallo</a></li>
</ul>
</li>
<li><a href="#org229676a">Definición matemática del factorial</a>
<ul>
<li><a href="#org3fdcfd5">Implementación en Prolog</a></li>
<li><a href="#orge84cf95">Ejemplo de uso</a></li>
<li><a href="#org3ae9eaf">Explicación paso a paso del proceso recursivo</a></li>
<li><a href="#org2eaa871">Resumen</a></li>
<li><a href="#org1c69d7d">Factorial en Prolog</a></li>
<li><a href="#org5f5286e">Prueba de escritorio para factorial(3, F)</a></li>
<li><a href="#org8376e11">Resultado final: factorial(3,6)</a></li>
<li><a href="#org6d483b5">Fibonacci en Prolog</a></li>
<li><a href="#org718c9dd">Prueba de escritorio para fibonacci(4, F)</a></li>
<li><a href="#org9c3b0ad">Resultado final: fibonacci(4,3)</a></li>
</ul>
</li>
<li><a href="#org4aca2e4">Listas en Prolog</a>
<ul>
<li><a href="#org42ead6a">1. Definición y construcción de listas</a></li>
<li><a href="#org429acc1">2. Operaciones básicas en listas</a></li>
<li><a href="#org0b08e3d">3. Otras operaciones comunes</a></li>
<li><a href="#org6081baf">4. Ejemplos adicionales y casos de uso</a></li>
</ul>
</li>
<li><a href="#org9caec7c">Ejercicios</a>
<ul>
<li><a href="#orgb1192fa">Problema: Los hermanos y sus mascotas</a></li>
<li><a href="#org2ebc57c">Solución</a></li>
<li><a href="#orgec3d5ab">Problema: Los investigadores y sus descubrimientos</a></li>
</ul>
</li>
<li><a href="#orge5b1ca6">Variables Anónimas en Prolog</a>
<ul>
<li><a href="#org96311f9">Características de las Variables Anónimas</a></li>
<li><a href="#org372ff31">Ejemplo</a></li>
<li><a href="#org917daeb">Casos Comunes de Uso</a></li>
<li><a href="#org46c74bf">Ejercicio</a></li>
</ul>
</li>
<li><a href="#orgadc5216">Predicados Mitológicos en Programación Lógica</a>
<ul>
<li><a href="#orgf2c4559">Introducción</a></li>
<li><a href="#org385bd47">Ejemplos Detallados de Predicados Mitológicos</a></li>
</ul>
</li>
<li><a href="#orgc115569">Problemas con Predicados Mitológicos</a>
<ul>
<li><a href="#org33c2216">1. Aplanar una lista de listas anidadas</a></li>
<li><a href="#orgfb58e99">2. Encontrar todas las permutaciones de una lista</a></li>
<li><a href="#org45a658c">3. Generar subconjuntos de una lista</a></li>
<li><a href="#orgc7e66f0">4. Encontrar todos los números en un rango que cumplen una condición</a></li>
<li><a href="#orgd978b95">5. Concatenar dos listas</a></li>
<li><a href="#orgb6201de">6. Encontrar elementos únicos en una lista</a></li>
<li><a href="#orgc352e1a">7. Calcular la potencia de un número</a></li>
<li><a href="#orge3d29ff">8. Alinear equipos en un torneo</a></li>
<li><a href="#org36ce183">9. Resolver problemas de caminos</a></li>
<li><a href="#org1d501ed">10. Generar combinaciones con repetición</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge55b451">Proyecto</a>
<ul>
<li><a href="#orga048c4e">Actividad</a></li>
</ul>
</li>
<li><a href="#org4ca85ed">Examen final</a>
<ul>
<li><a href="#org45e0460">Problema 1: Los guardianes de los templos</a></li>
<li><a href="#org9bf5445">Problemas 2: Las armas de los héroes Cuatro héroes mitológicos</a></li>
<li><a href="#orgbdf0ccf">Problema 3: Las gemas de los titanes Cuatro titanes</a></li>
</ul>
</li>
<li><a href="#org1b435b3">Respuestas Ejercicios</a>
<ul>
<li><a href="#org9462ff3">Problema 1: Los guardianes de los templos</a>
<ul>
<li><a href="#org2a2d05f">Prueba de escritorio (Unificación paso a paso)</a></li>
</ul>
</li>
<li><a href="#orga1768dd">Problema 2: Las armas de los héroes</a>
<ul>
<li><a href="#orgae624fa">Prueba de escritorio (Unificación paso a paso)</a></li>
</ul>
</li>
<li><a href="#orgc18b51d">Problema 3: Las gemas de los titanes</a>
<ul>
<li><a href="#org9d91fd7">Prueba de escritorio (Unificación paso a paso)</a></li>
<li><a href="#org4834c28">Tabla resumen de la solución</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6582199">Ejercicios</a></li>
<li><a href="#org2b97236">Ejercicios de Lisp: car, cdr y condicionales</a>
<ul>
<li><a href="#orgb6d73af">Ejercicio 1: Primer elemento de una lista</a></li>
<li><a href="#org7cec33e">Ejercicio 2: Segundo elemento de una lista</a></li>
<li><a href="#org42f3b04">Ejercicio 3: Último elemento de una lista</a></li>
<li><a href="#org0f67a6d">Ejercicio 4: Longitud de una lista</a></li>
<li><a href="#orgbbeef23">Ejercicio 5: Suma de una lista de números</a></li>
<li><a href="#orgc0a2efb">Ejercicio 6: Verificar si un elemento está en una lista</a></li>
<li><a href="#org5595192">Ejercicio 7: Invertir una lista</a></li>
<li><a href="#org1ead6b1">Ejercicio 8: Eliminar todas las ocurrencias de un elemento</a></li>
<li><a href="#org886ea8c">Ejercicio 9: Obtener el enésimo elemento de una lista</a></li>
<li><a href="#org1f38de8">Ejercicio 10: Concatenar dos listas</a></li>
</ul>
</li>
<li><a href="#orga5b35cc">Eliza</a>
<ul>
<li><a href="#org13b3284">Introducción</a></li>
<li><a href="#org747eb9d">Estructura general del programa</a></li>
<li><a href="#orgd5c2220">Predicado principal</a></li>
<li><a href="#org0597738">Casos base para terminar</a></li>
<li><a href="#orgd528a59">Mecanismo de respuesta</a></li>
<li><a href="#org7d97a79">Plantillas de diálogo</a></li>
<li><a href="#orgfd50c02">Predicado <code>replace0/5</code></a></li>
<li><a href="#org3c0f673">Parámetros</a></li>
<li><a href="#org2527f46">Detalle de ejecución</a></li>
<li><a href="#orgf0b2148">Corrida completa del código replace0/5</a>
<ul>
<li><a href="#org7063d99">Llamada inicial</a></li>
</ul>
</li>
<li><a href="#orgfc3ee10">Análisis del patrón</a></li>
<li><a href="#org640bad3">Paso 1 — Sustitución del índice 1</a></li>
<li><a href="#org53af7a0">Llamada recursiva con el nuevo N1</a></li>
<li><a href="#org83550b8">Paso 2 — Último índice</a>
<ul>
<li><a href="#orgc09b8a4">Esta llamada usa la cláusula “final” (no recursiva)**.</a></li>
<li><a href="#orge815b30">Resultado final:</a></li>
<li><a href="#org2911b43">Árbol de derivación completo con momentos exactos de N + 1</a></li>
<li><a href="#org4525169">Resumen claro</a></li>
<li><a href="#orgf6486a3">Resultado final del proceso</a></li>
</ul>
</li>
<li><a href="#org3b959fe">Conocimiento del mundo</a></li>
<li><a href="#org5a4276f">Plantillas especiales con <b>flags</b></a></li>
<li><a href="#org5572d7c">Respuestas genéricas</a></li>
<li><a href="#orgdea1552">Plantilla involucrada</a></li>
<li><a href="#orgcdc2426">¿Qué sucede en el código?</a></li>
<li><a href="#orgda060a7">Base de conocimiento familiar</a></li>
<li><a href="#org81c84f4">Ejemplo válido</a></li>
<li><a href="#org1b11a72">Ejemplo que no cumple</a></li>
<li><a href="#orga1cd99e">Ejemplo completo</a>
<ul>
<li><a href="#org9c827b3">Entrada del usuario:</a></li>
<li><a href="#orgb803cca">Flujo del programa:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org7d54c66">Ejercicios prolog</a></li>
<li><a href="#org61b9f19">Respuestas</a></li>
<li><a href="#org422c46e">Logica</a></li>
<li><a href="#org3d27b33">Acertijo de los Laboratorios</a>
<ul>
<li><a href="#orge85436f">Paso 1: Información Inicial</a></li>
<li><a href="#org154711f">Paso 2: Determinar los colores faltantes</a></li>
<li><a href="#org50a0ebe">Paso 3: Confirmación de Reglas</a></li>
</ul>
</li>
<li><a href="#org3073530">Examen</a></li>
<li><a href="#orge8e8530">Examen Prolog — Respuestas</a></li>
<li><a href="#org2ee93e5">Acertijo Lógico Examen</a>
<ul>
<li><a href="#orgc7129ae">Descripción General</a></li>
<li><a href="#orgd823d3d">Entidades</a></li>
<li><a href="#orgea390e2">Reglas del Acertijo</a></li>
<li><a href="#orgceae74d">Preguntas para resolver con Prolog</a></li>
</ul>
</li>
<li><a href="#org2fb8b57">Eliza Lisp</a></li>
<li><a href="#org834163a">Implementando ELIZA en Common Lisp</a></li>
<li><a href="#orgc1e441e">Introducción</a></li>
<li><a href="#org0ea45ad">Diferencias conceptuales entre Prolog y Lisp</a></li>
<li><a href="#orgb7e3159">Representación de Templates en Lisp</a></li>
<li><a href="#org9bb2d54">Tokenización del input</a></li>
<li><a href="#orgde263f0">Implementación del MATCH (equivalente a match/2 en Prolog)</a></li>
<li><a href="#org8f89260">Implementación del replace0 (equivalente a replace0/5)</a></li>
<li><a href="#org6f6ea2f">Manejo de FLAGS</a></li>
<li><a href="#org819be53">Búsqueda de la plantilla correcta</a></li>
<li><a href="#orgf113257">Ciclo principal (loop) equivalente al <code>eliza/1</code> de Prolog</a></li>
<li><a href="#org563fe51">Código completo (NÚCLEO de ELIZA)</a></li>
<li><a href="#org754cfaa">Cómo ejecutar ELIZA</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4c8f2b6" class="outline-2">
<h2 id="org4c8f2b6">Conceptos Fundamentales</h2>
<div class="outline-text-2" id="text-org4c8f2b6">
</div>
<div id="outline-container-org1ecab57" class="outline-3">
<h3 id="org1ecab57">Diferentes Estilos de Programación</h3>
<div class="outline-text-3" id="text-org1ecab57">
</div>
<div id="outline-container-orgf0ddf59" class="outline-4">
<h4 id="orgf0ddf59">Estilos de Programación</h4>
<div class="outline-text-4" id="text-orgf0ddf59">
<p>
(también llamados estándares de código o convención de código) es un
término que describe convenciones para escribir código fuente en
ciertos lenguajes de programación. El estilo de programación es
frecuentemente dependiente del lenguaje de programación que se haya
elegido para escribir. Por ejemplo el estilo del lenguaje de
Programación C variará con respecto al del lenguaje BASIC. <sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>
</div>
</div>


<div id="outline-container-orgb61d021" class="outline-4">
<h4 id="orgb61d021">Características del Estilo</h4>
<div class="outline-text-4" id="text-orgb61d021">
<p>
na pieza clave para un buen estilo es la elección apropiada de
ombres de variable. Variables pobremente nombradas dificultan la
ectura del código fuente y su comprensión.
</p>

<p>
omo ejemplo, considérese el siguiente extracto de pseudocódigo:
</p>

<div class="org-src-container">
<pre class="src src-C">t a b <span style="color: #228b22;">c</span> 
 <span style="color: #a0522d;">a</span> &lt; 24 and b &lt; 60 and c &lt; 60
<span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>
se
<span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>
</pre>
</div>

<p>
ebido a la elección de nombres de variable, es difícil darse cuenta
e la función del código. Compárese ahora con la siguiente versión:
</p>


<div class="org-src-container">
<pre class="src src-C">et horas minutos segundos 
<span style="color: #228b22;">f</span> <span style="color: #a0522d;">horas</span> &lt; 24 and minutos &lt; 60 and segundos &lt; 60
 <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>
lse
 <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>
</pre>
</div>

<p>
La intención el código es ahora más sencilla de discernir, "dado una
hora en 24 horas, se devolverá true si es válida y false si no".
</p>
</div>
</div>


<div id="outline-container-org04fae47" class="outline-4">
<h4 id="org04fae47">Nombres de Variable Apropiadas.</h4>
<div class="outline-text-4" id="text-org04fae47">
<p>
Una piedra clave para un buen estilo es la elección apropiada de
nombres de variable. Variables pobremente nombradas dificultan la
lectura del código fuente y su comprensión.  y Como ejemplo,
considérese el siguiente extracto de pseudocódigo:
</p>

<div class="org-src-container">
<pre class="src src-C">et a b c
<span style="color: #228b22;">f</span> <span style="color: #a0522d;">a</span> &lt; 24 and b &lt; 60 and c &lt; 60
 <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>
lse
 <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>
</pre>
</div>

<p>
Debido a la elección de nombres de variable, es difícil darse cuenta
de la función del código. Compárese ahora con la siguiente versión:
</p>

<div class="org-src-container">
<pre class="src src-C">get horas <span style="color: #228b22;">minutos</span> <span style="color: #a0522d;">segundos</span> 
<span style="color: #a020f0;">if</span> horas &lt; 24 and minutos &lt; 60 and segundos &lt; 60
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>
<span style="color: #a020f0;">else</span>
  <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>
</pre>
</div>

<p>
La intención el código es ahora más sencilla de discernir, "dado una
hora en 24 horas, se devolverá true si es válida y false si no".
</p>
</div>
</div>

<div id="outline-container-org9bf557d" class="outline-4">
<h4 id="org9bf557d">Estilo de indentación</h4>
<div class="outline-text-4" id="text-org9bf557d">
<p>
Estilo de indentación, en lenguajes de programación que usan llaves
para indentar o delimitar bloques lógicos de código, como por
ejemplo C, es también un punto clave el buen estilo. Usando un
estilo lógico y consistente hace el código de uno más
legible. Compárese:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a020f0;">if</span><span style="color: #707183;">(</span>horas &lt; 24 &amp;&amp; minutos &lt; 60 &amp;&amp; segundos &lt; 60<span style="color: #707183;">){</span>
   <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
<span style="color: #707183;">}</span><span style="color: #a020f0;">else</span><span style="color: #707183;">{</span>
   <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
<span style="color: #707183;">}</span>
</pre>
</div>
<p>
o bien:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #a020f0;">if</span><span style="color: #707183;">(</span>horas &lt; 24 &amp;&amp; minutos &lt; 60 &amp;&amp; segundos &lt; 60<span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
   <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;
<span style="color: #707183;">}</span>
<span style="color: #a020f0;">else</span>
<span style="color: #707183;">{</span>
   <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
con algo como:
</p>

<div class="org-src-container">
<pre class="src src-C">
<span style="color: #a020f0;">if</span><span style="color: #707183;">(</span>horas&lt;24&amp;&amp;minutos&lt;60&amp;&amp;segundos&lt;60<span style="color: #707183;">){</span><span style="color: #a020f0;">return</span> <span style="color: #008b8b;">true</span>;<span style="color: #707183;">}</span>
<span style="color: #a020f0;">else</span><span style="color: #707183;">{</span><span style="color: #a020f0;">return</span> <span style="color: #008b8b;">false</span>;<span style="color: #707183;">}</span>
</pre>
</div>

<p>
Los primeros dos ejemplos son mucho más fáciles de leer porque están
bien indentados, y los bloques lógicos de código se agrupan y se
representan juntos de forma más clara.
</p>

<p>
Valores booleanos en estructuras de decisión Algunos programadores
piensan que las estructuras de decisión como las anteriores, donde el
resultado de la decisión es meramente una computación de un valor
booleano, son demasiado prolijos e incluso propensos al
error. Prefieren hacer la decisión en la computación por sí mismo,
como esto:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #a020f0;">return</span> horas &lt; 12 &amp;&amp; minutos &lt; 60 &amp;&amp; segundos &lt; 60;
</pre>
</div>

<p>
La diferencia es, con frecuencia, puramente estilística y sintáctica,
ya que los compiladores modernos producirán código objeto idéntico en
las dos formas.
</p>
</div>
</div>

<div id="outline-container-orga27ddaa" class="outline-4">
<h4 id="orga27ddaa">Bucles y estructuras de control</h4>
<div class="outline-text-4" id="text-orga27ddaa">
<p>
El uso de estructuras de control lógicas para bucles también es parte
de un buen estilo de programación. Ayuda a alguien que esté leyendo
el código a entender la secuencia de ejecución (en programación
imperativa). Por ejemplo, el siguiente pseudocódigo:
</p>

<div class="org-src-container">
<pre class="src src-C">
   cuenta = 0
   <span style="color: #a020f0;">while</span> cuenta &lt; 5
     print cuenta * 2
     cuenta = cuenta + 1
   endwhile
</pre>
</div>

<p>
El extracto anterior cumple con las dos recomendaciones de estilo
anteriores, pero el siguiente uso de la construcción for hace el
código mucho más fácil de leer:
</p>

<div class="org-src-container">
<pre class="src src-C">
<span style="color: #a020f0;">for</span> cuenta = 0, cuenta &lt; 5, cuenta=cuenta+1
  print cuenta * 2
</pre>
</div>

<p>
En muchos lenguajes, el patrón frecuentemente usado "por cada elemento
en un rango" puede ser acortado a:
</p>

<div class="org-src-container">
<pre class="src src-C">
 <span style="color: #a020f0;">for</span> cuenta = 0 to 5
   print cuenta * 2
</pre>
</div>
</div>
</div>

<div id="outline-container-org47d8a3b" class="outline-4">
<h4 id="org47d8a3b">Espaciado</h4>
<div class="outline-text-4" id="text-org47d8a3b">
<p>
Los lenguajes de formato libre ignoran frecuentemente los espacios
en blanco. El buen uso del espaciado en la disposición del código
de uno es, por tanto, considerado un buen estilo de programación.
</p>

<p>
Compárese el siguiente extracto de código C:
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">cuenta</span>; <span style="color: #a020f0;">for</span><span style="color: #707183;">(</span>cuenta=0;cuenta&lt;10;cuenta++<span style="color: #707183;">)</span>
printf<span style="color: #707183;">(</span><span style="color: #8b2252;">"%d"</span>,cuenta*cuenta+cuenta<span style="color: #707183;">)</span>;<span style="color: #88090B;">}</span>
</pre>
</div>
<p>
con:
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #228b22;">int</span> <span style="color: #a0522d;">cuenta</span>;
<span style="color: #a020f0;">for</span> <span style="color: #707183;">(</span>cuenta = 0; cuenta &lt; 10; cuenta++<span style="color: #707183;">)</span>
<span style="color: #707183;">{</span>
   printf<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"%d"</span>, cuenta * cuenta + cuenta<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<p>
En los lenguajes de programación de la familia C se recomienda también
evitar el uso de caracteres tabulador en medio de una línea, ya que
diferentes editores de textos muestran su anchura de forma diferente.
</p>

<p>
El lenguaje de programación Python usa indentación para indicar
estructuras de control, por tanto se requiere obligatoriamente una
buena indentación. Haciendo esto, la necesidad de marcar con llaves ({
y }) es eliminada, y la legibilidad es mejorada sin interferir con los
estilos de codificación comunes.
</p>


<p>
Con todo, esto lleva frecuentemente a problemas donde el código es
copiado y pegado dentro de un programa Python, requiriendo un
tedioso reformateado. Adicionalmente, el código Python se vuelve
inusable cuando es publicado en un foro o página web que elimine el
espacio en blanco.
</p>
</div>
</div>

<div id="outline-container-org21199dd" class="outline-4">
<h4 id="org21199dd">Evaluación de expresiones</h4>
<div class="outline-text-4" id="text-org21199dd">
<p>
En general, salvo que se relacionen con las mencionadas sentencias modificadoras del 
flujo, las palabras-clave señalan al compilador aspectos complementarios que no
alteran el orden de ejecución dentro de la propia sentencia. Este orden viene 
determinado por cuatro condicionantes:
</p>

<ol class="org-ol">
<li>Presencia de paréntesis que obligan a un orden de evaluación
específico.</li>
<li>Naturaleza de los operadores involucrados en la expresión
(asociatividad).</li>
<li>Orden en que están colocados (precedencia).</li>
<li>Providencias (impredecibles) del compilador relativas a la
optimización del código.</li>
</ol>
</div>
</div>
</div>



<div id="outline-container-org92a5ac2" class="outline-3">
<h3 id="org92a5ac2">Analizando diferentes estilos de Programación</h3>
</div>


<div id="outline-container-org51881de" class="outline-3">
<h3 id="org51881de">Paradigma de Programación</h3>
<div class="outline-text-3" id="text-org51881de">
<p>
Un paradigma de programación es una propuesta tecnológica adoptada por
una comunidad de programadores y desarrolladores cuyo núcleo central
es incuestionable en cuanto que únicamente trata de resolver uno o
varios problemas claramente delimitados; la resolución de estos
problemas debe suponer consecuentemente un avance significativo en al
menos un parámetro que afecte a la ingeniería de software.
</p>
</div>


<div id="outline-container-org8732436" class="outline-4">
<h4 id="org8732436">Tipos más comunes de paradigmas de programación</h4>
<div class="outline-text-4" id="text-org8732436">
</div>
<ul class="org-ul">
<li><a id="org3ab077e"></a>Programación imperativa o por procedimientos:<br />
<div class="outline-text-5" id="text-org3ab077e">
<p>
 Es el más usado en general, se basa en dar instrucciones al ordenador
de como hacer las cosas en forma de algoritmos. La programación
imperativa es la más usada y la más antigua, el ejemplo principal
es el lenguaje de máquina. Ejemplos de lenguajes puros de este
paradigma serían el C, BASIC o Pascal.
</p>
</div>
</li>

<li><a id="org5ae4486"></a>Programación orientada a objetos:<br />
<div class="outline-text-5" id="text-org5ae4486">
<p>
Está basada en el imperativo, pero encapsula elementos denominados
objetos que incluyen tanto variables como funciones. Está
representado por C++, C#, Java o Python entre otros, pero el más
representativo sería el Smalltalk que está completamente orientado a
objetos.
</p>
</div>
</li>


<li><a id="org1460763"></a>Programación dinámica:<br />
<div class="outline-text-5" id="text-org1460763">
<p>
 está definida como el proceso de romper
problemas en partes pequeñas para analizarlos y resolverlos de forma
lo más cercana al óptimo, busca resolver problemas en O(n) sin usar
por tanto métodos recursivos. Este paradigma está más basado en el
modo de realizar los algoritmos, por lo que se puede usar con
cualquier lenguaje imperativo.
</p>
</div>
</li>

<li><a id="org3675e6f"></a>Programación dirigida por eventos:<br />
<div class="outline-text-5" id="text-org3675e6f">
<p>
la programación dirigida por
eventos es un paradigma de programación en el que tanto la estructura
como la ejecución de los programas van determinados por los sucesos
que ocurran en el sistema, definidos por el usuario o que ellos
mismos provoquen.
</p>
</div>
</li>


<li><a id="org5a00c93"></a>Programación declarativa:<br />
<div class="outline-text-5" id="text-org5a00c93">
<p>
 está basado en describir el problema
declarando propiedades y reglas que deben cumplirse, en lugar de
instrucciones. Hay lenguajes para la programación funcional, la
programación lógica, o la combinación lógico-funcional. Unos de los
primeros lenguajes funcionales fueron Lisp y Prolog.
</p>
</div>
</li>

<li><a id="org0f6f023"></a>Programación funcional:<br />
<div class="outline-text-5" id="text-org0f6f023">
<p>
La programación funcional es un paradigma de programación declarativa
basado en el uso de verdaderas funciones matemáticas. En este estilo
de programación las funciones son ciudadanas de primera clase, porque
sus expresiones pueden ser asignadas a variables como se haría con
cualquier otro valor; además de que pueden crearse funciones de orden
superior.​
</p>

<p>
La programación funcional tiene sus raíces en el cálculo lambda, un
sistema formal desarrollado en los años 1930 para investigar la
naturaleza de las funciones, la naturaleza de la computabilidad y su
relación con la recursión. Los lenguajes funcionales priorizan el uso
de recursividad y aplicación de funciones de orden superior para
resolver problemas que en otros lenguajes se resolverían mediante
estructuras de control (por ejemplo, ciclos). Algunos lenguajes
funcionales también buscan eliminar la mutabilidad o efectos
secundarios; en contraste con la programación imperativa, que se basa
en los cambios de estado mediante la mutación de variables. Esto
significa que, en programación funcional pura, dos o más expresiones
sintácticas idénticas (por ejemplo, dos llamadas a rutinas o dos
evaluaciones) siempre devolverán el mismo resultado. Es decir, se
tiene transparencia referencial. Lo anterior también puede ser
aprovechado para diseñar estrategias de evaluación que eviten repetir
el cómputo de expresiones antes vistas, ahorrando tiempo de ejecución.
</p>

<p>
Los lenguajes de programación funcional, especialmente los puramente
funcionales, han sido enfatizados en el ambiente académico y no tanto
en el desarrollo comercial o industrial. Sin embargo, lenguajes de
programación funcional como Lisp (Scheme, Common Lisp, etc.), Erlang,
Rust, Objective Caml, Scala, F# y Haskell, han sido utilizados en
aplicaciones comerciales e industriales por muchas
organizaciones. También es utilizada en la industria a través de
lenguajes de dominio específico como R (estadística), Mathematica
(cómputo simbólico), J y K (análisis financiero). Los lenguajes de uso
específico usados comúnmente como SQL y Lex/Yacc, utilizan algunos
elementos de programación funcional, especialmente al procesar valores
mutables. Las hojas de cálculo también pueden ser consideradas
lenguajes de programación funcional.
</p>
</div>
</li>

<li><a id="orge72334d"></a>Programación lógica:<br />
<div class="outline-text-5" id="text-orge72334d">
<p>
basado en la definición de relaciones lógicas,
 está representado por Prolog.
</p>
</div>
</li>


<li><a id="orgb402b85"></a>Programación con restricciones:<br />
<div class="outline-text-5" id="text-orgb402b85">
<p>
similar a la lógica usando
 ecuaciones. Casi todos los lenguajes son variantes del Prolog.
</p>
</div>
</li>

<li><a id="org4692a28"></a>Programación multiparadigma:<br />
<div class="outline-text-5" id="text-org4692a28">
<p>
es el uso de dos o más paradigmas dentro
  de un programa. El lenguaje Lisp se considera multiparadigma. Al
  igual que Python, que es orientado a objetos, reflexivo, imperativo y
  funcional.1
</p>
</div>
</li>

<li><a id="org07e70e2"></a>Lenguaje específico del dominio o DSL:<br />
<div class="outline-text-5" id="text-org07e70e2">
<p>
se denomina así a los
  lenguajes desarrollados para resolver un problema específico,
  pudiendo entrar dentro de cualquier grupo anterior. El más
  representativo sería SQL para el manejo de las bases de datos, de
  tipo declarativo, pero los hay imperativos, como el Logo.
</p>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-org6f74aa3" class="outline-3">
<h3 id="org6f74aa3">Evaluación de expresiones</h3>
</div>

<div id="outline-container-orgac43bf1" class="outline-3">
<h3 id="orgac43bf1">Tipos de datos</h3>
</div>

<div id="outline-container-orga9f34c1" class="outline-3">
<h3 id="orga9f34c1">Disciplina de tipos</h3>
</div>

<div id="outline-container-orgfd148cf" class="outline-3">
<h3 id="orgfd148cf">Funciones</h3>
</div>
</div>

<div id="outline-container-org2606c9a" class="outline-2">
<h2 id="org2606c9a">Programación Funcional</h2>
<div class="outline-text-2" id="text-org2606c9a">
<p>
La programación funcional, o mejor dicho, los lenguajes de
programación funcionales, son aquellos lenguajes donde las variables
no tienen estado — no hay cambios en éstas a lo largo del tiempo — y
son inmutables — no pueden cambiarse los valores a lo largo de la
ejecución. Además los programas se estructuran componiendo expresiones
que se evalúan como funciones. Dentro de los lenguajes funcionales
tenemos Lisp, Scheme, Clojure, Haskell, OCaml y Standard ML, entre
otros.  Estos lenguajes están diversidad de tipificación, donde se
encuentran lenguajes dinámicos, estáticos y estáticos fuertes.
</p>


<p>
En los lenguajes funcionales las instrucciones cíclicas como for,
while y do-while no existen. Todo se procesa usando recursividad y
funciones de alto orden.
</p>

<p>
Esto se debe a los fundamentos matemáticos de la mayoría de los
lenguajes funcionales, principalmente con bases en el sistema formal
diseñado por Alonzo Church para definir cómputos y estudiar las
aplicaciones de las funciones llamado Cálculo Lambda. En este sistema
formal se puede expresar recursividad en las funciones, y entre otras
cosas interesantes, se pueden expresar combinadores — funciones sin
variables libres — como el Combinador de Punto Fijo o Y-Combinator,
que expresa recursividad sin hacer llamadas recursivas.
</p>

<p>
En el Cálculo Lambda existen tres transformaciones esenciales, la
conversión \(α\), la reducción \(β\) y la conversión \(η\). En la conversión
α se sustituyen los nombres de las variables para dar mas claridad a
la aplicación de las funciones, por ejemplo evitando duplicados en sus
nombres. En la reducción \(β\) se traza el llamado de las funciones
sustituyendo las funciones por sus expresiones resultantes.
</p>

<p>
Finalmente en las conversiones η se busca las equivalencias de trazado
de funciones sustituyéndolas por sus equivalentes. Estas
transformaciones también pueden ser aplicadas en los lenguajes
funcionales — o en su mayoría — dando lugar lenguajes que cuentan con
una gran expresividad y consistencia.
</p>


<p>
Les pondré el clásico ejemplo del chiste geek del castigo “Debo poner
atención en clases”. La respuesta geek expresada en PHP esta escrita a
continuación.  Donde PHP es un lenguaje dinámico, no necesita declarar
variables y es un lenguaje orientado a objetos con raíces imperativas.
Sus instrucciones son paso a paso, y no constituyen una única
expresión reducible.
</p>

<div class="org-src-container">
<pre class="src src-C">&lt;?php
    <span style="color: #b22222;">/* </span><span style="color: #b22222;">codigo PHP</span><span style="color: #b22222;"> */</span>
    <span style="color: #a020f0;">for</span> <span style="color: #707183;">(</span>$i = 0; $i &lt; 500; $i++<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
        echo <span style="color: #8b2252;">"Debo poner atenci&#243;n en clase"</span>;
    <span style="color: #707183;">}</span>
 ?&gt;
</pre>
</div>

<p>
Si usamos Haskell como ejemplo, que es un lenguaje funcional con
tipificación estática fuerte, requiere que las variables sean
declaradas con un tipo — la mayoría de las veces — y es muy expresivo,
donde el siguiente ejemplo dice repetir la cadena, tomar 500 elementos
y con esa lista ejecutar la función monádica putStrLn, que esta hecha
para el Monad IO e imprime  el mensaje las 500 veces solicitada.
</p>


<div class="org-src-container">
<pre class="src src-C"> <span style="color: #228b22;">module</span> <span style="color: #0000ff;">Main</span> <span style="color: #707183;">(</span>main<span style="color: #707183;">)</span> where

 -- codigo Haskell

 main :: IO <span style="color: #707183;">()</span>
 main = mapM_ putStrLn $ take 500 $ repeat <span style="color: #8b2252;">"Debo poner atenci&#243;n"</span>
</pre>
</div>


<p>
En Lisp sería similar, pero Lisp es de tipificación dinámica y no
necesita declarar variables, dando lugar a un programa muy simple de
una sola linea.  Donde también tenemos lenguajes como Clojure, que es
un dialecto de Lisp y soporta construcciones muy similares a las del
ejemplo en Lisp, dando lugar a programas expresivos y simples, pero
que corren sobre la máquina virtual de Java o JVM.
</p>


<div class="org-src-container">
<pre class="src src-lisp"> <span style="color: #b22222;">;;; </span><span style="color: #b22222;">codigo Lisp</span>

 <span style="color: #707183;">(</span><span style="color: #a020f0;">loop</span> repeat 500 do <span style="color: #7388d6;">(</span>format t <span style="color: #8b2252;">"Debo poner atencion en clases~%"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>


<p>
Un ejemplo clásico para la conversión η en Haskell, es reducir las
llamadas a funciones en su combinador de identidad. Por ejemplo se
tiene la función \(f(g(x))\), que en Cálculo Lambda se expresa como
\(λx.(λy.y)x\), se puede reducir a \(g(x)\), que se expresa como \(λy.y\) en
Cálculo Lambda. Esto expresado en Haskell, se vería como el siguiente
ejemplo, donde absN y absN’ son funciones equivalentes y absN’ es la
reducción \(η\) de absN.
</p>



<div class="org-src-container">
<pre class="src src-haskell"> absN :: Num a =&gt; a -&gt; a
 absN n = abs n

 absN' :: Num a =&gt; a -&gt; a
 absN' = abs
</pre>
</div>


<p>
Actualmente los lenguajes orientados a objetos más comunes están
integrando características funcionales, como Java, que acaba de
incluir funciones anonimas.  Pero también están los lenguajes que a lo
largo de su historia han sido multi-paradigma, como Python, e
implementa características funcionales, procedurales y orientadas a
objetos. El bien conocido algoritmo para verificar si un RUT es válido
o no, se puede expresar funcionalmente en Python como esta escrito en
el siguiente ejemplo.
</p>


<div class="org-src-container">
<pre class="src src-python"><span style="background-color: #f2f2f2;"> </span><span style="color: #a020f0;">def</span> <span style="color: #0000ff;">val_rut</span><span style="color: #707183;">(</span>rut<span style="color: #707183;">)</span>:
<span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span><span style="color: #8b2252;">"""</span>
<span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">   </span><span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">Valida un string con un RUT con el guion incluido, retornando</span>
<span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">   </span><span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">cero si es valido.</span>

<span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">   </span><span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">Ejemplo: print(val_rut("22222222-2"))</span>
<span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">   </span><span style="color: #8b2252; background-color: #f2f2f2;"> </span><span style="color: #8b2252;">"""</span>
<span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span><span style="color: #a020f0;">return</span> <span style="color: #483d8b;">cmp</span><span style="color: #707183;">(</span>rut<span style="color: #7388d6;">[</span>-1<span style="color: #7388d6;">]</span>,
                <span style="color: #483d8b;">str</span><span style="color: #7388d6;">(</span><span style="color: #909183;">(</span><span style="color: #483d8b;">range</span><span style="color: #709870;">(</span>10<span style="color: #709870;">)</span> + <span style="color: #709870;">[</span><span style="color: #8b2252;">'K'</span><span style="color: #709870;">]</span><span style="color: #909183;">)[</span>
<span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="color: #709870;">(</span>11 - <span style="color: #483d8b;">sum</span><span style="color: #907373;">(</span><span style="color: #483d8b;">map</span><span style="color: #6276ba;">(</span><span style="color: #a020f0;">lambda</span> x: <span style="color: #858580;">(</span><span style="color: #483d8b;">int</span><span style="color: #80a880;">(</span>x<span style="color: #887070;">[</span>0<span style="color: #887070;">]</span><span style="color: #80a880;">)</span> * x<span style="color: #80a880;">[</span>1<span style="color: #80a880;">]</span><span style="color: #858580;">)</span>,
<span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span> <span style="color: #483d8b;">zip</span><span style="color: #858580;">(</span><span style="color: #483d8b;">reversed</span><span style="color: #80a880;">(</span>rut<span style="color: #887070;">[</span>:-2<span style="color: #887070;">]</span><span style="color: #80a880;">)</span>,
<span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span>   <span style="background-color: #f2f2f2;"> </span> <span style="color: #80a880;">(</span>2 * <span style="color: #483d8b;">range</span><span style="color: #887070;">(</span>2, 8<span style="color: #887070;">)</span><span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span> % 11<span style="color: #709870;">)</span><span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

</pre>
</div>


<p>
Como se aprecia en el ejemplo, la validación se realiza utilizando
 expresiones o llamadas a funciones, sin uso de variables con estado y
 mutabilidad, donde cada llamada a una función se puede reducir a un
 valor determinado, y como resultado final se tiene un valor cero o
 distinto de cero que indica si el RUT es válido.  Este mismo
 algoritmo funcional, se puede expresar en Haskell con llamadas muy
 similares, debido a que los nombres de las funciones y funciones de
 alto orden son bastante comunes entre los lenguajes funcionales.
</p>


<div class="org-src-container">
<pre class="src src-haskell">valRut :: String -&gt; Bool
valRut s = (((['0'..'9'] ++ ['K'])
             !! (11 - sum(zipWith (*)
                          (fmap digitToInt $ drop 2 $ reverse s)
                          (take 10 $ cycle [2..7])) `mod` 11)) == (last s))
</pre>
</div>


<p>
De estos dos ejemplos, se puede decir que son funciones puras,
principalmente debido a que no tienen variables libres y son una única
expresión sin estado y no mutable a lo largo de la ejecución. El
problema de la pureza es conceptualmente algo que se idealiza en la
programación funcional, siendo abordado de diferentes formas por
diferentes lenguajes. El objetivo es mantener las funciones y rutinas
puras. En Haskell, con su abstracción más clásica conocida con el
nombre de Mónada, permite entregar pureza a expresiones que parecen no
ser puras, y en términos muy sencillos el Mónada reúne una identidad y
una composición de funciones del tipo \(f(g(x))\), todo a través de un
tipo de dato que permite componer funciones sin abandonar ese tipo de
dato y darle un aspecto procedural.
</p>
</div>
</div>

<div id="outline-container-org7a21e4b" class="outline-2">
<h2 id="org7a21e4b">Lisp</h2>
<div class="outline-text-2" id="text-org7a21e4b">
<p>
Lisp (históricamente LISP) es una familia de lenguajes de programación
de computadora de tipo multiparadigma con larga historia y una
inconfundible y útil sintaxis homoicónica basada en la notación
polaca.
</p>

<p>
Desarrollado originalmente en 1959 por John McCarthy y sus
colaboradores en el Instituto Tecnológico de Massachusetts, Lisp es el
segundo lenguaje de programación de alto nivel de mayor antigüedad;
apareció un año después de FORTRAN y uno antes que COBOL.
</p>

<p>
Al igual que COBOL y FORTRAN, Lisp ha cambiado mucho desde sus
comienzos, y han existido un gran número de dialectos en su
historia. Hoy, los dialectos de Lisp más ampliamente usados son Scheme
(1975), Common Lisp (1984), Emacs Lisp (1985) y Clojure (2007).
</p>

<p>
Lisp fue creado originalmente como una notación matemática práctica
para los programas de computadora, basada en el cálculo lambda de
Alonzo Church. Se convirtió rápidamente en el lenguaje de programación
favorito en la investigación de la inteligencia artificial (AI). Como
lenguajes de programación precursor, Lisp fue pionero en muchas ideas
en ciencias de la computación, incluyendo las estructuras de datos de
árbol, el manejo de almacenamiento automático, tipos dinámicos, y el
compilador auto contenido.
</p>

<p>
El acrónimo LISP significa "LISt Processor" ('Procesamiento de
listas'). Las listas encadenadas son una de las estructuras de datos
importantes de Lisp, y el código fuente de Lisp en sí mismo está
compuesto de listas. Como resultado, los programas de Lisp pueden
manipular código fuente de Lisp como si fueran simples datos, dando
lugar a sistemas de macros que permiten a los programadores crear
lenguajes de dominio específico embebidos en Lisp.
</p>

<p>
La intercambiabilidad del código y los datos también da a Lisp su
instantáneamente reconocible sintaxis. Todo el código del programa es
escrito como expresiones S, o listas entre paréntesis. Una llamada de
función o una forma sintáctica es escrita como una lista, con la
función o el nombre del operador en primer lugar, y los argumentos a
continuación; por ejemplo, una función f que toma tres argumentos
puede ser llamada usando (f x y z).
</p>
</div>

<div id="outline-container-org2552bbe" class="outline-3">
<h3 id="org2552bbe">Historia</h3>
<div class="outline-text-3" id="text-org2552bbe">
<p>
El proyecto se inició en 1987, cuando los autores originales, Bruno
Haible y Michael Stoll, aún eran estudiantes en Alemania. La versión
original sólo era para Atari ST y estaba escrito en lenguaje
ensamblador del Motorola 68000 y Lisp. En 1992 se anunció la versión
2.0 para Linux en comp.os.linux, aunque sólo en formato binario.
</p>

<p>
Inicialmente Bruno Haible no tenía la intención de distribuir CLISP
bajo la licencia GPL, pero tras un debate público en octubre de 1992
en la lista de correo del proyecto4​ con Richard Stallman, cambió de
opinión. El inicio de este debate fue la reclamación por parte de
Richard Stallman para que cambiase la licencia CLISP a la GPL al
considerar que era un trabajo derivado de la biblioteca GNU readline
que se había empezado a usar en el proyecto poco sobre aquellas
fechas.
</p>

<p>
En 1993 apareció la primera versión portable, en la que se incluía el
código fuente bajo licencia GNU GPL. Esta versión estaba disponible
para Atari ST, Amiga 500-2000, MS-DOS (emx, djgpp), OS/2 (emx), Unix
(Linux, Sun4, Sun386, HP9000/800). A finales de 1993 apareció la
versión 2.6 que incluía soporte para CLOS. Para finales de ese año
apareció la versión 2.8 que sumó el paquete COMMON-LISP, que es el
contiene las primitivas del sistema Common Lisp tal y como se definen
en la especificación del lenguaje. En la versión 2.14 de 1995 se
incorporó la interfaz FFI (Foreign Function Interface) que permite
llamar a funciones C desde CLISP y hacer disponibles funciones CLISP
desde C.
</p>

<p>
Desde el año 2000, el proyecto se aloja en sourceforge.net5​ que le
proporciona los recursos necesarios para poder continuar con su
desarrollo.
</p>


<p>
<a href="https://es.wikipedia.org/wiki/Lisp">Fuente</a>
</p>


<p>
clisp
</p>
</div>
</div>


<div id="outline-container-org81545c2" class="outline-3">
<h3 id="org81545c2">Programación en Lisp</h3>
</div>
<div id="outline-container-org08acd8b" class="outline-3">
<h3 id="org08acd8b">Expresiones</h3>
<div class="outline-text-3" id="text-org08acd8b">
<p>
Es particularmente cierto que la mejor forma de aprender Lisp es
usándolo, porque se trata de un lenguaje interactivo. Cualquier
sistema Lisp, incluye una interfaz interactiva llamada top-level. Uno
escribe expresiones Lisp en el top-level, y el sistema despliega sus
valores. El sistema normalmente despliega un indicador llamado prompt
(&gt;) señalando que está esperando que una expresión sea escrita. Por
ejemplo, si escribímos el entero 1 después del prompt y tecleamos
enter, tenemos:
</p>

<div class="org-src-container">
<pre class="src src-lisp">&gt; 1
1
</pre>
</div>

<p>
el sistema despliega el valor de la expresión, seguida de un nuevo prompt,
indicando que está listo para evaluar una nueva expresión. En este caso, el
sistema desplegó lo mismo que tecleamos porque los números, como otras
constantes, evalúan a si mismos. Las cosas son más interesantes cuando una
expresión
</p>

<div class="org-src-container">
<pre class="src src-lisp">&gt; <span style="color: #707183;">(</span>+ 2 3<span style="color: #707183;">)</span>
5
</pre>
</div>

<p>
En la expresión (+ 2 3) el símbolo + es llamado el operador y los números 3 y 4 son sus argumentos (o parámetros actuales, siguendo la notación
introducida en el capítulo anterior). Como el operador viene al principio de
la expresión, esta notación se conoce como prefija y aunque parezca extraña,
veremos que es muy práctica. Por ejemplo, si queremos sumar tres números
en notación infija, necesitaríamos usar dos veces el operador +: 2+3+4. En
Lisp, las siguientes sumas son válidas:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>+<span style="color: #707183;">)</span>
0
<span style="color: #707183;">(</span>+ 2<span style="color: #707183;">)</span>
2
<span style="color: #707183;">(</span>+ 2 3<span style="color: #707183;">)</span>
5
<span style="color: #707183;">(</span>+ 2 3 5<span style="color: #707183;">)</span>
10
</pre>
</div>

<p>
Como los operadores pueden tomar un número variable de argumentos,
es necesario utilizar los paréntesis para indicar donde inicia y donde termina
una expresión. Las expresiones pueden anidarse, esto es, el argumento de
una expresión puede ser otra expresión compleja. Ej.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>/ <span style="color: #7388d6;">(</span>- 7 1<span style="color: #7388d6;">)(</span>- 4 2<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
3
</pre>
</div>

<p>
En español esto corresponde a siete menos uno, dividido por cuatro
menos dos.  Estética minimalista, esto es todo lo que hay que decir
sobre la notación en Lisp. Toda expresión Lisp es un átomo, como 1, o
bien es una lista que consiste de cero o más expresiones delimitadas
por paréntesis. Como veremos, código y datos usan la misma notación en
Lisp.
</p>


<p>
4 + 5 / 34 + 67 * 2 
4 + (/ 5 34) + (* 67 2)
A= (/ 5 34)
B= (* 67 2)
4 + A + B
(+ 4 A) + B
C = (+ 4 A)
C + B
</p>
<ul class="org-ul">
<li>C B</li>
<li>4 5</li>
</ul>


<p>
(load "/home/likcos/Materias/Prolog/public/src/ejemplo1.lisp")
</p>

<p>
Para cargar en un archivo y ejecutarlo en clisp se utiliza la función load. 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>load <span style="color: #8b2252;">"path"</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>load <span style="color: #8b2252;">"/home/likcos/Materias/Prolog/public/src/ejemplo1.lisp"</span><span style="color: #707183;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hola</span><span style="color: #7388d6;">()</span>
<span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Hola mundo Prolog"</span> <span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>hola '<span style="color: #707183;">)</span>
</pre>
</div>




<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">suma</span><span style="color: #7388d6;">(</span>a b<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>+ a b<span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>suma 3 4<span style="color: #707183;">)</span>

</pre>
</div>

<p>
Resolver 
</p>

<ol class="org-ol">
<li>8, 3, -2,-7,-12,</li>
<li>3,6,12,24,48,</li>
<li>4,9,16,25,36,49,</li>
<li>5,10,17,26,37,50,</li>
<li>6,11,18,27,38,51,</li>
<li>3,8,15,24,35,48,</li>
<li>-4,9,-16,25,-36,49,</li>
<li>4,-9,16,-25,36,-49,</li>
<li>\(\cfrac{2}{4},\cfrac{5}{9},\cfrac{8}{16},\cfrac{11}{25},\cfrac{14}{36}\)</li>
<li>\(-5,\cfrac{7}{2},-\cfrac{9}{3},\cfrac{11}{4},-\cfrac{13}{5}\)</li>
</ol>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*pi*</span> 3.1415<span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">areaCirculo</span><span style="color: #7388d6;">(</span>r<span style="color: #7388d6;">)</span>
<span style="color: #7388d6;">(</span>* *pi* <span style="color: #909183;">(</span>* r r<span style="color: #909183;">)</span>  <span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>

'<span style="color: #707183;">(</span>+ 5 6 <span style="color: #707183;">)</span>
eval
</pre>
</div>

<p>
4 + 5 / 34 + 67 * 2 
4 + (/ 5 34) + (* 67 2)
A= (/ 5 34)
B= (* 67 2)
4 + A + B
(+ 4 A) + B
C = (+ 4 A)
C + B
</p>
<ul class="org-ul">
<li>C B</li>
<li>4 5</li>
</ul>


<p>
(load "/home/likcos/Materias/Prolog/public/src/ejemplo1.lisp")
</p>

<p>
Para cargar en un archivo y ejecutarlo en clisp se utiliza la función load. 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>load <span style="color: #8b2252;">"path"</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>load <span style="color: #8b2252;">"/home/likcos/Materias/Prolog/public/src/ejemplo1.lisp"</span><span style="color: #707183;">)</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">hola</span><span style="color: #7388d6;">()</span>
<span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Hola mundo Prolog"</span> <span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>hola '<span style="color: #707183;">)</span>
</pre>
</div>




<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">suma</span><span style="color: #7388d6;">(</span>a b<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>+ a b<span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>suma 3 4<span style="color: #707183;">)</span>

</pre>
</div>

<p>
Resolver 
</p>

<ol class="org-ol">
<li>8, 3, -2,-7,-12,</li>
<li>3,6,12,24,48,</li>
<li>4,9,16,25,36,49,</li>
<li>5,10,17,26,37,50,</li>
<li>6,11,18,27,38,51,</li>
<li>3,8,15,24,35,48,</li>
<li>-4,9,-16,25,-36,49,</li>
<li>4,-9,16,-25,36,-49,</li>
<li>\(\cfrac{2}{4},\cfrac{5}{9},\cfrac{8}{16},\cfrac{11}{25},\cfrac{14}{36}\)</li>
<li>\(-5,\cfrac{7}{2},-\cfrac{9}{3},\cfrac{11}{4},-\cfrac{13}{5}\)</li>
</ol>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*pi*</span> 3.1415<span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">areaCirculo</span><span style="color: #7388d6;">(</span>r<span style="color: #7388d6;">)</span>
<span style="color: #7388d6;">(</span>* *pi* <span style="color: #909183;">(</span>* r r<span style="color: #909183;">)</span>  <span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>

'<span style="color: #707183;">(</span>+ 5 6 <span style="color: #707183;">)</span>
eval
</pre>
</div>
</div>
</div>

<div id="outline-container-org7b421b1" class="outline-3">
<h3 id="org7b421b1">Datos</h3>
<div class="outline-text-3" id="text-org7b421b1">
<p>
Lisp ofrece los tipos de datos que podemos encontrar en otros
lenguajes de programación, y otros que no. Ya hemos usado enteros en
los ejemplos precedentes. Lascadenas de caracteres se delimita por
comillas, por ejemplo, “Hola mundo”. Enteros y cadenas evalúan a ellos
mismos, como las constantes.  Dos tipos de datos propios de Lisp son
los símbolos y las listas. Los símbolos son palabras. Normalmente se
evaluan como si estuvieran escritos en mayúsculas, independientemente
de como fueron tecleados:
</p>

<div class="org-src-container">
<pre class="src src-lisp">'uno
uno
</pre>
</div>

<p>
Los símbolos por lo general no evaluan a si mismos, así que si es
necesario referirse a ellos, se debe usar quote, como en ejemplo
anterior, de lo contrario, se producirá un error ya que el símbolo uno
no está acotado (no tiene ligado ningún valor en este momento).
</p>

<p>
Las listas se representan como cero o más elementos entre paréntesis. Los
elementos pueden ser de cualquier tipo, incluidas las listas. Se debe usar
quote con las listas, ya que de otra forma Lisp las tomaría como una llamada
a función. Veamos algunos ejemplos:
</p>

<div class="org-src-container">
<pre class="src src-lisp">&#8217;<span style="color: #707183;">(</span>Mis 2 <span style="color: #8b2252;">"ciudades"</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>MIS 2 <span style="color: #8b2252;">"CIUDADES"</span><span style="color: #707183;">)</span>
&#8217;<span style="color: #707183;">(</span>La lista <span style="color: #7388d6;">(</span>a b c<span style="color: #7388d6;">)</span> tiene 3 elementos<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>LA LISTA <span style="color: #7388d6;">(</span>A B C<span style="color: #7388d6;">)</span> TIENE 3 ELEMENTOS<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Observen que quote protege a toda la expresión, incluidas las
sub-expresiones en ella. La lista (a b c), tampoco fue
evaluada. También es posible construir listas usando la función list:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>list &#8217;mis <span style="color: #7388d6;">(</span>+ 4 2<span style="color: #7388d6;">)</span> <span style="color: #8b2252;">"colegas"</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>MIS 6 COLEGAS<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Estética minimalista y pragmática, observen que los programas Lisp se
representan como listas. Si el argumento estético no bastará para defender la
notación de Lisp, esto debe bastar –Un programa Lisp puede generar código
Lisp! Por eso es necesario quote. Si una lista es precedida por el operador
quote, la evaluación regresa la misma lista, en otro caso, la lista es evaluada
como si fuese código. Por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>list &#8217;<span style="color: #7388d6;">(</span>+ 2 3<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>+ 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7388d6;">(</span>+ 2 3<span style="color: #7388d6;">)</span> 5<span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8121ed" class="outline-3">
<h3 id="orgf8121ed">Evaluación</h3>
<div class="outline-text-3" id="text-orgf8121ed">
<p>
Veamos más en detalle como las expresiones son evaluadas para
desplegar su valor en el top-level. En Lisp, + es una función y (+
2 3) es una llamada a la función. Cuando Lisp evalúa una llamada a
alguna función, lo hace en dos pasos:
</p>

<ul class="org-ul">
<li>Los argumentos de la llamada son evaluados de izquierda a derecha.
En este caso, los valores de los argumentos son 2 y 3,
respectivamente.</li>

<li>Los valores de los argumentos son pasados a la función nombrada por
el operador. En este caso la función + que regresa 5.</li>
</ul>

<p>
Si alguno de los argumentos es a su vez una llamada de función, será
evaluado con las mismas reglas. Ej. Al evaluar la expresión (/ (- 7 1) (- 4 2))
pasa lo siguiente.
</p>

<ol class="org-ol">
<li>Lisp evalúa el primer argumento de izquierda a derecha (- 7 1). 7 es
evaluado como 7 y 1 como 1. Estos valores son pasados a la función -
que regresa 6.</li>
<li>El siguiente argumento (- 4 2) es evaluado. 4 es evaluado como 4 y 2
como 2. Estos valores son pasados a la función - que regresa 2.</li>
<li>Los valores 6 y 2 son pasados a la función / que regresa 3.</li>
</ol>


<p>
No todos los operadores en Lisp son funciones, pero la mayoría lo son.
Todas las llamadas a función son evaluadas de esta forma, que se conoce
como regla de evaluación de Lisp. Los operadores que no siguen la regla de
evaluación se conocen como operadores especiales. Uno de estos operadores
especiales es quote (’). La regla de evaluación de quote es –No evalues nada,
despliega lo que el usuario tecleo, verbatim. 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>quote <span style="color: #7388d6;">(</span>+ 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>+ 2 3<span style="color: #707183;">)</span>
'<span style="color: #707183;">(</span> + 2 3<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>+ 2 3<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Lisp provee el operador quote como una forma de evitar que una
expresión sea evaluada. En la siguiente sección veremos porque esta
protección puede ser útil.
</p>
</div>
</div>

<div id="outline-container-orgf4a6457" class="outline-3">
<h3 id="orgf4a6457">Funciones en Lisp</h3>
<div class="outline-text-3" id="text-orgf4a6457">
<p>
Es posible definir nuevas funciones con defun que toma normalmente tres
argumentos: un nombre, una lista de parámetros y una o más expresiones
que conforman el cuerpo de la función. Ej. Así definiríamos tercero:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">tercero</span><span style="color: #7388d6;">(</span>lst<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>caddr lst<span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
</pre>
</div>

<p>
El primer argumento de defun indica que el nombre de nuestra función
definida será tercero. El segundo argumento (lst) indica que la
función tiene un sólo argumento, lst. Un símbolo usado de esta forma
se conoce como variable. Cuando la variable representa el argumento de
una función, se conoce como parámetro. El resto de la definición
indica lo que se debe hacer para calcular el valor de la función, en
este caso, para cualquier lst, se calculará el primer elemento, del
resto, del resto del parámetro (caddr lst).
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>tercero '<span style="color: #7388d6;">(</span>a b c d e<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
C
</pre>
</div>

<p>
Ahora que hemos introducido el concepto de variable, es más sencillo
entender lo que es un símbolo. Los símbolos son nombres de variables, que
existen con derechos propios en el lenguaje Lisp. Por ello símbolos y listas
deben protegerse con quote para ser accesados. Una lista debe protegerse
porque de otra forma es procesada como si fuese código; un símbolo debe
protegerse porque de otra forma es procesado como si fuese una variable.
Podríamos decir que la definición de una función corresponde a la versión
generalizada de una expresión Lisp. Ej. La siguiente expresión verifica si la
suma de 1 y 4 es mayor que 3:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span> &gt;<span style="color: #7388d6;">(</span>+ 1 4<span style="color: #7388d6;">)</span> 3<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Substituyendo los números partículares por variables, podemos definir
una función que verifica si la suma de sus dos primeros argumentos es
mayor que el tercero:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">suma-mayor-que</span> <span style="color: #7388d6;">(</span>x  y z<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>&gt; <span style="color: #909183;">(</span>+ x y<span style="color: #909183;">)</span> z<span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>suma-mayor-que 1 4 3<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Lisp no distigue entre programa, procedimiento y función; todos cuentan
como funciones y de hecho, casi todo el lenguaje está compuesto de funciones. Si se desea considerar una función en partícular como main, es posible
hacerlo, pero cualquier función puede ser llamada desde el top-level. Entre
otras cosas, esto significa que posible probar nuestros programas, pieza por
pieza, conforme los vamos escribiendo, lo que se conoce como programación
incremental (bottom-up).
</p>
</div>
</div>

<div id="outline-container-org750aa24" class="outline-3">
<h3 id="org750aa24">Listas</h3>
<div class="outline-text-3" id="text-org750aa24">
<p>
En Lisp, las listas son una estructura de datos fundamental y
versátil. Se utilizan para almacenar una secuencia de elementos, que
pueden ser datos simples como números o cadenas de texto, así como
otras listas, lo que permite crear estructuras de datos
jerárquicas. Las listas en Lisp se representan mediante paréntesis y
los elementos se separan mediante espacios. Aquí tienes una
descripción básica de las listas en Lisp:
</p>

<ol class="org-ol">
<li>Sintaxis: Las listas en Lisp se representan mediante paréntesis. La
lista comienza con un paréntesis abierto "(" y termina con un
paréntesis cerrado ")". Los elementos de la lista se separan
mediante espacios.</li>
</ol>

<p>
Ejemplo de una lista simple en Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>1 2 3 4 5<span style="color: #707183;">)</span>
</pre>
</div>


<ol class="org-ol">
<li>Listas anidadas: Puedes anidar listas dentro de otras listas para
crear estructuras de datos más complejas. Esto permite representar
datos jerárquicos.</li>
</ol>

<p>
Ejemplo de una lista anidada en Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>1 <span style="color: #7388d6;">(</span>2 3<span style="color: #7388d6;">)</span> 4 <span style="color: #7388d6;">(</span>5 <span style="color: #909183;">(</span>6 7<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>


<ol class="org-ol">
<li>Listas vacías: Una lista vacía se representa simplemente como un
par de paréntesis sin ningún elemento en su interior.</li>
</ol>

<p>
Ejemplo de una lista vacía en Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">()</span>
</pre>
</div>


<ol class="org-ol">
<li>Funciones y listas: En Lisp, las listas se utilizan comúnmente para
representar programas y datos. Las funciones se llaman aplicando
una lista, donde el primer elemento de la lista es el nombre de la
función y los elementos subsiguientes son los argumentos.</li>
</ol>

<p>
Ejemplo de una llamada a función en Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>+ 1 2<span style="color: #707183;">)</span>
<span style="color: #b22222;">; </span><span style="color: #b22222;">En este caso, "+" es la funci&#243;n que suma los n&#250;meros 1 y 2.</span>
</pre>
</div>

<ol class="org-ol">
<li>Manipulación de listas: Lisp proporciona una variedad de funciones
para trabajar con listas, como <b><b>car</b></b> (para obtener el primer
elemento de una lista), <b><b>cdr</b></b> (para obtener todos los elementos
excepto el primero), <b><b>cons</b></b> (para construir nuevas listas),
`append` (para concatenar listas), entre otras.</li>
</ol>

<p>
En resumen, las listas en Lisp son una parte fundamental de la
programación y se utilizan para representar datos y programas. Su
flexibilidad y capacidad para anidarse las hacen muy poderosas en la
programación en Lisp.
</p>
</div>
</div>

<div id="outline-container-orge0c5ad5" class="outline-3">
<h3 id="orge0c5ad5">Cons</h3>
<div class="outline-text-3" id="text-orge0c5ad5">
<p>
La función `cons` se utiliza para crear nuevas listas al agregar un
elemento al principio de una lista existente. Su sintaxis es la
siguiente:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>cons elemento lista<span style="color: #707183;">)</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>elemento</b></b> es el elemento que deseas agregar al principio de la lista.</li>
<li><b><b>lista</b></b> es la lista existente a la cual deseas agregar el elemento.</li>
</ul>

<p>
La función <b><b>cons</b></b> toma el elemento especificado y lo coloca al
principio de la lista proporcionada, devolviendo una nueva lista que
contiene el elemento recién añadido al principio. La lista original no
se modifica; en su lugar, se crea una nueva lista con el nuevo
elemento.
</p>

<p>
Un ejemplo de cómo se utiliza la función <b><b>cons*</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq lista-original '<span style="color: #7388d6;">(</span>2 3 4<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>setq nueva-lista <span style="color: #7388d6;">(</span>cons 1 lista-original<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
En este ejemplo, <b><b>lista-original</b></b> contiene <b><b>(2 3 4)</b></b>. Luego, usamos
`cons` para agregar el número <b><b>1</b></b> al principio de <b><b>lista-original</b></b>,
creando una nueva lista llamada <b><b>nueva-lista</b></b>. Después de esta
operación, <b><b>nueva-lista</b></b> será <b><b>(1 2 3 4)</b></b> y <b><b>lista-original</b></b> seguirá
siendo <b><b>(2 3 4)</b></b>.
</p>

<p>
La función <b><b>cons</b></b> es útil para construir y modificar listas en Lisp y
se utiliza con frecuencia en la programación en este lenguaje para
crear estructuras de datos y manipular listas de manera eficiente.
</p>
</div>
</div>





<div id="outline-container-orgd4be993" class="outline-3">
<h3 id="orgd4be993">Funciones CAR y CDR</h3>
<div class="outline-text-3" id="text-orgd4be993">
<p>
CAR admite un único argumento que debe ser una lista o una expresión
cuyo valor sea una lista y devuelve el primer elemento de dicha
lista. Como LISP siempre interpreta una lista como una llamada a una
función, necesitamos una manera de pasar una lista a CAR sin que LISP
trate de procesarla como llamada a función.
</p>

<p>
CDR recibe también una lista y devuelve el resto de la lista después
de eliminar el primer elemento (CAR lista). Por lo tanto puede
contemplarse como la función complementaria de CAR. Una manera de
interpretar una lista en LISP es como la conjunción de un CAR y un
CDR. Se podrá acceder a cualquier término de una lista mediante los
anidamientos apropiados de CAR y CDR.  
</p>

<ul class="org-ul">
<li>(CAR lista) ;primer término</li>
<li>(CAR (CDR lista)) ;segundo término</li>
<li>(CAR (CDR (CDR lista))) ; tercer término</li>
</ul>

<p>
Para simplificar las expresiones se permite crear 
nombres compuestos
para anidamientos de CAR y CDR de la siguiente manera:
</p>
<ul class="org-ul">
<li>comenzando por una primera letra C</li>
<li>una letra A por cada CAR o una D por cada CDR</li>
<li>terminando con una letra R</li>
<li>así (CAR (CDR (CDR lista))) sería lo mismo que (CADDR lista).</li>
</ul>

<p>
De esta manera podemos construir hasta 28 funciones distintas para acceso a
listas. Según Johnson estas 28 concatenaciones se pueden dividir en
cuatro grupos, tomando como base la profundidad a que pueden acceder
en listas anidadas en varios niveles.
</p>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;</span><span style="color: #b22222;">(eval (car '((+ 1 2) 2 3 4 5)))</span>
<span style="color: #707183;">(</span>cadr '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #b22222;">;</span><span style="color: #b22222;">(cddd  '((1 2 3 4 5) (6 7 8 9 10) (11 12 13 14 15)))</span>

</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span><span style="color: #707183;">)</span>


</pre>
</div>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">mylength</span> <span style="color: #7388d6;">(</span>list<span style="color: #7388d6;">)</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">if</span> list 
    <span style="color: #909183;">(</span>1+ <span style="color: #709870;">(</span>mylength <span style="color: #907373;">(</span>cdr list<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    0<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">rec</span><span style="color: #7388d6;">(</span>list<span style="color: #7388d6;">)</span>
<span style="color: #7388d6;">(</span>print <span style="color: #909183;">(</span>car list<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">if</span> list 
<span style="color: #909183;">(</span>rec <span style="color: #709870;">(</span> cdr list<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
<span style="color: #7388d6;">)</span>
<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defvar</span> <span style="color: #a0522d;">a</span> 4<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>format T <span style="color: #8b2252;">"Hola mundo ~ d"</span> a<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>rec '<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>1 2 3 4 4<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #b22222;">;</span><span style="color: #b22222;">(mylength '(1 2 3 4))</span>

</pre>
</div>
</div>

<div id="outline-container-org0a3ed98" class="outline-4">
<h4 id="org0a3ed98">Ejercicios car cdr</h4>
<div class="outline-text-4" id="text-org0a3ed98">
</div>
<ul class="org-ul">
<li><a id="org73af162"></a>Problema 1: Acceder al cuarto elemento de una lista<br />
<div class="outline-text-5" id="text-org73af162">
<p>
Dada la lista `(a b c d e f g)`, escribe una expresión para devolver el cuarto elemento utilizando solo `car` y `cdr`.
</p>
</div>
</li>

<li><a id="orgc7beab8"></a>Problema 2: Obtener los tres últimos elementos de una lista<br />
<div class="outline-text-5" id="text-orgc7beab8">
<p>
Dada la lista `(1 2 3 4 5 6)`, utiliza combinaciones de `car` y `cdr` para devolver los tres últimos elementos.
</p>
</div>
</li>

<li><a id="org75c308f"></a>Problema 3: Construir una lista a partir de los tres primeros elementos<br />
<div class="outline-text-5" id="text-org75c308f">
<p>
Dada la lista `(a b c d e)`, construye una nueva lista que contenga solo los tres primeros elementos.
</p>
</div>
</li>

<li><a id="orgaae4948"></a>Problema 4: Eliminar el primer y último elemento de una lista<br />
<div class="outline-text-5" id="text-orgaae4948">
<p>
Dada la lista `(x y z w)`, escribe una expresión que elimine el primer y último elemento.
</p>
</div>
</li>

<li><a id="org11e7df9"></a>Problema 5: Verificar si una lista tiene al menos tres elementos<br />
<div class="outline-text-5" id="text-org11e7df9">
<p>
Escribe una función que reciba una lista y verifique si tiene al menos tres elementos usando `car` y `cdr`.
</p>
</div>
</li>

<li><a id="orgdb68d38"></a>Problema 6: Sumar los primeros tres números de una lista<br />
<div class="outline-text-5" id="text-orgdb68d38">
<p>
Dada la lista `(10 20 30 40)`, utiliza `car` y `cdr` para obtener la suma de los tres primeros números.
</p>
</div>
</li>
<li><a id="orgeb63420"></a>Problema 7: Acceder al penúltimo elemento de una lista<br />
<div class="outline-text-5" id="text-orgeb63420">
<p>
Dada la lista `(p q r s t)`, escribe una expresión que devuelva el penúltimo elemento.
</p>
</div>
</li>
<li><a id="org45e495c"></a>Problema 8: Crear una lista anidada<br />
<div class="outline-text-5" id="text-org45e495c">
<p>
Dada la lista `(1 2 3)`, usa `cons`, `car`, y `cdr` para crear la lista anidada `((1) (2) (3))`.
</p>
</div>
</li>

<li><a id="org6d2acd9"></a>Problema 9: Fusionar dos listas<br />
<div class="outline-text-5" id="text-org6d2acd9">
<p>
Dadas las listas `(a b c)` y `(x y z)`, escribe una expresión que las combine en una sola lista `(a b c x y z)` utilizando `cons`, `car`, y `cdr`.
</p>
</div>
</li>
<li><a id="org9ec17b2"></a>Problema 10: Invertir los dos primeros pares de elementos de una lista<br />
<div class="outline-text-5" id="text-org9ec17b2">
<p>
Dada la lista `(1 2 3 4 5 6)`, invierte los primeros dos pares de elementos de la lista, de modo que obtengas `(2 1 4 3 5 6)`.
</p>
</div>
</li>
</ul>
</div>
</div>




<div id="outline-container-orgf8becc4" class="outline-3">
<h3 id="orgf8becc4">Entradas y salidas</h3>
<div class="outline-text-3" id="text-orgf8becc4">
<p>
Lisp proporciona un amplio conjunto de facilidades para realizar
entrada/salida. Todas las operaciones de entrada/salida se realizan en
flujos de varios tipos. Aunque es posible leer y escribir datos
binarios, la mayoría de los métodos de entrada/salida de Common Lisp
leen o escriben caracteres. Para leer y escribir caracteres
individuales o líneas de datos, existen primitivas directas. Sin
embargo, la operación de entrada/salida más útil es leer y escribir
representaciones escritas de objetos Lisp arbitrarios.
</p>

<p>
<b><b>Objetos Lisp:</b></b>
</p>

<p>
Los objetos Lisp suelen ser estructuras de datos complejas en lugar de
cadenas de texto. Difieren de las cadenas de texto en términos de
atributos debido a cómo se representan internamente. Sin embargo, Lisp
ofrece una representación de la mayoría de los objetos en forma de
texto escrito, conocida como la representación impresa, que se utiliza
en las facilidades de entrada/salida. Esto hace posible acceder y
discutir objetos Lisp.
</p>

<p>
Los caracteres de la representación impresa de un objeto Lisp se
transmiten a un flujo mediante funciones como "print". El (Lisp)
impresor es un conjunto de funciones que realiza esto. El (Lisp)
lector es un conjunto de rutinas que realiza la función de lectura,
que acepta caracteres de un flujo, los interpreta como una
representación impresa de un objeto Lisp, crea ese objeto y lo
devuelve.
</p>
</div>

<div id="outline-container-orgb86754c" class="outline-4">
<h4 id="orgb86754c">Funciones de Entrada:</h4>
<div class="outline-text-4" id="text-orgb86754c">
<p>
Los caracteres de la representación impresa de un objeto Lisp se
transmiten a un flujo mediante funciones como "print". El (Lisp)
impresor es un conjunto de funciones que realiza esta tarea. El (Lisp)
lector es un conjunto de rutinas que ejecutan la función de lectura,
la cual acepta caracteres de un flujo, los interpreta como la
representación impresa de un objeto Lisp, crea ese objeto y lo
devuelve.
</p>

<p>
<b><b>Funciones de Entrada</b></b>: Las funciones de entrada se dividen en dos
categorías: aquellas que trabajan con flujos de caracteres y aquellas
que trabajan con flujos binarios.
</p>

<p>
<b><b>Entrada desde Flujos de Caracteres</b></b>: Existen muchos argumentos
opcionales en las funciones de entrada de caracteres llamados
"input-stream", "eof-error-p" y "eof-value". El argumento
"input-stream" es el flujo desde el cual recoger la entrada; si no se
especifica o es "nil", se toma por defecto el valor de la variable
especial 'standard-input'. El parámetro "eof-error-p" controla lo que
sucede si la entrada proviene de un archivo y se alcanza el final del
archivo. Si "eof-error-p" es verdadero, que es el valor
predeterminado, se señalará un error al final del archivo. Si es
falso, entonces no se encuentra ningún error, y en su lugar, la
función devuelve "eof-value".
</p>

<p>
Las funciones read, read-line y read-char son funciones de entrada en
Lisp que se utilizan para leer datos desde un flujo. Aquí se describen
sus parámetros:
</p>

<ul class="org-ul">
<li><b><b>read &amp;optional input-stream eof-error-p eof-value recursive-p</b></b>:
Esta función lee datos desde el flujo de entrada especificado en
input-stream. Si no se especifica input-stream, se utiliza el valor
predeterminado que es el flujo de entrada estándar. eof-error-p
controla si se produce un error cuando se alcanza el final del
archivo (true por defecto), y eof-value especifica el valor que se
devuelve en lugar de un error cuando se llega al final del
archivo. recursive-p es un parámetro opcional que controla si la
función debe leer de manera recursiva objetos anidados.</li>

<li><b><b>read-line &amp;optional input-stream eof-error-p eof-value
recursive-p</b></b>: Esta función lee una línea de texto desde el flujo
de entrada especificado en input-stream. Devuelve la línea como una
cadena de caracteres (sin el carácter de nueva línea). El segundo
valor que se devuelve es un indicador booleano que es true si el
final del archivo terminó la línea (no está vacía) o false si la
línea se terminó correctamente.</li>

<li><b><b>read-char &amp;optional input-stream eof-error-p eof-value
recursive-p</b></b>: Esta función lee un carácter desde el flujo de
entrada especificado en input-stream. Al igual que las otras
funciones, eof-error-p controla si se produce un error cuando se
alcanza el final del archivo (true por defecto), y eof-value
especifica el valor que se devuelve en lugar de un error cuando se
llega al final del archivo. recursive-p es un parámetro opcional
que controla si la función debe leer de manera recursiva objetos
anidados.</li>
</ul>

<p>
Estas funciones son útiles para leer datos de diferentes maneras desde
flujos de entrada en Lisp.
</p>


<p>
Aquí se describen las funciones unread-char y
read-preserving-whitespace en Lisp:
</p>

<ul class="org-ul">
<li><b><b>unread-char</b></b>: Esta función mueve un carácter al principio del
flujo de entrada. Es importante destacar que el carácter que se
pasa como argumento debe coincidir con el último carácter leído del
flujo de entrada. Después de usar unread-char, cuando se lea el
siguiente carácter del flujo de entrada, será el carácter
especificado seguido de los contenidos previos del flujo de
entrada, ya que el flujo de entrada "retrocede" sobre este
carácter. unread-char devuelve nil como resultado.</li>

<li><b><b>read-preserving-whitespace</b></b>: Esta función se utiliza cuando es
necesario saber con precisión qué carácter finalizó un token
extendido. Permite leer tokens mientras conserva información sobre
los caracteres de espacio en blanco. A diferencia de read, que
normalmente ignora los espacios en blanco,
read-preserving-whitespace conserva los caracteres de espacio en
blanco y proporciona información adicional sobre cómo se formó el
token.</li>
</ul>

<p>
Estas funciones son útiles en situaciones específicas donde se
necesita un mayor control sobre la lectura y manipulación de
caracteres en el flujo de entrada en Lisp.
</p>

<p>
Aquí se describen varias funciones relacionadas con la manipulación de
entrada de caracteres en Lisp:
</p>

<ul class="org-ul">
<li><b><b>peek-char &amp;optional peek-type input-stream eof-error-p eof-value
recursive-p</b></b>: La función peek-char se utiliza para examinar el
siguiente carácter en el flujo de entrada sin eliminarlo del
flujo. El parámetro opcional peek-type determina el comportamiento
de peek-char. Si peek-type es nil (valor predeterminado), la
función devuelve el próximo carácter que se leerá en el flujo de
entrada sin eliminarlo. Esto es útil para ver qué carácter vendrá a
continuación sin avanzar en la secuencia de entrada.</li>

<li><b><b>listen &amp;optional input-stream</b></b>: La función listen se utiliza
para verificar si un carácter está inmediatamente disponible en el
flujo de entrada. Si hay un carácter disponible para ser leído, la
función devuelve true; de lo contrario, devuelve false. Esto es
especialmente útil cuando se trabaja con flujos de entrada
interactivos como el teclado.</li>

<li><b><b>read-char-no-hang &amp;optional input-stream eof-error-p eof-value
recursive-p</b></b>: Similar a read-char, esta función lee un carácter
del flujo de entrada. Sin embargo, si no hay un carácter disponible
de inmediato, en lugar de esperar, devuelve nil de inmediato. Esto
permite una lectura no bloqueante.</li>

<li><b><b>clear-input &amp;optional input-stream</b></b>: La función clear-input se
utiliza para borrar la entrada bufferizada del flujo de entrada
relacionada con la entrada. Es útil, por ejemplo, para eliminar
entradas previas no leídas, especialmente en situaciones de errores
asincrónicos. Si el flujo de entrada no es aplicable para esta
operación, clear-input no tendrá ningún efecto.</li>

<li><b><b>read-from-string string &amp;optional eof-error-p eof-value &amp;key
:start :end :preserve-whitespace:</b></b> Esta función crea un objeto
Lisp a partir de los caracteres de una cadena, uno a la vez, y
devuelve el objeto resultante. Además, devuelve la longitud de la
cadena (o longitud + 1) o el índice del primer carácter en la
cadena que no se leyó.</li>

<li><b><b>parse-integer string &amp;key :start :end :radix :junk-allowed:</b></b> La
función parse-integer se utiliza para analizar una cadena en busca
de un número entero. Puede especificar el rango de caracteres a
considerar mediante los parámetros :start y :end, y puede definir
la base numérica con :radix. Si se encuentra un carácter no válido
y :junk-allowed está configurado en nil, se generará un error.</li>
</ul>

<p>
Estas funciones son útiles en la manipulación de flujos de entrada de
caracteres y en la conversión de cadenas en objetos Lisp o números
enteros.
</p>
</div>
</div>
</div>



<div id="outline-container-orgf0278cb" class="outline-3">
<h3 id="orgf0278cb">Condicionales en Lisp</h3>
<div class="outline-text-3" id="text-orgf0278cb">
<p>
En este documento se describen las condicionales más comunes utilizadas en Lisp, con más ejemplos prácticos para <code>when</code> y <code>unless</code>.
</p>


<ul class="org-ul">
<li><code>if</code> permite evaluar una condición y ejecutar una de dos ramas.</li>
<li><code>when</code> evalúa una condición y ejecuta el bloque de código si es verdadera.</li>
<li><code>unless</code> evalúa una condición y ejecuta el bloque de código si es falsa.</li>
<li><code>cond</code> permite evaluar múltiples condiciones de manera secuencial.</li>
<li><code>case</code> compara una expresión con varios valores posibles y ejecuta el bloque correspondiente.</li>
</ul>
</div>

<div id="outline-container-orgeba4b20" class="outline-4">
<h4 id="orgeba4b20">Condicionales Básicas</h4>
<div class="outline-text-4" id="text-orgeba4b20">
</div>
<ul class="org-ul">
<li><a id="orgcb8468d"></a>if<br />
<div class="outline-text-5" id="text-orgcb8468d">
<p>
La expresión <code>if</code> es una de las condicionales más simples en Lisp. Evalúa una condición y ejecuta una de las dos ramas, dependiendo del resultado de esa condición.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">if</span> condici&#243;n
    entonces
    else<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>&gt; 5 3<span style="color: #7388d6;">)</span>
    <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"5 es mayor que 3"</span><span style="color: #7388d6;">)</span>
    <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Esto no se imprimir&#225;"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</li>

<li><a id="org7f24f1c"></a>when<br />
<div class="outline-text-5" id="text-org7f24f1c">
<p>
La expresión <code>when</code> se utiliza cuando solo hay una acción que se desea ejecutar si la condición es verdadera. Si la condición es falsa, no se ejecuta nada.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">when</span> condici&#243;n
  entonces<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ejemplo básico:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">when</span> <span style="color: #7388d6;">(</span>&gt; 5 3<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"5 es mayor que 3"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto imprimirá <code>5 es mayor que 3</code> porque la condición es verdadera. Si no lo fuera, no haría nada.
</p>
</div>

<ul class="org-ul">
<li><a id="org61f3036"></a>Ejemplo 2: Ejecutando varias expresiones con <code>when</code><br />
<div class="outline-text-6" id="text-org61f3036">
<p>
Si quieres ejecutar múltiples expresiones cuando la condición sea verdadera, puedes hacerlo incluyendo más de una expresión dentro de <code>when</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">when</span> <span style="color: #7388d6;">(</span>= 10 10<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Diez es igual a diez"</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Este es otro mensaje dentro del when"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto imprimirá:
</p>

<pre class="example" id="org41e81e1">
Diez es igual a diez
Este es otro mensaje dentro del when
</pre>
</div>
</li>

<li><a id="org34be058"></a>Ejemplo 3: Usando funciones dentro de <code>when</code><br />
<div class="outline-text-6" id="text-org34be058">
<p>
Puedes utilizar cualquier función dentro de <code>when</code>. Aquí hay un ejemplo en el que se verifica si una lista no está vacía antes de aplicar una función.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-lista '<span style="color: #7388d6;">(</span>1 2 3 4<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">when</span> mi-lista
  <span style="color: #7388d6;">(</span>print <span style="color: #909183;">(</span>car mi-lista<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>  <span style="color: #b22222;">; Imprime el primer elemento de la lista</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #909183;">(</span>length mi-lista<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">; Imprime la longitud de la lista</span>
</pre>
</div>

<p>
La salida será:
</p>

<pre class="example" id="orgd26bf12">
1
4
</pre>
</div>
</li>

<li><a id="orgb666556"></a>Ejemplo 4: <code>when</code> con listas vacías<br />
<div class="outline-text-6" id="text-orgb666556">
<p>
Lisp trata las listas vacías como <code>nil</code>. En este caso, <code>when</code> no ejecutará el bloque de código si la lista está vacía.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-lista '<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">when</span> mi-lista
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Esto no se imprimir&#225; porque la lista est&#225; vac&#237;a"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Como la lista está vacía, no se imprimirá nada.
</p>
</div>
</li>
</ul>
</li>

<li><a id="org5de9d82"></a>unless<br />
<div class="outline-text-5" id="text-org5de9d82">
<p>
La expresión <code>unless</code> es lo contrario de <code>when</code>. Ejecuta el bloque de código solo si la condición es falsa.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">unless</span> condici&#243;n
  entonces<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ejemplo básico:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">unless</span> <span style="color: #7388d6;">(</span>&lt; 5 3<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"5 no es menor que 3"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto imprimirá <code>5 no es menor que 3</code> porque la condición es falsa.
</p>
</div>

<ul class="org-ul">
<li><a id="org2a9d75c"></a>Ejemplo 2: Ejecutando varias expresiones con <code>unless</code><br />
<div class="outline-text-6" id="text-org2a9d75c">
<p>
Al igual que con <code>when</code>, también puedes ejecutar múltiples expresiones dentro de <code>unless</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">unless</span> nil
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Esto se imprimir&#225;"</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"Este es otro mensaje dentro del unless"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto imprimirá:
</p>

<pre class="example" id="org44842fc">
Esto se imprimirá
Este es otro mensaje dentro del unless
</pre>
</div>
</li>

<li><a id="org861f10a"></a>Ejemplo 3: <code>unless</code> con funciones<br />
<div class="outline-text-6" id="text-org861f10a">
<p>
Puedes utilizar funciones dentro de <code>unless</code> de la misma forma que en <code>when</code>.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-lista '<span style="color: #7388d6;">()</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">unless</span> mi-lista
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"La lista est&#225; vac&#237;a"</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"No hay elementos en la lista"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto imprimirá:
</p>

<pre class="example" id="org4114866">
La lista está vacía
No hay elementos en la lista
</pre>
</div>
</li>

<li><a id="org7381cd4"></a>Ejemplo 4: <code>unless</code> con comparaciones<br />
<div class="outline-text-6" id="text-org7381cd4">
<p>
En este ejemplo, se compara si dos valores no son iguales, y si es cierto, ejecuta el bloque de código.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq x 10<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">unless</span> <span style="color: #7388d6;">(</span>= x 5<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"x no es igual a 5"</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>print <span style="color: #8b2252;">"El valor de x es"</span> x<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
La salida será:
</p>

<pre class="example" id="org13ce49d">
x no es igual a 5
El valor de x es 10
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-org1fc0df5" class="outline-4">
<h4 id="org1fc0df5">Condicionales Anidadas</h4>
<div class="outline-text-4" id="text-org1fc0df5">
<p>
Las condicionales <code>when</code> y <code>unless</code> también pueden anidarse dentro de otras condicionales.
</p>

<p>
Ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">if</span> <span style="color: #7388d6;">(</span>= 5 5<span style="color: #7388d6;">)</span>
    <span style="color: #7388d6;">(</span><span style="color: #a020f0;">when</span> <span style="color: #909183;">(</span>&gt; 5 3<span style="color: #909183;">)</span>
      <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"Ambas condiciones son verdaderas"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
    <span style="color: #7388d6;">(</span><span style="color: #a020f0;">unless</span> <span style="color: #909183;">(</span>&gt; 5 3<span style="color: #909183;">)</span>
      <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"Esto no se imprimir&#225;"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Aquí se imprime <code>Ambas condiciones son verdaderas</code>, ya que ambas condiciones dentro de la condicional son ciertas.
</p>
</div>
</div>

<div id="outline-container-org54a7dcc" class="outline-4">
<h4 id="org54a7dcc">Condicionales Complejas</h4>
<div class="outline-text-4" id="text-org54a7dcc">
</div>
<ul class="org-ul">
<li><a id="org72f5188"></a>cond<br />
<div class="outline-text-5" id="text-org72f5188">
<p>
La expresión <code>cond</code> se utiliza para evaluar múltiples condiciones. Se puede pensar en <code>cond</code> como una cadena de <code>if</code>, cada uno con su propia condición y acción.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">cond</span>
  <span style="color: #7388d6;">(</span>condici&#243;n1 acci&#243;n1<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>condici&#243;n2 acci&#243;n2<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>t acci&#243;n-por-defecto<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">cond</span>
  <span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>= 5 6<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"5 es igual a 6"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>&gt; 5 6<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"5 es mayor que 6"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>t <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"Ninguna de las anteriores"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Se imprimirá <code>Ninguna de las anteriores</code> porque ambas condiciones anteriores son falsas.
</p>
</div>
</li>

<li><a id="orgc697498"></a>case<br />
<div class="outline-text-5" id="text-orgc697498">
<p>
La expresión <code>case</code> es similar a un "switch" en otros lenguajes de programación. Se utiliza para evaluar una expresión y compararla con una lista de posibles valores.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">case</span> expresi&#243;n
  <span style="color: #7388d6;">(</span>valor1 acci&#243;n1<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>valor2 acci&#243;n2<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>t acci&#243;n-por-defecto<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">case</span> 5
  <span style="color: #7388d6;">(</span>1 <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"Uno"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>5 <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"Cinco"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>t <span style="color: #909183;">(</span>print <span style="color: #8b2252;">"Ninguno de los anteriores"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Aquí se imprimirá <code>Cinco</code> porque la expresión evaluada es igual a 5.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org1a30ba9" class="outline-4">
<h4 id="org1a30ba9">Referencias</h4>
<div class="outline-text-4" id="text-org1a30ba9">
<p>
Para más información sobre las condicionales en Lisp, se recomienda revisar la documentación oficial o los siguientes recursos:
</p>
<ul class="org-ul">
<li><a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Conditionals.html">GNU Emacs Lisp Reference Manual - Condicionales</a></li>
</ul>
</div>
</div>
</div>




<div id="outline-container-orgeb77d72" class="outline-3">
<h3 id="orgeb77d72">Listas de Asociación en Lisp</h3>
<div class="outline-text-3" id="text-orgeb77d72">
<p>
Las <b><b>listas de asociación</b></b> en <b><b>Lisp</b></b> permiten asociar claves con
valores. Cada clave está emparejada con un valor en una lista. A
continuación, te muestro cómo crear, modificar, y acceder a estas
listas.
</p>

<p>
<b><b>Concepto de listas de asociación</b></b>
</p>

<p>
Una <b><b>lista de asociación</b></b> es una lista donde cada elemento es un par clave-valor, representado por una lista de dos elementos. Por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-alist '<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>nombre . <span style="color: #8b2252;">"Juan"</span><span style="color: #909183;">)</span>
                 <span style="color: #909183;">(</span>edad . 30<span style="color: #909183;">)</span>
                 <span style="color: #909183;">(</span>ciudad . <span style="color: #8b2252;">"Madrid"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esta lista tiene:
</p>
<ul class="org-ul">
<li>`nombre` asociado a `"Juan"`</li>
<li>`edad` asociado a `30`</li>
<li>`ciudad` asociado a `"Madrid"`</li>
</ul>

<p>
<b><b>Operaciones básicas</b></b>
</p>
</div>

<div id="outline-container-orga2dc8c4" class="outline-4">
<h4 id="orga2dc8c4">1. Acceder a un valor <b>*</b></h4>
<div class="outline-text-4" id="text-orga2dc8c4">
<p>
Para obtener el valor asociado a una clave, se utiliza la función `assoc`:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>assoc 'nombre mi-alist<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto devolverá el par `(nombre . "Juan")`. Para obtener solo el valor, usa `cdr`:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>cdr <span style="color: #7388d6;">(</span>assoc 'nombre mi-alist<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado: `"Juan"`
</p>
</div>
</div>

<div id="outline-container-org63db5b3" class="outline-4">
<h4 id="org63db5b3">2. Agregar un nuevo par clave-valor <b>*</b></h4>
<div class="outline-text-4" id="text-org63db5b3">
<p>
Puedes agregar un nuevo par clave-valor al principio de la lista con `cons`:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-alist <span style="color: #7388d6;">(</span>cons '<span style="color: #909183;">(</span>pais . <span style="color: #8b2252;">"Espa&#241;a"</span><span style="color: #909183;">)</span> mi-alist<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ahora `mi-alist` incluirá `(pais . "España")`.
</p>
</div>
</div>

<div id="outline-container-orgcbd6857" class="outline-4">
<h4 id="orgcbd6857">3. Modificar un valor existente <b>*</b></h4>
<div class="outline-text-4" id="text-orgcbd6857">
<p>
Para modificar el valor de una clave existente, primero eliminas el par antiguo y luego agregas el nuevo:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-alist <span style="color: #7388d6;">(</span>cons '<span style="color: #909183;">(</span>edad . 31<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>assq-delete-all 'edad mi-alist<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto actualiza el valor de `edad` a `31`.
</p>
</div>
</div>

<div id="outline-container-orgdacec1e" class="outline-4">
<h4 id="orgdacec1e">4. Eliminar un par clave-valor <b>*</b></h4>
<div class="outline-text-4" id="text-orgdacec1e">
<p>
Para eliminar un par clave-valor por su clave, usa `assq-delete-all`:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq mi-alist <span style="color: #7388d6;">(</span>assq-delete-all 'ciudad mi-alist<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto elimina el par `(ciudad . "Madrid")` de la lista.
</p>

<p>
<b><b>Ejemplo completo</b></b>
</p>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Definir una lista de asociaci&#243;n</span>
<span style="color: #707183;">(</span>setq mi-alist '<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>nombre . <span style="color: #8b2252;">"Juan"</span><span style="color: #909183;">)</span>
                 <span style="color: #909183;">(</span>edad . 30<span style="color: #909183;">)</span>y
                 <span style="color: #909183;">(</span>ciudad . <span style="color: #8b2252;">"Madrid"</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Acceder a un valor</span>
<span style="color: #707183;">(</span>format t <span style="color: #8b2252;">"Nombre: ~a~%"</span> <span style="color: #7388d6;">(</span>cdr <span style="color: #909183;">(</span>assoc 'nombre mi-alist<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Agregar un nuevo par</span>
<span style="color: #707183;">(</span>setq mi-alist <span style="color: #7388d6;">(</span>cons '<span style="color: #909183;">(</span>pais . <span style="color: #8b2252;">"Espa&#241;a"</span><span style="color: #909183;">)</span> mi-alist<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Modificar un valor existente</span>
<span style="color: #707183;">(</span>setq mi-alist <span style="color: #7388d6;">(</span>cons '<span style="color: #909183;">(</span>edad . 31<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>assq-delete-all 'edad mi-alist<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Eliminar un par</span>
<span style="color: #707183;">(</span>setq mi-alist <span style="color: #7388d6;">(</span>assq-delete-all 'ciudad mi-alist<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Imprimir la lista completa</span>
<span style="color: #707183;">(</span>format t <span style="color: #8b2252;">"Lista de asociaci&#243;n: ~a~%"</span> mi-alist<span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgc74ea1e" class="outline-3">
<h3 id="orgc74ea1e">Casi-Quoting en Lisp</h3>
<div class="outline-text-3" id="text-orgc74ea1e">
</div>
<div id="outline-container-org05fc342" class="outline-4">
<h4 id="org05fc342">Introducción</h4>
<div class="outline-text-4" id="text-org05fc342">
<p>
El <b><b>casi-quoting</b></b> (<b>backquote</b>) es una herramienta poderosa en Lisp
para crear listas que contienen tanto valores literales como valores
evaluados. A diferencia de `quote`, que previene la evaluación
completa de una lista, el <b><b>backquote</b></b> te permite evaluar partes
específicas de la lista usando comas (`,`).
</p>
</div>
</div>

<div id="outline-container-org668e05b" class="outline-4">
<h4 id="org668e05b">1. Operador `quote`</h4>
<div class="outline-text-4" id="text-org668e05b">
<p>
El operador `quote` (`'`) en Lisp previene la evaluación de una expresión. Si citas una lista, ésta se trata como literal:
</p>

<div class="org-src-container">
<pre class="src src-lisp">'<span style="color: #707183;">(</span>a b c<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org29f2384">
(a b c)
</pre>
</div>
</div>

<div id="outline-container-org3db40b8" class="outline-4">
<h4 id="org3db40b8">2. Operador `backquote`</h4>
<div class="outline-text-4" id="text-org3db40b8">
<p>
El <b><b>backquote</b></b> (o <b>casi-quoting</b>) es similar a `quote`, pero permite que algunas partes de la lista sean evaluadas. El operador es el símbolo de acento grave (<b><b>`</b></b>):
</p>

<div class="org-src-container">
<pre class="src src-lisp">`<span style="color: #707183;">(</span>a b c<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Este código produce el mismo resultado que `quote`, es decir:
</p>

<pre class="example" id="orgdd8ab10">
(a b c)
</pre>

<p>
La ventaja del `backquote` es que puedes usar comas (`,`) para evaluar partes específicas de la lista.
</p>
</div>
</div>

<div id="outline-container-org4ba2e13" class="outline-4">
<h4 id="org4ba2e13">3. Evaluación con la coma (`,`)</h4>
<div class="outline-text-4" id="text-org4ba2e13">
<p>
Dentro de una lista creada con <b>backquote</b>, cualquier parte de la lista precedida por una coma (`,`) se evalúa, mientras que el resto permanece literal.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq x 10<span style="color: #707183;">)</span>
`<span style="color: #707183;">(</span>a b ,x<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org4b4969e">
(a b 10)
</pre>

<p>
Aquí, la variable `x` se evaluó y su valor, `10`, se insertó en la lista.
</p>
</div>
</div>

<div id="outline-container-orgac59cca" class="outline-4">
<h4 id="orgac59cca">4. Expansión de listas con `,@`</h4>
<div class="outline-text-4" id="text-orgac59cca">
<p>
Cuando necesitas insertar los elementos de una lista en lugar de la lista completa como un elemento único, puedes usar `,@` (coma seguido de arroba). Esto "expande" la lista y la inserta en la lista resultante.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq lst '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
`<span style="color: #707183;">(</span>a b ,@lst<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org806983d">
(a b 1 2 3)
</pre>

<p>
En este caso, los elementos de `lst` se expanden e insertan en la lista final.
</p>
</div>
</div>

<div id="outline-container-org1f40cc9" class="outline-4">
<h4 id="org1f40cc9">5. Combinación de `backquote`, `,` y `,@`</h4>
<div class="outline-text-4" id="text-org1f40cc9">
<p>
Puedes combinar `backquote`, `,` y `,@` para crear listas más complejas que mezclan datos literales y resultados evaluados.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq x 10<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>setq lst '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
`<span style="color: #707183;">(</span>valores: ,x lista: ,@lst<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orge3a0ebb">
(valores: 10 lista: 1 2 3)
</pre>

<p>
En este ejemplo:
</p>
<ul class="org-ul">
<li>`,x` inserta el valor de `x`.</li>
<li>`,@lst` expande los elementos de `lst`.</li>
</ul>
</div>
</div>

<div id="outline-container-org0c934b4" class="outline-4">
<h4 id="org0c934b4">6. Ejemplos adicionales</h4>
<div class="outline-text-4" id="text-org0c934b4">
</div>
<ul class="org-ul">
<li><a id="orgd922073"></a>Ejemplo 1: Combinando literales y evaluaciones<br />
<div class="outline-text-5" id="text-orgd922073">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq a 5<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>setq b 10<span style="color: #707183;">)</span>
`<span style="color: #707183;">(</span>suma ,<span style="color: #7388d6;">(</span>+ a b<span style="color: #7388d6;">)</span> lista <span style="color: #7388d6;">(</span>1 2 ,<span style="color: #909183;">(</span>+ 3 4<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org598e716">
(suma 15 lista (1 2 7))
</pre>
</div>
</li>

<li><a id="org568c1b7"></a>Ejemplo 2: Insertando múltiples listas<br />
<div class="outline-text-5" id="text-org568c1b7">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq l1 '<span style="color: #7388d6;">(</span>a b c<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>setq l2 '<span style="color: #7388d6;">(</span>x y z<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
`<span style="color: #707183;">(</span>primera lista: ,@l1 segunda lista: ,@l2<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgb7ba1ab">
(primera lista: a b c segunda lista: x y z)
</pre>
</div>
</li>
</ul>
</div>


<div id="outline-container-orgaf03a9b" class="outline-4">
<h4 id="orgaf03a9b">8. Ejemplo completo</h4>
<div class="outline-text-4" id="text-orgaf03a9b">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>setq x 20<span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>setq nums '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>setq palabra <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>

`<span style="color: #707183;">(</span>el valor de x es ,x y la lista es ,@nums, con una palabra ,palabra<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgee27f83">
(el valor de x es 20 y la lista es 1 2 3 con una palabra hola)
</pre>


<ul class="org-ul">
<li><b><b>`quote`</b></b> (`'`): Cita una lista, evitando su evaluación.</li>
<li><b><b>`backquote`</b></b> (<b><b>`</b></b>): Crea una lista que puede tener partes evaluadas.</li>
<li><b><b>`,`</b></b>: Evalúa una expresión dentro de una lista con <b>backquote</b>.</li>
<li><b><b>`,@`</b></b>: Expande el contenido de una lista dentro de otra lista.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgca99e9c" class="outline-3">
<h3 id="orgca99e9c">mapcar en Lisp</h3>
<div class="outline-text-3" id="text-orgca99e9c">
</div>
<div id="outline-container-org96d9fde" class="outline-4">
<h4 id="org96d9fde">Introducción</h4>
<div class="outline-text-4" id="text-org96d9fde">
<p>
La función `mapcar` en Lisp se utiliza para aplicar una función a cada
elemento de una o más listas, devolviendo una nueva lista con los
resultados de esas aplicaciones. Es una de las funciones más útiles
para procesar listas en Lisp, ya que permite transformar listas de
manera sencilla.
</p>
</div>
</div>

<div id="outline-container-org3a9c4d8" class="outline-4">
<h4 id="org3a9c4d8">Sintaxis básica de mapcar</h4>
<div class="outline-text-4" id="text-org3a9c4d8">
<p>
La sintaxis básica de mapcar es la siguiente:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar funci&#243;n lista<span style="color: #707183;">)</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>función</b></b>: Es una función que se aplicará a cada elemento de la lista.</li>
<li><b><b>lista</b></b>: Es la lista a la que se aplicará la función.</li>
</ul>
</div>
</div>

<div id="outline-container-orge713e5e" class="outline-4">
<h4 id="orge713e5e">Ejemplos básicos</h4>
<div class="outline-text-4" id="text-orge713e5e">
</div>
<ul class="org-ul">
<li><a id="orgcd275e4"></a>Ejemplo 1: Aplicando una función a una lista<br />
<div class="outline-text-5" id="text-orgcd275e4">
<p>
Vamos a aplicar la función 1+ (que suma 1) a cada elemento de una lista de números:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar #'1+ '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgffcb855">
(2 3 4 5 6)
</pre>

<p>
Aquí, `mapcar` ha aplicado la función 1+ a cada número en la lista, incrementando cada uno en 1.
</p>
</div>
</li>

<li><a id="orgedfff8c"></a>Ejemplo 2: Usando una función lambda<br />
<div class="outline-text-5" id="text-orgedfff8c">
<p>
También puedes usar funciones anónimas (lambda) con `mapcar`. En este ejemplo, multiplicamos cada número de una lista por 2:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x 2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org7e0aef8">
(2 4 6 8 10)
</pre>
</div>
</li>

<li><a id="orgc6a40ab"></a>Ejemplo 3: Aplicando una función a varias listas<br />
<div class="outline-text-5" id="text-orgc6a40ab">
<p>
`mapcar` también puede operar sobre varias listas. La función debe tomar tantos argumentos como listas haya:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar #'+ '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>4 5 6<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgee6404c">
(5 7 9)
</pre>

<p>
Aquí, `mapcar` ha sumado los elementos correspondientes de las dos listas.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org8fb031a" class="outline-4">
<h4 id="org8fb031a">Ejemplos</h4>
<div class="outline-text-4" id="text-org8fb031a">
</div>
<ul class="org-ul">
<li><a id="orge382065"></a>Ejemplo 4: Filtrando listas con `mapcar`<br />
<div class="outline-text-5" id="text-orge382065">
<p>
Aunque `mapcar` no está diseñado específicamente para filtrar listas,
podemos usarlo junto con una función condicional para obtener un
efecto de filtrado. Por ejemplo, si queremos obtener solo los números
pares de una lista, podríamos hacer lo siguiente:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>evenp x<span style="color: #709870;">)</span> x nil<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5 6<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org5b2f1e3">
(nil 2 nil 4 nil 6)
</pre>

<p>
Esto devolverá `nil` para los números impares y los números pares sin cambios.
</p>
</div>
</li>

<li><a id="org40745f9"></a>Ejemplo 5: Transformando listas de listas<br />
<div class="outline-text-5" id="text-org40745f9">
<p>
`mapcar` también es útil para trabajar con listas de listas. Por ejemplo, si queremos sumar los elementos de sublistas:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>lst<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>apply #'+ lst<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>1 2 3<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>4 5 6<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>7 8 9<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgbc617de">
(6 15 24)
</pre>

<p>
Aquí, hemos sumado los elementos de cada sublista.
</p>
</div>
</li>

<li><a id="orgc221af1"></a>Ejemplo 6: Trabajando con cadenas de texto<br />
<div class="outline-text-5" id="text-orgc221af1">
<p>
`mapcar` no está limitado solo a números. También puede aplicarse a listas de caracteres o cadenas de texto:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar #'char-upcase '<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"b"</span> <span style="color: #8b2252;">"c"</span> <span style="color: #8b2252;">"d"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org7724573">
("A" "B" "C" "D")
</pre>

<p>
Este ejemplo convierte cada letra en mayúscula.
</p>

<ul class="org-ul">
<li>`mapcar` es una función poderosa en Lisp para aplicar una función a cada elemento de una o más listas.</li>
<li>Puedes usar funciones predefinidas, como `1+` o `+`, o funciones anónimas (lambda).</li>
<li>Se puede aplicar a listas de números, cadenas de texto, o incluso listas de listas.</li>
</ul>


<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Definimos una lista de n&#250;meros</span>
<span style="color: #707183;">(</span>setq numeros '<span style="color: #7388d6;">(</span>1 2 3 4 5 6 7 8 9 10<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Usamos mapcar para obtener los n&#250;meros pares multiplicados por 2</span>
<span style="color: #707183;">(</span>mapcar <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">if</span> <span style="color: #709870;">(</span>evenp x<span style="color: #709870;">)</span> <span style="color: #709870;">(</span>* x 2<span style="color: #709870;">)</span> nil<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> numeros<span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Aplicamos mapcar para sumar los elementos de dos listas</span>
<span style="color: #707183;">(</span>mapcar #'+ '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>4 5 6<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Aplicamos mapcar para convertir letras min&#250;sculas a may&#250;sculas</span>
<span style="color: #707183;">(</span>mapcar #'char-upcase '<span style="color: #7388d6;">(</span><span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"b"</span> <span style="color: #8b2252;">"c"</span> <span style="color: #8b2252;">"d"</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-org5c00a5b" class="outline-3">
<h3 id="org5c00a5b">Comparaciones en Lisp</h3>
<div class="outline-text-3" id="text-org5c00a5b">
<p>
En <b><b>Lisp</b></b>, las funciones de comparación se utilizan para comparar
diferentes tipos de objetos: números, cadenas, símbolos, listas,
etc. Dependiendo del tipo de dato que estés comparando, es importante
usar la función adecuada.
</p>
</div>

<div id="outline-container-org1bfc410" class="outline-4">
<h4 id="org1bfc410">1. <b>eq</b></h4>
<div class="outline-text-4" id="text-org1bfc410">
<p>
La función <b>eq</b> es la forma más básica de comparación en Lisp. Compara si dos objetos son <b><b>idénticos</b></b> (el mismo objeto en memoria). Generalmente se usa para comparar símbolos.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>eq 'a 'a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, porque los s&#237;mbolos son el mismo objeto</span>
<span style="color: #707183;">(</span>eq 'a 'b<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, los s&#237;mbolos son diferentes</span>
<span style="color: #707183;">(</span>eq 10 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">En algunas implementaciones puede devolver NIL</span>
<span style="color: #707183;">(</span>eq <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, las cadenas no son el mismo objeto en memoria</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparación de símbolos.</li>
<li><b><b>Advertencia</b></b>: No usar para comparar números o cadenas de texto, ya que puede devolver resultados inesperados.</li>
</ul>
</div>
</div>

<div id="outline-container-orgdfeaa26" class="outline-4">
<h4 id="orgdfeaa26">2. <b>eql</b></h4>
<div class="outline-text-4" id="text-orgdfeaa26">
<p>
<b>eql</b> es más general que <b>eq</b>. Se comporta igual que <b>eq</b> para símbolos, pero también maneja correctamente la comparación de números y caracteres.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>eql 'a 'a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T</span>
<span style="color: #707183;">(</span>eql 10 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, porque compara n&#250;meros por su valor</span>
<span style="color: #707183;">(</span>eql 10.0 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, porque compara tipos tambi&#233;n (entero vs flotante)</span>
<span style="color: #707183;">(</span>eql #\A #\A<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, compara caracteres</span>
<span style="color: #707183;">(</span>eql <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, porque compara referencias de cadenas</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparación de símbolos, números, y caracteres.</li>
</ul>
</div>
</div>

<div id="outline-container-org3711b58" class="outline-4">
<h4 id="org3711b58">3. <b>equal</b></h4>
<div class="outline-text-4" id="text-org3711b58">
<p>
<b>equal</b> compara el contenido de dos objetos de forma más flexible. Es capaz de comparar listas, números, símbolos, y cadenas de texto, pero no distingue entre mayúsculas y minúsculas en cadenas.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>equal '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, compara listas por contenido</span>
<span style="color: #707183;">(</span>equal <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, compara cadenas por su contenido</span>
<span style="color: #707183;">(</span>equal <span style="color: #8b2252;">"Hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, las may&#250;sculas y min&#250;sculas importan</span>
<span style="color: #707183;">(</span>equal 10 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, porque compara n&#250;meros por valor</span>
<span style="color: #707183;">(</span>equal 10.0 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, porque no iguala flotantes y enteros</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparación de listas, cadenas, símbolos, y números.</li>
</ul>
</div>
</div>

<div id="outline-container-org8a2d3ca" class="outline-4">
<h4 id="org8a2d3ca">4. <b>equalp</b></h4>
<div class="outline-text-4" id="text-org8a2d3ca">
<p>
<b>equalp</b> es similar a <b>equal</b>, pero es más "tolerante". Ignora las diferencias entre mayúsculas y minúsculas en cadenas, y compara enteros y flotantes de manera flexible.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>equalp <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"HOLA"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, ignora may&#250;sculas y min&#250;sculas</span>
<span style="color: #707183;">(</span>equalp 10 10.0<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, iguala enteros y flotantes</span>
<span style="color: #707183;">(</span>equalp '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, compara listas por contenido</span>
<span style="color: #707183;">(</span>equalp #\A #\a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, ignora las diferencias entre may&#250;sculas y min&#250;sculas en caracteres</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparación de listas, números, caracteres y cadenas ignorando las diferencias menores.</li>
</ul>
</div>
</div>

<div id="outline-container-org8645e17" class="outline-4">
<h4 id="org8645e17">5. <b>=</b></h4>
<div class="outline-text-4" id="text-org8645e17">
<p>
<b>=</b> se usa exclusivamente para comparar <b><b>números</b></b>. Compara números enteros y flotantes, asegurándose de que sus valores sean los mismos.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>= 10 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, ambos n&#250;meros son iguales</span>
<span style="color: #707183;">(</span>= 10 10.0<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, porque compara n&#250;meros enteros y flotantes</span>
<span style="color: #707183;">(</span>= 5 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, los n&#250;meros son diferentes</span>
<span style="color: #707183;">(</span>= <span style="color: #8b2252;">"10"</span> 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Error, no se puede usar para comparar cadenas</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparación de números.</li>
</ul>
</div>
</div>

<div id="outline-container-org3428279" class="outline-4">
<h4 id="org3428279">6. <b>/=</b></h4>
<div class="outline-text-4" id="text-org3428279">
<p>
<b>/=</b> compara si dos números <b><b>no</b></b> son iguales.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>/= 10 5<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, los n&#250;meros son diferentes</span>
<span style="color: #707183;">(</span>/= 10 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, los n&#250;meros son iguales</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Verificar que dos números no sean iguales.</li>
</ul>
</div>
</div>

<div id="outline-container-org07911ff" class="outline-4">
<h4 id="org07911ff">7. <b>string=</b></h4>
<div class="outline-text-4" id="text-org07911ff">
<p>
<b>string=</b> se utiliza para comparar cadenas de texto de manera exacta, respetando las diferencias entre mayúsculas y minúsculas.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>string= <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, las cadenas son iguales</span>
<span style="color: #707183;">(</span>string= <span style="color: #8b2252;">"Hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, may&#250;sculas y min&#250;sculas no coinciden</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparar cadenas de texto exactamente, respetando mayúsculas y minúsculas.</li>
</ul>
</div>
</div>

<div id="outline-container-org8a27c40" class="outline-4">
<h4 id="org8a27c40">8. <b>string-equal</b></h4>
<div class="outline-text-4" id="text-org8a27c40">
<p>
<b>string-equal</b> es similar a <b>string=</b>, pero ignora las diferencias entre mayúsculas y minúsculas.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>string-equal <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"HOLA"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, ignora las diferencias de may&#250;sculas</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparar cadenas de texto sin importar las mayúsculas y minúsculas.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc2596cb" class="outline-4">
<h4 id="orgc2596cb">9. <b>char=</b> y <b>char-equal</b></h4>
<div class="outline-text-4" id="text-orgc2596cb">
<p>
Estas funciones comparan caracteres individuales. <b>char=</b> compara caracteres de manera exacta, mientras que <b>char-equal</b> ignora las diferencias entre mayúsculas y minúsculas.
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>char= #\A #\A<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, los caracteres son iguales</span>
<span style="color: #707183;">(</span>char= #\A #\a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve NIL, may&#250;sculas y min&#250;sculas no coinciden</span>
<span style="color: #707183;">(</span>char-equal #\A #\a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">Devuelve T, ignora las diferencias de may&#250;sculas</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>Mejor uso</b></b>: Comparar caracteres individuales.</li>
</ul>
</div>
</div>

<div id="outline-container-org560e122" class="outline-4">
<h4 id="org560e122">Resumen</h4>
<div class="outline-text-4" id="text-org560e122">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Función</td>
<td class="org-left">Propósito</td>
<td class="org-left">Caso de uso</td>
</tr>

<tr>
<td class="org-left">--------------</td>
<td class="org-left">---------------------------------------</td>
<td class="org-left">---------------------------------------------------</td>
</tr>

<tr>
<td class="org-left"><b>eq</b></td>
<td class="org-left">Comparar si dos símbolos son idénticos</td>
<td class="org-left">Comparación de símbolos</td>
</tr>

<tr>
<td class="org-left"><b>eql</b></td>
<td class="org-left">Comparar símbolos, números y caracteres</td>
<td class="org-left">Comparación de símbolos, números y caracteres</td>
</tr>

<tr>
<td class="org-left"><b>equal</b></td>
<td class="org-left">Comparar listas, cadenas y objetos</td>
<td class="org-left">Comparación de listas, cadenas y objetos estructurados</td>
</tr>

<tr>
<td class="org-left"><b>equalp</b></td>
<td class="org-left">Comparar listas y cadenas de forma flexible</td>
<td class="org-left">Comparación flexible de listas, cadenas, números y caracteres</td>
</tr>

<tr>
<td class="org-left"><b>=</b></td>
<td class="org-left">Comparar si dos números son iguales</td>
<td class="org-left">Comparación estricta de números</td>
</tr>

<tr>
<td class="org-left"><b>/=</b></td>
<td class="org-left">Comparar si dos números no son iguales</td>
<td class="org-left">Verificar que dos números sean diferentes</td>
</tr>

<tr>
<td class="org-left"><b>string=</b></td>
<td class="org-left">Comparar cadenas exactamente</td>
<td class="org-left">Comparar cadenas de texto, respetando mayúsculas</td>
</tr>

<tr>
<td class="org-left"><b>string-equal</b></td>
<td class="org-left">Comparar cadenas, ignorando mayúsculas</td>
<td class="org-left">Comparar cadenas de texto, ignorando mayúsculas</td>
</tr>

<tr>
<td class="org-left"><b>char=</b></td>
<td class="org-left">Comparar caracteres exactamente</td>
<td class="org-left">Comparar caracteres individuales</td>
</tr>

<tr>
<td class="org-left"><b>char-equal</b></td>
<td class="org-left">Comparar caracteres, ignorando mayúsculas</td>
<td class="org-left">Comparación flexible de caracteres</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgb135474" class="outline-4">
<h4 id="orgb135474">Ejemplo completo</h4>
<div class="outline-text-4" id="text-orgb135474">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Comparaci&#243;n de s&#237;mbolos</span>
<span style="color: #707183;">(</span>eq 'a 'a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>
<span style="color: #707183;">(</span>eq 'a 'b<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">NIL</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Comparaci&#243;n de n&#250;meros y caracteres</span>
<span style="color: #707183;">(</span>eql 10 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>
<span style="color: #707183;">(</span>eql 10.0 10<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">NIL</span>
<span style="color: #707183;">(</span>eql #\A #\A<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Comparaci&#243;n de listas y cadenas</span>
<span style="color: #707183;">(</span>equal '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>
<span style="color: #707183;">(</span>equal <span style="color: #8b2252;">"Hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">NIL</span>
<span style="color: #707183;">(</span>equalp <span style="color: #8b2252;">"Hola"</span> <span style="color: #8b2252;">"hola"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Comparaci&#243;n num&#233;rica</span>
<span style="color: #707183;">(</span>= 10 10.0<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>
<span style="color: #707183;">(</span>/= 10 5<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Comparaci&#243;n de cadenas</span>
<span style="color: #707183;">(</span>string= <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"HOLA"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">NIL</span>
<span style="color: #707183;">(</span>string-equal <span style="color: #8b2252;">"hola"</span> <span style="color: #8b2252;">"HOLA"</span><span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Comparaci&#243;n de caracteres</span>
<span style="color: #707183;">(</span>char= #\A #\A<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>
<span style="color: #707183;">(</span>char-equal #\A #\a<span style="color: #707183;">)</span>  <span style="color: #b22222;">;; </span><span style="color: #b22222;">T</span>
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org04771f7" class="outline-3">
<h3 id="org04771f7">Funciones lambda en Lisp</h3>
<div class="outline-text-3" id="text-org04771f7">
</div>
<div id="outline-container-org42811e6" class="outline-4">
<h4 id="org42811e6">Introducción</h4>
<div class="outline-text-4" id="text-org42811e6">
<p>
En <b><b>Lisp</b></b>, las <b><b>funciones lambda</b></b> son funciones anónimas que
puedes definir sin necesidad de darles un nombre. Son útiles cuando
necesitas una función pequeña y no quieres definirla por
separado. Estas funciones pueden ser pasadas como argumentos a otras
funciones, utilizadas en listas de procesamiento, o empleadas en
lugares donde una función completa sería innecesaria.
</p>
</div>
</div>

<div id="outline-container-orga41bf8d" class="outline-4">
<h4 id="orga41bf8d">Definición básica de una función lambda</h4>
<div class="outline-text-4" id="text-orga41bf8d">
<p>
La sintaxis básica de una función lambda es la siguiente:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #7388d6;">(</span>parametros<span style="color: #7388d6;">)</span> cuerpo<span style="color: #707183;">)</span>
</pre>
</div>

<ul class="org-ul">
<li><b><b>parametros</b></b>: Una lista de parámetros que la función recibirá.</li>
<li><b><b>cuerpo</b></b>: Las expresiones que se evaluarán cuando se invoque la función.</li>
</ul>

<p>
Ejemplo básico:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #7388d6;">(</span>x<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>* x 2<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esta es una función lambda que toma un número `x` y devuelve `x` multiplicado por 2.
</p>
</div>
</div>

<div id="outline-container-orgc1c2fef" class="outline-4">
<h4 id="orgc1c2fef">Ejemplos de uso de lambdas</h4>
<div class="outline-text-4" id="text-orgc1c2fef">
</div>
<ul class="org-ul">
<li><a id="org3011376"></a>Ejemplo 1: Usando lambdas con `mapcar`<br />
<div class="outline-text-5" id="text-org3011376">
<p>
Puedes usar una función lambda directamente en llamadas a funciones como `mapcar`, donde necesitas aplicar una operación a cada elemento de una lista. 
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>mapcar <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x 2<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orge77e8a6">
(2 4 6 8 10)
</pre>

<p>
En este caso, la función lambda toma cada elemento de la lista `(1 2 3 4 5)` y lo multiplica por 2.
</p>
</div>
</li>

<li><a id="org56717b6"></a>Ejemplo 2: Usando lambdas con `reduce`<br />
<div class="outline-text-5" id="text-org56717b6">
<p>
También puedes usar lambdas en combinación con otras funciones de orden superior como `reduce`. Por ejemplo, para sumar todos los elementos de una lista:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>reduce <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x y<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>+ x y<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orga717ef4">
15
</pre>

<p>
Aquí, la lambda toma dos elementos, los suma, y luego pasa el resultado para la siguiente suma.
</p>
</div>
</li>

<li><a id="orgd81fbe2"></a>Ejemplo 3: Lambdas dentro de una función<br />
<div class="outline-text-5" id="text-orgd81fbe2">
<p>
Las funciones lambda también pueden ser utilizadas dentro de otras funciones para definir comportamientos específicos:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">aplicar-operacion</span> <span style="color: #7388d6;">(</span>operacion lista<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>mapcar operacion lista<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>aplicar-operacion <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x x<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="org7482027">
(1 4 9 16)
</pre>

<p>
Aquí, la función `aplicar-operacion` toma una lambda que eleva cada número al cuadrado y la aplica a la lista.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org439abfa" class="outline-4">
<h4 id="org439abfa">Ámbito de las lambdas</h4>
<div class="outline-text-4" id="text-org439abfa">
<p>
Las lambdas pueden acceder a variables que están en su entorno de definición. Esto es conocido como <b><b>alcance léxico</b></b>.
</p>
</div>

<ul class="org-ul">
<li><a id="org2072d76"></a>Ejemplo 4: Usando una variable externa en una lambda<br />
<div class="outline-text-5" id="text-org2072d76">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">let</span> <span style="color: #7388d6;">(</span><span style="color: #909183;">(</span>factor 3<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>mapcar <span style="color: #909183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #709870;">(</span>x<span style="color: #709870;">)</span> <span style="color: #709870;">(</span>* x factor<span style="color: #709870;">)</span><span style="color: #909183;">)</span> '<span style="color: #909183;">(</span>1 2 3 4 5<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgda9b698">
(3 6 9 12 15)
</pre>

<p>
En este caso, la variable `factor` está definida en el entorno léxico donde se declara la lambda, y la lambda puede acceder a ella.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org07a4634" class="outline-4">
<h4 id="org07a4634">Lambdas como valores de retorno</h4>
<div class="outline-text-4" id="text-org07a4634">
<p>
Las funciones lambda también pueden ser retornadas desde otras funciones, lo que permite construir funciones dinámicamente.
</p>
</div>

<ul class="org-ul">
<li><a id="org631e84b"></a>Ejemplo 5: Retornar una lambda desde una función<br />
<div class="outline-text-5" id="text-org631e84b">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">multiplicador</span> <span style="color: #7388d6;">(</span>n<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x n<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>setq duplicar <span style="color: #7388d6;">(</span>multiplicador 2<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>funcall duplicar 10<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Resultado:
</p>

<pre class="example" id="orgc5d441a">
20
</pre>

<p>
Aquí, la función `multiplicador` devuelve una lambda que multiplica por `n`. En el ejemplo, `duplicar` es una función que multiplica por 2, y al llamar `funcall` con `duplicar` y `10`, obtenemos `20`.
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org53e429d" class="outline-4">
<h4 id="org53e429d">Usos comunes de lambdas</h4>
<div class="outline-text-4" id="text-org53e429d">
<p>
Las funciones lambda son extremadamente útiles en situaciones donde necesitas funciones temporales o pequeñas que no ameritan una definición completa. Algunas aplicaciones comunes son:
</p>

<ul class="org-ul">
<li>En procesamiento de listas (`mapcar`, `reduce`, etc.).</li>
<li>Para definir funciones rápidas que solo se usan en una parte del código.</li>
<li>Para generar funciones dinámicamente, como vimos en el ejemplo de `multiplicador`.</li>
</ul>
</div>
</div>

<div id="outline-container-orgf8b8407" class="outline-4">
<h4 id="orgf8b8407">Ejemplos</h4>
<div class="outline-text-4" id="text-orgf8b8407">
<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #b22222;">;; </span><span style="color: #b22222;">Usando lambda con mapcar para elevar n&#250;meros al cubo</span>
<span style="color: #707183;">(</span>mapcar <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x x x<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Usando lambda con reduce para multiplicar todos los elementos</span>
<span style="color: #707183;">(</span>reduce <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x y<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x y<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Usando lambda dentro de una funci&#243;n personalizada</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">aplicar-operacion</span> <span style="color: #7388d6;">(</span>operacion lista<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>mapcar operacion lista<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>aplicar-operacion <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>+ x 10<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span> '<span style="color: #7388d6;">(</span>1 2 3 4 5<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Retornando una lambda desde una funci&#243;n</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">multiplicador</span> <span style="color: #7388d6;">(</span>n<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> <span style="color: #909183;">(</span>* x n<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span>setq triplicar <span style="color: #7388d6;">(</span>multiplicador 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>funcall triplicar 10<span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org6579720" class="outline-2">
<h2 id="org6579720">Prolog</h2>
<div class="outline-text-2" id="text-org6579720">
<p>
Una regla sirve para representar conocimiento que en lenguaje natural
 se expresa mediante una sentencia condicional. Por ejemplo, si en
 lenguaje natural decimos «si X es padre de Y entonces Y es hijo de X»
 , en Prolog escribiremos: hijo(Y,X) :- padre(X,Y).  El símbolo «:-»
 significa «si» , y la traducción directa al lenguaje natural de la
 regla es: «Y es hijo de X si X es padre de Y» .  Las reglas resultan
 muy útiles para definir nuevos predicados a partir de otros
 previamente definidos. Por ejemplo, podríamos tener un conjunto de
 hechos de la forma «padre(juan, luis)» , «padre(luis,jaime)» , etc.,
 que definen el predicado (o relación) «padre» por extensión. La regla
 anterior define intensionalmente la relación «hijo» .  Muchas
 expresiones que en lenguaje natural no tienen explícitamente la forma
 condicional pueden representarse de este modo manteniendo su
 significado: «todos los hombres son mortales» es equivalente a decir
 «si X es un hombre entonces X es mortal» ; en Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">mortal</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span> :- hombre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En general, una regla tiene una «cabeza» y un «cuerpo» . La cabeza es
un predicado, y el cuerpo una conjunción de literales; para indicar la
conjunción se utiliza una coma separando a los predicados del cuerpo:
una definición de «abuelo» es:
</p>
<div class="org-src-container">
<pre class="src src-prolog"> abuelo<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>,padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
(X es abuelo de Y si X es padre de algún individuo Z que, a su vez, es
padre de Y).  Pero esta definición estaría incompleta: sólo cubre los
abuelos paternos. Podemos completarla añadiendo otra regla:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">abuelo</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>,madre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Escribir dos o más reglas para definir un predicado es la manera
normal de expresar en Prolog lo que en lógica sería una disyunción. En
este caso, «X es abuelo de Y si&#x2026; o bien si&#x2026;» . También puede
expresarse explícitamente la disyunción mediante «;» :
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">abuelo</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>,<span style="color: #707183;">(</span>padre<span style="color: #7388d6;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #7388d6;">)</span><span style="color: #a020f0;">;</span>madre<span style="color: #7388d6;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
pero normalmente se prefiere la versión en dos reglas por su mayor
claridad.  También se puede definir introduciendo un concepto
intermedio, «progenitor» (padre o madre):
</p>

<div class="org-src-container">
<pre class="src src-prolog"> progenitor<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.  
 progenitor<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- madre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.  
 abuelo<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>,progenitor<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
El cuerpo de la regla puede contener literales negativos. Por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">hermano</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- progenitor<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>,  
                 progenitor<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>, not <span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>=<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.
</pre>
</div>






<p>
importante: no debe confundirse «reglas de inferencia» con «reglas»
(de Prolog) (y tampoco con «reglas gramaticales»). Las «reglas» de
Prolog son sentencias condicionales que se satisfacen para unas
interpretaciones pero no para otras. Una regla de inferencia es un
esquema general de razonamiento que, formalizado, se representa por
una sentencia válida (Apartado . Por ejemplo, la regla de Prolog
«men(x) :- pol(x)» corresponde a la sentencia condicional ( A
x)(pol(x) ==&gt;men(x)) se satisface para unas interpretaciones pero no
para otras. Una particularización de la regla de inferencia modus
ponens es: P1: ( A x)(pol(x) ==&gt;men(x)) P2: pol(x) C: men(x) a la que
corresponde la sentencia ( A x)((pol(x) ==&gt;men(x)) /\ pol(x)
==&gt;men(x)), que es una sentencia válida (se satisface con cualquier
interpretación de los predicados y cualquier asignación de x).
</p>
</div>


<div id="outline-container-org525da57" class="outline-3">
<h3 id="org525da57">Lógica de primer orden</h3>
<div class="outline-text-3" id="text-org525da57">
</div>
<div id="outline-container-org0cde51d" class="outline-4">
<h4 id="org0cde51d">1. La Tierra es un planeta.</h4>
<div class="outline-text-4" id="text-org0cde51d">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "La Tierra es un planeta."</li>
<li><b><b>Interpretación</b></b>: Afirmamos que la "Tierra" tiene la propiedad de
ser un planeta.</li>
<li><b><b>Formalización</b></b>: <code>Planeta(Tierra)</code></li>
<li><b><b>Razonamiento</b></b>: Usamos el predicado <code>Planeta</code> aplicado a la
constante <code>Tierra</code>, ya que solo queremos expresar una propiedad
directa sin relaciones adicionales.</li>
</ul>
</div>
</div>

<div id="outline-container-orgde0f5c5" class="outline-4">
<h4 id="orgde0f5c5">2. La Luna no es un planeta.</h4>
<div class="outline-text-4" id="text-orgde0f5c5">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "La Luna no es un planeta."</li>
<li><b><b>Interpretación</b></b>: Queremos expresar la ausencia de la propiedad
de ser un planeta en la Luna.</li>
<li><b><b>Formalización</b></b>: <code>¬Planeta(Luna)</code></li>
<li><b><b>Razonamiento</b></b>: Utilizamos el operador de negación <code>¬</code> sobre el
predicado <code>Planeta(Luna)</code> para indicar que "Luna" no cumple con
esta propiedad. Es una negación directa de una propiedad.</li>
</ul>
</div>
</div>

<div id="outline-container-org5e18608" class="outline-4">
<h4 id="org5e18608">3. La Luna es un satélite.</h4>
<div class="outline-text-4" id="text-org5e18608">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "La Luna es un satélite."</li>
<li><b><b>Interpretación</b></b>: Decimos que la "Luna" tiene la propiedad de ser
un satélite.</li>
<li><b><b>Formalización</b></b>: <code>Satelite(Luna)</code></li>
<li><b><b>Razonamiento</b></b>: Similar al primer ejemplo, usamos el predicado
<code>Satelite</code> aplicado a <code>Luna</code> para indicar esta propiedad simple.</li>
</ul>
</div>
</div>

<div id="outline-container-org5ff74d9" class="outline-4">
<h4 id="org5ff74d9">4. La Tierra gira alrededor del Sol.</h4>
<div class="outline-text-4" id="text-org5ff74d9">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "La Tierra gira alrededor del Sol."</li>
<li><b><b>Interpretación</b></b>: Queremos expresar una relación entre "Tierra" y "Sol".</li>
<li><b><b>Formalización</b></b>: <code>GiraAlrededor(Tierra, Sol)</code></li>
<li><b><b>Razonamiento</b></b>: Usamos un predicado de dos argumentos
<code>GiraAlrededor(x, y)</code> para representar la relación "girar alrededor
de". Aplicamos esta relación entre "Tierra" y "Sol".</li>
</ul>
</div>
</div>

<div id="outline-container-orge11b617" class="outline-4">
<h4 id="orge11b617">5. Todo planeta es un satélite.</h4>
<div class="outline-text-4" id="text-orge11b617">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Todo planeta es un satélite."</li>
<li><b><b>Interpretación</b></b>: Queremos expresar que ser un planeta implica ser un satélite.</li>
<li><b><b>Formalización</b></b>: <code>∀x (Planeta(x) → Satelite(x))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos una <b><b>implicación</b></b> (<code>→</code>) para expresar una
regla general. La implicación establece que si un objeto <code>x</code> es un
planeta, entonces <code>x</code> también debe ser un satélite. <code>∀x</code> indica que
esta regla aplica a todos los elementos en el dominio.</li>
</ul>
</div>
</div>

<div id="outline-container-org367c7c7" class="outline-4">
<h4 id="org367c7c7">6. Todo planeta gira alrededor del Sol.</h4>
<div class="outline-text-4" id="text-org367c7c7">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Todo planeta gira alrededor del Sol."</li>
<li><b><b>Interpretación</b></b>: Decimos que si algo es un planeta, entonces
gira alrededor del Sol.</li>
<li><b><b>Formalización</b></b>: <code>∀x (Planeta(x) → GiraAlrededor(x, Sol))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos <b><b>implicación</b></b> para expresar que la
propiedad de ser un planeta (<code>Planeta(x)</code>) lleva a la consecuencia
de girar alrededor del Sol (<code>GiraAlrededor(x, Sol)</code>). <code>∀x</code> indica que
esto se aplica a todos los planetas.</li>
</ul>
</div>
</div>

<div id="outline-container-org78829a0" class="outline-4">
<h4 id="org78829a0">7. Algún planeta gira alrededor de la Luna.</h4>
<div class="outline-text-4" id="text-org78829a0">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Algún planeta gira alrededor de la Luna."</li>
<li><b><b>Interpretación</b></b>: Existe al menos un planeta que tiene la
propiedad de girar alrededor de la Luna.</li>
<li><b><b>Formalización</b></b>: <code>∃x (Planeta(x) ∧ GiraAlrededor(x, Luna))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos el <b><b>cuantificador existencial</b></b> <code>∃x</code> para
indicar que al menos un objeto <code>x</code> cumple con ambas condiciones:
ser un planeta y girar alrededor de la Luna. La <b><b>conjunción</b></b> (<code>∧</code>)
asegura que ambas condiciones son verdaderas simultáneamente.</li>
</ul>
</div>
</div>

<div id="outline-container-org84d4a3e" class="outline-4">
<h4 id="org84d4a3e">8. Hay por lo menos un satélite.</h4>
<div class="outline-text-4" id="text-org84d4a3e">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Hay por lo menos un satélite."</li>
<li><b><b>Interpretación</b></b>: Queremos indicar que existe al menos un objeto
que tiene la propiedad de ser un satélite.</li>
<li><b><b>Formalización</b></b>: <code>∃x Satelite(x)</code></li>
<li><b><b>Razonamiento</b></b>: Usamos el <b><b>cuantificador existencial</b></b> <code>∃x</code> con el
predicado <code>Satelite(x)</code> para expresar que existe al menos un objeto
que es un satélite. No necesitamos conjunción ni implicación
aquí, solo afirmamos la existencia de un satélite.</li>
</ul>
</div>
</div>

<div id="outline-container-org5027305" class="outline-4">
<h4 id="org5027305">9. Todos los perros del vecindario muerden a algún cartero.</h4>
<div class="outline-text-4" id="text-org5027305">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Todos los perros del vecindario muerden a algún
cartero."</li>
<li><b><b>Interpretación</b></b>: Cada perro tiene la propiedad de morder a por
lo menos un cartero.</li>
<li><b><b>Formalización</b></b>: <code>∀x (Perro(x) → ∃y (Cartero(y) ∧ Muerde(x, y)))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos una <b><b>implicación</b></b> (<code>→</code>) para expresar una
condición general: "si <code>x</code> es un perro, entonces existe algún <code>y</code> que
es cartero y es mordido por <code>x</code>". La conjunción <code>Cartero(y) ∧
     Muerde(x, y)</code> asegura que <code>y</code> es cartero y es mordido por <code>x</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org476aa00" class="outline-4">
<h4 id="org476aa00">10. Hay un cartero al que lo muerden todos los perros.</h4>
<div class="outline-text-4" id="text-org476aa00">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Hay un cartero al que lo muerden todos los perros."</li>
<li><b><b>Interpretación</b></b>: Existe al menos un cartero al que todos los
perros muerden.</li>
<li><b><b>Formalización</b></b>: <code>∃y (Cartero(y) ∧ ∀x (Perro(x) → Muerde(x, y)))</code></li>
<li><b><b>Razonamiento</b></b>: Aquí, usamos <b><b>cuantificador existencial</b></b> <code>∃y</code> para
el cartero <code>y</code>, y luego una <b><b>implicación</b></b> para decir que si <code>x</code> es un
perro, entonces <code>x</code> debe morder a <code>y</code>. La conjunción <code>Cartero(y)</code>
asegura que <code>y</code> es un cartero.</li>
</ul>
</div>
</div>

<div id="outline-container-org2a8fbc6" class="outline-4">
<h4 id="org2a8fbc6">11. Todos los carteros son mordidos por algún perro.</h4>
<div class="outline-text-4" id="text-org2a8fbc6">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Todos los carteros son mordidos por algún perro."</li>
<li><b><b>Interpretación</b></b>: Cada cartero es mordido por al menos un perro.</li>
<li><b><b>Formalización</b></b>: <code>∀y (Cartero(y) → ∃x (Perro(x) ∧ Muerde(x, y)))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos <b><b>implicación</b></b> para indicar que si <code>y</code> es un
cartero, entonces existe algún perro <code>x</code> que muerde a <code>y</code>. La
<b><b>conjunción</b></b> <code>Perro(x) ∧ Muerde(x, y)</code> asegura que <code>x</code> es un perro y
muerde a <code>y</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org9f7fb6d" class="outline-4">
<h4 id="org9f7fb6d">12. Hay un perro que muerde a todos los carteros.</h4>
<div class="outline-text-4" id="text-org9f7fb6d">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Hay un perro que muerde a todos los carteros."</li>
<li><b><b>Interpretación</b></b>: Existe al menos un perro que muerde a todos los carteros.</li>
<li><b><b>Formalización</b></b>: <code>∃x (Perro(x) ∧ ∀y (Cartero(y) → Muerde(x, y)))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos un <b><b>cuantificador existencial</b></b> <code>∃x</code> para
expresar que existe un perro que cumple esta condición. Luego, la
<b><b>implicación</b></b> indica que si <code>y</code> es cartero, entonces <code>x</code> lo muerde.</li>
</ul>
</div>
</div>

<div id="outline-container-org4e84228" class="outline-4">
<h4 id="org4e84228">13. Todos los perros que asustan a algún cartero, lo muerden.</h4>
<div class="outline-text-4" id="text-org4e84228">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Todos los perros que asustan a algún cartero, lo muerden."</li>
<li><b><b>Formalización</b></b>: <code>∀x ∀y ((Perro(x) ∧ Cartero(y) ∧ Asusta(x, y)) → Muerde(x, y))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos <b><b>implicación</b></b> para expresar que si un
perro <code>x</code> asusta a un cartero <code>y</code>, entonces <code>x</code> lo muerde. La
<b><b>conjunción</b></b> <code>Perro(x) ∧ Cartero(y) ∧ Asusta(x, y)</code> dentro de la
implicación indica que todas estas condiciones deben cumplirse
para que el perro lo muerda.</li>
</ul>
</div>
</div>

<div id="outline-container-orgc154abb" class="outline-4">
<h4 id="orgc154abb">14. Hay un perro que muerde a todos los perros que muerden a algún cartero.</h4>
<div class="outline-text-4" id="text-orgc154abb">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Hay un perro que muerde a todos los perros que
muerden a algún cartero."</li>
<li><b><b>Formalización</b></b>: <code>∃x (Perro(x) ∧ ∀y ((Perro(y) ∧ ∃z (Cartero(z) ∧ Muerde(y, z))) → Muerde(x, y)))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos un <b><b>cuantificador existencial</b></b> para
indicar que existe un perro <code>x</code> con esta característica. La
<b><b>implicación</b></b> dentro del cuantificador universal dice que, si <code>y</code>
es un perro que muerde a algún cartero, entonces <code>x</code> muerde a <code>y</code>.</li>
</ul>
</div>
</div>

<div id="outline-container-org94770e6" class="outline-4">
<h4 id="org94770e6">15. Hay un solo perro que se muerde a sí mismo.</h4>
<div class="outline-text-4" id="text-org94770e6">
<ul class="org-ul">
<li><b><b>Enunciado</b></b>: "Hay un solo perro que se muerde a sí mismo."</li>
<li><b><b>Formalización</b></b>: <code>∃x (Perro(x) ∧ Muerde(x, x) ∧ ∀y ((Perro(y) ∧
     Muerde(y, y)) → x = y))</code></li>
<li><b><b>Razonamiento</b></b>: Usamos el <b><b>cuantificador existencial</b></b> para
expresar la existencia de un único perro que cumple esta
condición. La <b><b>conjunción</b></b> asegura que existe un solo perro <code>x</code> que
se muerde a sí mismo y que ningún otro perro lo hace.</li>
</ul>
</div>
</div>
</div>





<div id="outline-container-org437f8fb" class="outline-3">
<h3 id="org437f8fb">Hechos, Átomos y Reglas</h3>
<div class="outline-text-3" id="text-org437f8fb">
<p>
En Prolog, los programas se construyen mediante <b><b>hechos</b></b>, <b><b>átomos</b></b> y
<b><b>reglas</b></b>. Estos elementos son la base de la programación lógica en
Prolog y permiten representar el conocimiento y definir relaciones
entre distintos elementos.
</p>
</div>

<div id="outline-container-org0f3d7ef" class="outline-4">
<h4 id="org0f3d7ef">1. Hechos</h4>
<div class="outline-text-4" id="text-org0f3d7ef">
<p>
Los <b><b>hechos</b></b> representan afirmaciones o declaraciones que se
consideran verdaderas en el programa. Los hechos se utilizan para
describir propiedades o relaciones entre elementos. Un hecho es una
sentencia simple que no requiere ser probada, ya que se asume que
es verdadera en el contexto de la base de datos.
</p>

<p>
Ejemplos de hechos:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #b22222;">% </span><span style="color: #b22222;">Representa que "Juan es un hombre"</span>
   hombre<span style="color: #707183;">(</span>juan<span style="color: #707183;">)</span>.

   <span style="color: #b22222;">% </span><span style="color: #b22222;">Representa que "Mar&#237;a es mujer"</span>
   mujer<span style="color: #707183;">(</span>maria<span style="color: #707183;">)</span>.

   <span style="color: #b22222;">% </span><span style="color: #b22222;">Representa una relaci&#243;n de parentesco "Juan es padre de Mar&#237;a"</span>
   padre<span style="color: #707183;">(</span>juan, maria<span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En estos ejemplos:
</p>
<ul class="org-ul">
<li>`hombre(juan)` es un hecho que indica que Juan es un hombre.</li>
<li>`mujer(maria)` indica que María es una mujer.</li>
<li>`padre(juan, maria)` indica que Juan es el padre de María.</li>
</ul>

<p>
Los hechos se escriben en minúsculas y sin variables, ya que
simplemente representan afirmaciones que se consideran verdaderas.
</p>
</div>
</div>

<div id="outline-container-org3717106" class="outline-4">
<h4 id="org3717106">2. Átomos</h4>
<div class="outline-text-4" id="text-org3717106">
<p>
Un <b><b>átomo</b></b> es un tipo de dato básico en Prolog que representa una
constante simbólica, similar a un nombre o una etiqueta. Los átomos
son entidades indivisibles, y Prolog los usa para identificar
hechos, valores o constantes simbólicas.
</p>

<p>
Los átomos pueden ser:
</p>
<ul class="org-ul">
<li>Palabras en minúsculas sin espacios (`juan`, `maria`, `perro`).</li>
<li>Cadenas de caracteres entre comillas simples (`'Juan Pérez'`, `'esto es un átomo'`).</li>
<li>Secuencias especiales con caracteres como `@`, `#`, etc. (`@ejemplo`, `#dato`).</li>
</ul>

<p>
Ejemplos de átomos:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #b22222;">% </span><span style="color: #b22222;">Nombres simples</span>
   hombre<span style="color: #707183;">(</span>juan<span style="color: #707183;">)</span>.
   color<span style="color: #707183;">(</span>rojo<span style="color: #707183;">)</span>.

   <span style="color: #b22222;">% </span><span style="color: #b22222;">Nombres con caracteres especiales</span>
   gato<span style="color: #707183;">(</span><span style="color: #8b2252;">'Amichi'</span><span style="color: #707183;">)</span>.
   palabra<span style="color: #707183;">(</span><span style="color: #8b2252;">'#clave'</span><span style="color: #707183;">)</span>.

   <span style="color: #b22222;">% </span><span style="color: #b22222;">Nombres con comillas</span>
   nombre<span style="color: #707183;">(</span><span style="color: #8b2252;">'Juan P&#233;rez'</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
<b><b>Importante</b></b>: Los átomos se diferencian de las variables porque los
átomos están en minúscula y representan constantes, mientras que
las variables están en mayúscula y representan valores que pueden
cambiar.
</p>
</div>
</div>

<div id="outline-container-org4b7c6a1" class="outline-4">
<h4 id="org4b7c6a1">3. Reglas</h4>
<div class="outline-text-4" id="text-org4b7c6a1">
<p>
Las <b><b>reglas</b></b> permiten definir relaciones lógicas entre hechos y se
utilizan para derivar nueva información. Una regla consiste en una
cabeza y un cuerpo, y su estructura general es:
</p>

<pre class="example" id="orgd1bfdd6">
   cabeza :- cuerpo.
</pre>

<p>
La <b><b>cabeza</b></b> es el resultado o conclusión de la regla, mientras que
el <b><b>cuerpo</b></b> es una combinación de condiciones que deben cumplirse
para que la cabeza sea verdadera. Las reglas en Prolog son como
"si-entonces"; si se cumplen las condiciones en el cuerpo, entonces
la cabeza también es cierta.
</p>

<p>
Ejemplos de reglas:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #b22222;">% </span><span style="color: #b22222;">Definici&#243;n de "padre" y "abuelo" mediante reglas</span>
   padre<span style="color: #707183;">(</span>juan, maria<span style="color: #707183;">)</span>.                  <span style="color: #b22222;">% </span><span style="color: #b22222;">Hecho: Juan es padre de Mar&#237;a</span>
   padre<span style="color: #707183;">(</span>jose, juan<span style="color: #707183;">)</span>.                   <span style="color: #b22222;">% </span><span style="color: #b22222;">Hecho: Jos&#233; es padre de Juan</span>

   abuelo<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>, padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En este ejemplo:
</p>
<ul class="org-ul">
<li>`padre(juan, maria)` y `padre(jose, juan)` son hechos que definen
relaciones directas de parentesco.</li>
<li>La regla `abuelo(X, Y) :- padre(X, Z), padre(Z, Y).` define que
`X` es abuelo de `Y` si `X` es padre de `Z` y `Z` es padre de
`Y`.</li>
</ul>

<p>
<b><b>Explicación de la regla</b></b>:
</p>
<ul class="org-ul">
<li>`abuelo(X, Y)` es la cabeza de la regla.</li>
<li>`padre(X, Z), padre(Z, Y)` es el cuerpo de la regla, que indica
que para que `X` sea abuelo de `Y`, debe existir un `Z` tal que
`X` sea padre de `Z` y `Z` sea padre de `Y`.</li>
</ul>
</div>
</div>

<div id="outline-container-org8af1caf" class="outline-4">
<h4 id="org8af1caf">4. Ejemplos adicionales para comprender hechos, átomos y reglas</h4>
<div class="outline-text-4" id="text-org8af1caf">
<ul class="org-ul">
<li><b><b>Hecho</b></b>: `es<sub>amigo</sub>(juan, maria).` – Juan es amigo de María.</li>
<li><b><b>Átomo</b></b>: `rojo` en `color(rojo).` – Un color específico.</li>
<li><b><b>Regla</b></b>: `es<sub>feliz</sub>(X) :- es<sub>rico</sub>(X), tiene<sub>salud</sub>(X).` – Una persona `X` es feliz si es rica y tiene salud.</li>
</ul>
</div>
</div>

<div id="outline-container-org6c930fb" class="outline-4">
<h4 id="org6c930fb">5. Ejecución de consultas en Prolog</h4>
<div class="outline-text-4" id="text-org6c930fb">
<p>
Las consultas en Prolog se utilizan para obtener información a
partir de hechos y reglas. Cuando haces una consulta, Prolog
intenta unificar la consulta con los hechos y reglas disponibles
para determinar si la consulta es verdadera o para encontrar
valores de las variables que hagan que sea verdadera.
</p>

<p>
Ejemplo de consulta:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- abuelo<span style="color: #707183;">(</span>jose, maria<span style="color: #707183;">)</span>.
   true.

   ?- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, maria<span style="color: #707183;">)</span>.
   <span style="color: #a0522d;">X</span> = juan.
</pre>
</div>

<p>
En la primera consulta, Prolog verifica si `jose` es abuelo de
`maria` usando la regla definida. En la segunda consulta, Prolog
busca el valor de `X` que hace que `padre(X, maria)` sea verdadero,
unificando `X` con `juan`. 
</p>


<ul class="org-ul">
<li><b><b>Hechos</b></b>: Declaraciones de relaciones o propiedades que se consideran verdaderas.</li>
<li><b><b>Átomos</b></b>: Constantes simbólicas que representan nombres o valores específicos en Prolog.</li>
<li><b><b>Reglas</b></b>: Estructuras que permiten inferir nueva información mediante condiciones lógicas.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-org1c7ba1f" class="outline-3">
<h3 id="org1c7ba1f">Unificación en Prolog</h3>
<div class="outline-text-3" id="text-org1c7ba1f">
<p>
La unificación es uno de los conceptos fundamentales en Prolog y es el
proceso mediante el cual el lenguaje determina si dos términos pueden
hacerse iguales. Este proceso es esencial para el funcionamiento de
las consultas y reglas en Prolog, ya que permite enlazar variables con
valores específicos y evaluar la compatibilidad entre términos.
</p>
</div>

<div id="outline-container-orgf02124b" class="outline-4">
<h4 id="orgf02124b">1. ¿Qué es la unificación?</h4>
<div class="outline-text-4" id="text-orgf02124b">
<p>
La unificación en Prolog ocurre cuando intentamos "igualar" dos
términos. Si los términos pueden unirse o emparejarse siguiendo las
reglas de Prolog, decimos que se "unifican" y el intérprete establece
correspondencias entre variables y valores que cumplen con la
igualdad.
</p>

<p>
Por ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- <span style="color: #a0522d;">X</span> = 5.
<span style="color: #a0522d;">X</span> = 5.
</pre>
</div>

<p>
Aquí, Prolog unifica la variable <b>X</b> con el valor <b>5</b>, es decir, establece
que <b>X</b> ahora representa el valor <b>5</b>.
</p>
</div>
</div>

<div id="outline-container-org4208c46" class="outline-4">
<h4 id="org4208c46">2. Reglas de unificación</h4>
<div class="outline-text-4" id="text-org4208c46">
<p>
La unificación en Prolog sigue ciertas reglas:
</p>

<ul class="org-ul">
<li><p>
<b><b>Dos constantes se unifican si y solo si son idénticas.</b></b> Ejemplo:
</p>
<div class="org-src-container">
<pre class="src src-prolog">     ?- 3 = 3.
     true.
     
     ?- 3 = 4.
     false.
</pre>
</div></li>

<li><p>
<b><b>Una variable se puede unificar con cualquier valor.</b></b> Si una
variable no tiene un valor asignado, Prolog puede unirla con
cualquier término.
</p>
<div class="org-src-container">
<pre class="src src-prolog">     ?- <span style="color: #a0522d;">X</span> = 5.
     <span style="color: #a0522d;">X</span> = 5.
</pre>
</div></li>

<li><p>
<b><b>Dos variables pueden unificarse entre sí.</b></b> Cuando dos variables
se unifican, ambas quedan enlazadas y cualquier valor que se
asigne a una también afectará a la otra.
</p>
<div class="org-src-container">
<pre class="src src-prolog">     ?- <span style="color: #a0522d;">X</span> = <span style="color: #a0522d;">Y</span>.
     <span style="color: #a0522d;">X</span> = <span style="color: #a0522d;">Y</span>.
</pre>
</div></li>

<li><b><b>Unificamos listas y estructuras término a término.</b></b> Las listas y
estructuras (también llamadas compuestos) se unifican si tienen
la misma cantidad de elementos y cada elemento correspondiente
también se unifica.</li>
</ul>
</div>
</div>

<div id="outline-container-org3ca444c" class="outline-4">
<h4 id="org3ca444c">3. Ejemplos de unificación</h4>
<div class="outline-text-4" id="text-org3ca444c">
</div>
<ul class="org-ul">
<li><a id="org143998d"></a>a) Unificación de constantes<br />
<div class="outline-text-5" id="text-org143998d">
<div class="org-src-container">
<pre class="src src-prolog">   ?- hola = hola.
   true.

   ?- hola = adios.
   false.
</pre>
</div>

<p>
Aquí, solo la primera consulta unifica porque ambos términos son idénticos.
</p>
</div>
</li>

<li><a id="orge2cf085"></a>b) Unificación de variables<br />
<div class="outline-text-5" id="text-orge2cf085">
<p>
Las variables en Prolog pueden unificarse con cualquier valor que
no contradiga otros enlaces:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- <span style="color: #a0522d;">X</span> = 42.
   <span style="color: #a0522d;">X</span> = 42.

   ?- <span style="color: #a0522d;">X</span> = <span style="color: #a0522d;">Y</span>.
   <span style="color: #a0522d;">X</span> = <span style="color: #a0522d;">Y</span>.
</pre>
</div>
</div>
</li>

<li><a id="org7c8693f"></a>c) Unificación de listas<br />
<div class="outline-text-5" id="text-org7c8693f">
<p>
Para listas, Prolog trata de unificar cada elemento individualmente:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- <span style="color: #707183;">[</span>1, 2, 3<span style="color: #707183;">]</span> = <span style="color: #707183;">[</span>1, <span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">]</span>.
   <span style="color: #a0522d;">X</span> = 2.
</pre>
</div>

<p>
En este caso, `X` se unifica con `2` para que ambas listas sean iguales.
</p>
</div>
</li>

<li><a id="orgee64ab9"></a>d) Unificación de estructuras o términos compuestos<br />
<div class="outline-text-5" id="text-orgee64ab9">
<p>
Prolog permite trabajar con estructuras que siguen una sintaxis de
"functor(argumento1, argumento2, &#x2026;)".
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- punto<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> = punto<span style="color: #707183;">(</span>3, 4<span style="color: #707183;">)</span>.
   <span style="color: #a0522d;">X</span> = 3,
   <span style="color: #a0522d;">Y</span> = 4.
</pre>
</div>

<p>
Aquí, `X` y `Y` se unifican con `3` y `4`, respectivamente,
haciendo que ambas estructuras sean idénticas.
</p>

<p>
a*** 4. Casos en los que la unificación falla
</p>

<p>
La unificación falla cuando:
</p>

<ul class="org-ul">
<li>Los términos son distintos y no tienen variables que puedan
unificarse con otros valores.</li>
<li>Los términos tienen estructuras diferentes (diferente número de
argumentos o diferentes functors).</li>
</ul>

<p>
Ejemplo de fallos en la unificación:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- perro<span style="color: #707183;">(</span>orejas, cola<span style="color: #707183;">)</span> = gato<span style="color: #707183;">(</span>orejas, cola<span style="color: #707183;">)</span>.
   false.

   ?- <span style="color: #707183;">[</span>1, 2, 3<span style="color: #707183;">]</span> = <span style="color: #707183;">[</span>1, 2<span style="color: #707183;">]</span>.
   false.
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org4c3bbe1" class="outline-4">
<h4 id="org4c3bbe1">5. Importancia de la unificación en Prolog</h4>
<div class="outline-text-4" id="text-org4c3bbe1">
<p>
La unificación es la base de la búsqueda de soluciones en Prolog,
ya que permite enlazar valores con variables dentro de las
consultas y reglas. Gracias a la unificación, Prolog puede "probar"
términos y hacer coincidencias, lo que es esencial en la resolución
de problemas lógicos.
</p>
</div>
</div>

<div id="outline-container-org6a07707" class="outline-4">
<h4 id="org6a07707">6. Ejemplo práctico</h4>
<div class="outline-text-4" id="text-org6a07707">
<p>
Supongamos que queremos consultar si un punto `(3, 4)` coincide con
un término `punto(X, Y)`:
</p>


<p>
padre(juan, maria).
</p>

<p>
?padre(juan, X).
</p>

<p>
padre(juan, X) = padre(juan, maria)
</p>

<p>
juan = juan
X = maria
</p>

<p>
maria 
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- punto<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> = punto<span style="color: #707183;">(</span>3, 4<span style="color: #707183;">)</span>.
   <span style="color: #a0522d;">X</span> = 3,
   <span style="color: #a0522d;">Y</span> = 4.
</pre>
</div>

<p>
Aquí, la unificación permite asignar `X = 3` y `Y = 4`, logrando
que ambos términos sean idénticos.
</p>
</div>
</div>

<div id="outline-container-org102491e" class="outline-4">
<h4 id="org102491e">Resumen</h4>
<div class="outline-text-4" id="text-org102491e">
<p>
La unificación en Prolog es el proceso de hacer iguales dos términos,
enlazando variables con valores específicos cuando es posible. Este
proceso es fundamental para las consultas y reglas, permitiendo que
Prolog resuelva problemas y encuentre soluciones.
</p>
</div>
</div>
</div>


<div id="outline-container-org534266f" class="outline-3">
<h3 id="org534266f">Corte</h3>
<div class="outline-text-3" id="text-org534266f">
<p>
El corte es un predicado predefinido que no recibe argumentos. Se
representa mediante un signo de admiración (!). Sin duda, es el
predicado más difícil de entender. El corte tiene la espantosa
propiedad de eliminar los puntos de elección del predicado que lo
contiene.
</p>

<p>
Es decir, cuando se ejecuta el corte, el resultado del objetivo (no
sólo la cláusula en cuestión) queda comprometido al éxito o fallo de
los objetivos que aparecen a continuación. Es como si a Prolog "se le
olvidase" que dicho objetivo puede tener varias soluciones.
</p>

<p>
Otra forma de ver el efecto del corte es pensar que solamente tiene la
propiedad de detener el backtracking cuando éste se produce. Es decir,
en la ejecución normal el corte no hace nada. Pero cuando el programa
entra en backtracking y los objetivos se recorren marcha atrás, al
llegar al corte el backtracking se detiene repentinamente forzando el
fallo del objetivo.
</p>



<p>
Para entender de manera simple el uso del corte vamos a comparar dos
predicados que solamente se diferencian en un corte:
</p>


<div class="org-src-container">
<pre class="src src-prolog"> <span style="color: #b22222;">% </span><span style="color: #b22222;">Sin corte. </span>
 p<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">X</span> &gt; 15, <span style="color: #a0522d;">Y</span> &gt; 50. 
 p<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">X</span> &gt; <span style="color: #a0522d;">Y</span>, 

 <span style="color: #b22222;">% </span><span style="color: #b22222;">Con corte.</span>
 q<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">X</span> &gt; 15, <span style="color: #a020f0;">!</span>, <span style="color: #a0522d;">Y</span> &gt; 50. 
 q<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">X</span> &gt; <span style="color: #a0522d;">Y</span>, 

</pre>
</div>


<p>
Veamos que ocurre si ejecutamos el objetivo p(25,12):
</p>

<ul class="org-ul">
<li>Obsérve que ambas cláusulas unifican con la cabeza, luego existen
dos puntos de elección que se anotan.</li>
<li>Prolog entra por el primer punto de elección (primera cláusula)
eliminandolo.</li>
<li>Prolog ejecuta el primer objetivo del cuerpo (X&gt;15), que tiene
éxito.</li>
<li>Prolog ejecuta el segundo objetivo del cuerpo (X&gt;50), que falla.</li>
<li>Empieza el backtracking.</li>
<li>Se recorren ambos objetivos hacia atrás pero no hay variables que se
hayan ligado en ellos.</li>
<li>Encontramos el segundo punto de elección (segunda cláusula) que
detiene el backtracking eliminandolo en el proceso. La ejecución
continúa hacia delante.</li>
<li>Prolog ejecuta el cuerpo de la segunda cláusula que consiste en
X&gt;Y. Este objetivo tiene éxito.</li>
<li>El objetivo p(25,12) tiene éxito.</li>
</ul>

<p>
Ahora comprobamos lo que ocurre cuando éxiste el corte, ejecutamos q(25,12):
</p>

<ul class="org-ul">
<li>Ambas cláusulas unifican con la cabeza, luego existen dos puntos de
elección que se anotan.</li>
<li>Prolog entra por el primer punto de elección (primera cláusula)
eliminandolo.</li>
<li>Prolog ejecuta el primer objetivo del cuerpo (X&gt;15), que tiene
éxito.</li>
<li>Se ejecuta el segundo objetivo del cuerpo que es el corte. Por
tanto, se eliminan todos los puntos de elección anotados que son
debidos al objetivo q(25,12). Solamente teníamos uno, que se
elimina.</li>
<li>Prolog ejecuta el tercer objetivo del cuerpo (X&gt;50), que falla.</li>
<li>Empieza el backtracking.</li>
<li>Se recorren ambos objetivos hacia atrás pero no hay variables que se
hayan ligado en ellos.</li>
<li>No encontramos ningún punto de elección porque fueron eliminados por
el corte.</li>
<li>El objetivo p(25,12) falla.</li>
</ul>

<p>
Como puede comprobar, los resultados son sustacialmente diferentes. La
segunda cláusula del predicado q/2 ni siquiera ha llegado a ejecutarse
porque el corte ha comprometido el resultado del objetivo al resultado
de Y&gt;15 en la primera cláusula.
</p>
</div>


<div id="outline-container-org693bce3" class="outline-4">
<h4 id="org693bce3">Usos del corte</h4>
<div class="outline-text-4" id="text-org693bce3">
<p>
El corte se utiliza muy frecuentemente, cuanto más diestro es el
programador más lo suele usar. Los motivos por los que se usa el corte
son, por orden de importancia, los siguientes:
</p>

<ul class="org-ul">
<li>Para optimizar la ejecución. El corte sirve para evitar que por
culpa del backtracking se exploren puntos de elección que, con toda
seguridad, no llevan a otra solución (fallan). Para los entendidos,
esto es podar el árbol de búsqueda de posibles soluciones.</li>
<li><b>Para facilitar la legibilidad y comprensión del algoritmo que está
siendo programado</b>. A veces se situan cortes en puntos donde, con
toda seguridad, no van a existir puntos de elección para eliminar,
pero ayuda a entender que la ejecución sólo depende de la cláusula
en cuestión.</li>
<li>Para implementar algoritmos diferentes según la combinación de
argumentos de entrada. Algo similar al comportamiento de las
sentencias case en los lenguajes imperativos.</li>
<li>Para conseguir que un predicado solamente tenga una solución. Esto
nos puede interesar en algún momento. Una vez que el programa
encuentra una solución ejecutamos un corte. Así evitamos que Prolog
busque otras soluciones aunque sabemos que éstas existen.</li>
</ul>
</div>
</div>


<div id="outline-container-orgf5af999" class="outline-4">
<h4 id="orgf5af999">Corte y fallo</h4>
<div class="outline-text-4" id="text-orgf5af999">
<p>
Es muy habitual encontrar la secuencia de objetivos corte-fallo:
!,fail. El predicado fail/0 es un predicado predefinido que siempre
falla. Se utiliza para detectar prematuramente combinaciones de los
argumentos que no llevan a solución, evitando la ejecución de un
montón de código que al final va a fallar de todas formas.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">fib</span><span style="color: #707183;">(</span>0, 1<span style="color: #707183;">)</span> :- <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">fib</span><span style="color: #707183;">(</span>1, 1<span style="color: #707183;">)</span> :- <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">fib</span><span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">F</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">N</span> &gt; 1, <span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span>-1,  <span style="color: #a0522d;">N2</span> is <span style="color: #a0522d;">N</span>-2, fib<span style="color: #707183;">(</span><span style="color: #a0522d;">N1</span>, <span style="color: #a0522d;">F1</span><span style="color: #707183;">)</span>, fib<span style="color: #707183;">(</span><span style="color: #a0522d;">N2</span>, <span style="color: #a0522d;">F2</span><span style="color: #707183;">)</span>,
        <span style="color: #a0522d;">F</span> is <span style="color: #a0522d;">F1</span>+<span style="color: #a0522d;">F2</span>.
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org229676a" class="outline-3">
<h3 id="org229676a">Definición matemática del factorial</h3>
<div class="outline-text-3" id="text-org229676a">
<p>
Matemáticamente, el factorial de \( N \) (denotado como \( N! \)) se define como:
</p>

<ul class="org-ul">
<li>Caso base: \( 0! = 1 \)</li>
<li>Caso recursivo: \( N! = N \times (N - 1)! \) para \( N > 0 \)</li>
</ul>
</div>

<div id="outline-container-org3fdcfd5" class="outline-4">
<h4 id="org3fdcfd5">Implementación en Prolog</h4>
<div class="outline-text-4" id="text-org3fdcfd5">
<p>
La implementación en Prolog sigue esta definición. Usamos una regla
recursiva donde el caso base define que el factorial de 0 es 1, y
el caso recursivo multiplica \( N \) por el factorial de \( N - 1
   \).
</p>

<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #b22222;">% </span><span style="color: #b22222;">Caso base: el factorial de 0 es 1</span>
   factorial<span style="color: #707183;">(</span>0, 1<span style="color: #707183;">)</span> = <span style="color: #a020f0;">!</span>.

   <span style="color: #b22222;">% </span><span style="color: #b22222;">Caso recursivo: factorial de N es N * factorial de (N-1)</span>
   factorial<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">F</span><span style="color: #707183;">)</span> :-
       <span style="color: #a0522d;">N</span> &gt; 0,                           <span style="color: #b22222;">% </span><span style="color: #b22222;">Comprobaci&#243;n para asegurar que N es positivo</span>
       <span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> - 1,                     <span style="color: #b22222;">% </span><span style="color: #b22222;">Calcular N - 1</span>
       factorial<span style="color: #707183;">(</span><span style="color: #a0522d;">N1</span>, <span style="color: #a0522d;">F1</span><span style="color: #707183;">)</span>,               <span style="color: #b22222;">% </span><span style="color: #b22222;">Llamada recursiva para obtener factorial de N - 1</span>
       <span style="color: #a0522d;">F</span> is <span style="color: #a0522d;">N</span> * <span style="color: #a0522d;">F1</span>.                     <span style="color: #b22222;">% </span><span style="color: #b22222;">Calcular el factorial de N</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge84cf95" class="outline-4">
<h4 id="orge84cf95">Ejemplo de uso</h4>
<div class="outline-text-4" id="text-orge84cf95">
<p>
Para calcular el factorial de 5, usamos una consulta que unifica la
variable `F` con el resultado:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   ?- factorial<span style="color: #707183;">(</span>5, <span style="color: #a0522d;">F</span><span style="color: #707183;">)</span>.  <span style="color: #a0522d;">F</span> = 120.
</pre>
</div>

<p>
Prolog realiza la recursión de la siguiente manera:
</p>

<ol class="org-ol">
<li>Calcula `factorial(5, F)`.</li>
<li>Llama recursivamente a `factorial(4, F1)`, `factorial(3, F2)`, etc., hasta llegar a `factorial(0, 1)`.</li>
<li>Luego, cada llamada recursiva se resuelve multiplicando el valor, acumulando el resultado y regresando el valor final.</li>
</ol>
</div>
</div>

<div id="outline-container-org3ae9eaf" class="outline-4">
<h4 id="org3ae9eaf">Explicación paso a paso del proceso recursivo</h4>
<div class="outline-text-4" id="text-org3ae9eaf">
<p>
Para entender cómo se realiza la recursión, observa la secuencia de llamadas al calcular `factorial(3, F)`:
</p>

<ol class="org-ol">
<li>`factorial(3, F)` llama a `factorial(2, F1)`.</li>
<li>`factorial(2, F1)` llama a `factorial(1, F2)`.</li>
<li>`factorial(1, F2)` llama a `factorial(0, 1)`.</li>
<li>Al retornar, Prolog realiza las multiplicaciones:
<ul class="org-ul">
<li>`F2 = 1 * 1 = 1` para `factorial(1, 1)`.</li>
<li>`F1 = 2 * 1 = 2` para `factorial(2, 2)`.</li>
<li>`F = 3 * 2 = 6` para `factorial(3, 6)`.</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org2eaa871" class="outline-4">
<h4 id="org2eaa871">Resumen</h4>
<div class="outline-text-4" id="text-org2eaa871">
<ul class="org-ul">
<li><b><b>Caso base</b></b>: Define el factorial de 0 como 1.</li>
<li><b><b>Caso recursivo</b></b>: Define el factorial de \( N \) multiplicando \( N \) por el factorial de \( N - 1 \).</li>
</ul>

<p>
Esta implementación es un ejemplo clásico de recursión en Prolog y muestra cómo se usa el concepto de llamada recursiva para calcular valores acumulativos.
</p>
</div>
</div>







<div id="outline-container-org1c69d7d" class="outline-4">
<h4 id="org1c69d7d">Factorial en Prolog</h4>
<div class="outline-text-4" id="text-org1c69d7d">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">factorial</span><span style="color: #707183;">(</span>0, 1<span style="color: #707183;">)</span>.  
<span style="color: #0000ff;">factorial</span><span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">F</span><span style="color: #707183;">)</span> :-  
    <span style="color: #a0522d;">N</span> &gt; 0,  
    <span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> - 1,  
    factorial<span style="color: #707183;">(</span><span style="color: #a0522d;">N1</span>, <span style="color: #a0522d;">F1</span><span style="color: #707183;">)</span>,  
    <span style="color: #a0522d;">F</span> is <span style="color: #a0522d;">N</span> * <span style="color: #a0522d;">F1</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org5f5286e" class="outline-4">
<h4 id="org5f5286e">Prueba de escritorio para factorial(3, F)</h4>
<div class="outline-text-4" id="text-org5f5286e">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Llamada</th>
<th scope="col" class="org-right">N</th>
<th scope="col" class="org-right">N1</th>
<th scope="col" class="org-right">F1</th>
<th scope="col" class="org-left">F</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">factorial(3, F)</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">?</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">factorial(2, F1)</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">?</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">factorial(1, F1)</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">?</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-left">factorial(0, 1)</td>
<td class="org-right">0</td>
<td class="org-right">-</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
</tr>

<tr>
<td class="org-left">factorial(1, 1)</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">factorial(2, 2)</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">2</td>
</tr>

<tr>
<td class="org-left">factorial(3, 6)</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-left">6</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org8376e11" class="outline-4">
<h4 id="org8376e11">Resultado final: factorial(3,6)</h4>
<div class="outline-text-4" id="text-org8376e11">
<p>
Unificación en cada paso
</p>

<p>
Se llama factorial(3, F), N=3, unifica con la segunda regla.
</p>

<p>
Se calcula N1 is 3-1, unifica N1=2, se llama factorial(2, F1).
</p>

<p>
Se calcula N1 is 2-1, unifica N1=1, se llama factorial(1, F1).
</p>

<p>
Se calcula N1 is 1-1, unifica N1=0, se llama factorial(0, 1).
</p>

<p>
factorial(0,1) unifica con la primera regla, retorna F1=1.
</p>

<p>
Retrocede, F is 1*1, unifica F=1 para factorial(1,1).
</p>

<p>
Retrocede, F is 2*1, unifica F=2 para factorial(2,2).
</p>

<p>
Retrocede, F is 3*2, unifica F=6 para factorial(3,6).
</p>

<p>
Resultado final: factorial(3,6).
</p>
</div>
</div>



<div id="outline-container-org6d483b5" class="outline-4">
<h4 id="org6d483b5">Fibonacci en Prolog</h4>
<div class="outline-text-4" id="text-org6d483b5">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">fibonacci</span><span style="color: #707183;">(</span>0, 0<span style="color: #707183;">)</span>.  
<span style="color: #0000ff;">fibonacci</span><span style="color: #707183;">(</span>1, 1<span style="color: #707183;">)</span>.  
<span style="color: #0000ff;">fibonacci</span><span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">F</span><span style="color: #707183;">)</span>:- <span style="color: #a0522d;">N</span> &gt; 1, <span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> - 1,  <span style="color: #a0522d;">N2</span> is <span style="color: #a0522d;">N</span> - 2, fibonacci<span style="color: #707183;">(</span><span style="color: #a0522d;">N1</span>, <span style="color: #a0522d;">F1</span><span style="color: #707183;">)</span>,fibonacci<span style="color: #707183;">(</span><span style="color: #a0522d;">N2</span>, <span style="color: #a0522d;">F2</span><span style="color: #707183;">)</span>,
                  <span style="color: #a0522d;">F</span> is <span style="color: #a0522d;">F1</span> + <span style="color: #a0522d;">F2</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org718c9dd" class="outline-4">
<h4 id="org718c9dd">Prueba de escritorio para fibonacci(4, F)</h4>
<div class="outline-text-4" id="text-org718c9dd">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Llamada</th>
<th scope="col" class="org-right">N</th>
<th scope="col" class="org-right">N1</th>
<th scope="col" class="org-right">N2</th>
<th scope="col" class="org-right">F1</th>
<th scope="col" class="org-left">F2</th>
<th scope="col" class="org-right">F</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">fibonacci(4, F)</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">?</td>
<td class="org-left">?</td>
<td class="org-right">?</td>
</tr>

<tr>
<td class="org-left">fibonacci(3, F1)</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">?</td>
<td class="org-left">?</td>
<td class="org-right">?</td>
</tr>

<tr>
<td class="org-left">fibonacci(2, F1)</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">?</td>
<td class="org-left">?</td>
<td class="org-right">?</td>
</tr>

<tr>
<td class="org-left">fibonacci(1, 1)</td>
<td class="org-right">1</td>
<td class="org-right">-</td>
<td class="org-right">-</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">fibonacci(0, 0)</td>
<td class="org-right">0</td>
<td class="org-right">-</td>
<td class="org-right">-</td>
<td class="org-right">0</td>
<td class="org-left">-</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">fibonacci(2, 1)</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">fibonacci(3, 2)</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-left">fibonacci(4, 3)</td>
<td class="org-right">4</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">2</td>
<td class="org-left">1</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org9c3b0ad" class="outline-4">
<h4 id="org9c3b0ad">Resultado final: fibonacci(4,3)</h4>
<div class="outline-text-4" id="text-org9c3b0ad">
<p>
Unificación en cada paso
fibonacci(4, F), unifica con la tercera regla.
</p>

<p>
N1 is 4-1=3, N2 is 4-2=2, llama fibonacci(3, F1), fibonacci(2, F2).
</p>

<p>
fibonacci(3, F1), N1 is 3-1=2, N2 is 3-2=1, llama fibonacci(2, F1), fibonacci(1, F2).
</p>

<p>
fibonacci(2, F1), N1 is 2-1=1, N2 is 2-2=0, llama fibonacci(1, 1), fibonacci(0, 0).
</p>

<p>
fibonacci(1, 1) y fibonacci(0, 0) unifican con las primeras reglas.
</p>

<p>
Retrocede, F is 1+0=1 en fibonacci(2,1).
</p>

<p>
Retrocede, F is 1+1=2 en fibonacci(3,2).
</p>

<p>
Retrocede, F is 2+1=3 en fibonacci(4,3).
</p>

<p>
Resultado final: fibonacci(4,3).
</p>
</div>
</div>
</div>





<div id="outline-container-org4aca2e4" class="outline-3">
<h3 id="org4aca2e4">Listas en Prolog</h3>
<div class="outline-text-3" id="text-org4aca2e4">
</div>
<div id="outline-container-org42ead6a" class="outline-4">
<h4 id="org42ead6a">1. Definición y construcción de listas</h4>
<div class="outline-text-4" id="text-org42ead6a">
<p>
En Prolog, una lista se representa como una secuencia de elementos
entre corchetes. Algunos ejemplos de listas son:
</p>

<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #707183;">[]</span>             <span style="color: #b22222;">% </span><span style="color: #b22222;">Lista vac&#237;a</span>
   <span style="color: #707183;">[</span>1, 2, 3<span style="color: #707183;">]</span>      <span style="color: #b22222;">% </span><span style="color: #b22222;">Lista de n&#250;meros</span>
   <span style="color: #707183;">[</span>a, b, c<span style="color: #707183;">]</span>      <span style="color: #b22222;">% </span><span style="color: #b22222;">Lista de &#225;tomos</span>
   <span style="color: #707183;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #707183;">]</span>        <span style="color: #b22222;">% </span><span style="color: #b22222;">Lista con cabeza `H` y cola `T`</span>
</pre>
</div>

<p>
La lista `[H | T]` indica que `H` es el primer elemento (cabeza) y
`T` es la cola (el resto de los elementos de la lista).
</p>
</div>
</div>

<div id="outline-container-org429acc1" class="outline-4">
<h4 id="org429acc1">2. Operaciones básicas en listas</h4>
<div class="outline-text-4" id="text-org429acc1">
</div>
<ul class="org-ul">
<li><a id="org8dff872"></a>a) Concatenación de listas<br />
<div class="outline-text-5" id="text-org8dff872">
<p>
Para concatenar dos listas en Prolog, puedes definir una regla
recursiva llamada `concatenar`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    concatenar<span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">L</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.                        
    concatenar<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :- concatenar<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">L</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- concatenar<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2<span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>3, 4<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">L</span> = <span style="color: #707183;">[</span>1, 2, 3, 4<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</li>

<li><a id="orga670540"></a>b) Encontrar el tamaño de una lista<br />
<div class="outline-text-5" id="text-orga670540">
<p>
Para encontrar el tamaño de una lista, usamos una regla `tamano`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    tamano<span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, 0<span style="color: #707183;">)</span>.                               
    tamano<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">N</span><span style="color: #707183;">)</span> :-tamano<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">N1</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">N</span> is <span style="color: #a0522d;">N1</span> + 1.                             
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- tamano<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">N</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">N</span> = 3.
</pre>
</div>

<p>
<b>**</b> Explicación del funcionamiento del contador La regla `tamano`
cuenta el número de elementos en la lista usando recursión y un
contador acumulativo.
</p>

<ul class="org-ul">
<li>En el caso base `tamano([], 0).`, la lista vacía tiene un tamaño de `0`.</li>
<li>En la cláusula recursiva `tamano([_ | T], N) :- tamano(T, N1), N is N1 + 1.`:
<ul class="org-ul">
<li>Primero, se llama a `tamano(T, N1)` para contar el tamaño de la cola `T`.</li>
<li>Al volver de la recursión, `N1` contiene el tamaño de `T`, al
cual se suma `1` para contar el elemento de la cabeza.</li>
<li>Esta suma (`N is N1 + 1`) es el nuevo tamaño de la lista completa `[H | T]`.</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="org2ef0a96"></a>c) Obtener el último elemento de una lista<br />
<div class="outline-text-5" id="text-org2ef0a96">
<p>
Para obtener el último elemento de una lista, usamos la regla `ultimo`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    ultimo<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">X</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>.                              
    ultimo<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span> :- ultimo<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- ultimo<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">X</span> = 3.
</pre>
</div>
</div>
</li>

<li><a id="org1b4c731"></a>d) Obtener el primer elemento de una lista<br />
<div class="outline-text-5" id="text-org1b4c731">
<p>
El primer elemento de una lista es simplemente la cabeza de la lista, que se puede obtener así:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    primer_elemento<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">_</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">H</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- primer_elemento<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">X</span> = 1.
</pre>
</div>
</div>
</li>

<li><a id="orgd1d5c77"></a>e) Invertir una lista<br />
<div class="outline-text-5" id="text-orgd1d5c77">
<p>
Para invertir una lista, utilizamos una regla `invertir` que emplea acumuladores para construir la lista invertida:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    invertir<span style="color: #707183;">(</span><span style="color: #a0522d;">L</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-
        invertir_acum<span style="color: #707183;">(</span><span style="color: #a0522d;">L</span>, <span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.

    invertir_acum<span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">Acc</span>, <span style="color: #a0522d;">Acc</span><span style="color: #707183;">)</span>.                 
    invertir_acum<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Acc</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-            
        invertir_acum<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">Acc</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- invertir<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">L</span> = <span style="color: #707183;">[</span>3, 2, 1<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org0b08e3d" class="outline-4">
<h4 id="org0b08e3d">3. Otras operaciones comunes</h4>
<div class="outline-text-4" id="text-org0b08e3d">
</div>
<ul class="org-ul">
<li><a id="org63e0630"></a>a) Verificar si un elemento pertenece a una lista<br />
<div class="outline-text-5" id="text-org63e0630">
<p>
Para verificar si un elemento está en una lista, usamos la regla `miembro`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    miembro<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">X</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">_</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.                         
    miembro<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :- miembro<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">T</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- miembro<span style="color: #707183;">(</span>2, <span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
    true.
    ?- miembro<span style="color: #707183;">(</span>4, <span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
    false.
</pre>
</div>
</div>
</li>

<li><a id="org8ecf0b3"></a>b) Eliminar un elemento de una lista<br />
<div class="outline-text-5" id="text-org8ecf0b3">
<p>
La siguiente regla `eliminar` elimina una ocurrencia de un elemento de una lista:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    eliminar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">X</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">T</span><span style="color: #707183;">)</span>.                     
    eliminar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-             
        eliminar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- eliminar<span style="color: #707183;">(</span>2, <span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">L</span> = <span style="color: #707183;">[</span>1, 3<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</li>

<li><a id="org8cb4b0a"></a>c) Insertar un elemento en una lista<br />
<div class="outline-text-5" id="text-org8cb4b0a">
<p>
Para insertar un elemento en cualquier posición de una lista, definimos una regla `insertar`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    insertar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">L</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">X</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">L</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.                     
    insertar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-             
        insertar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- insertar<span style="color: #707183;">(</span>4, <span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">L</span> = <span style="color: #707183;">[</span>4, 1, 2, 3<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</li>

<li><a id="org0531130"></a>d) Verificar si una lista es un sublista de otra<br />
<div class="outline-text-5" id="text-org0531130">
<p>
Para verificar si una lista `Sub` es sublista de `L`, usamos la regla `sublista`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    sublista<span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">_</span><span style="color: #707183;">)</span>.                             
    sublista<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T2</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-               
        sublista<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">T2</span><span style="color: #707183;">)</span>.
    sublista<span style="color: #707183;">(</span><span style="color: #a0522d;">Sub</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-                    
        sublista<span style="color: #707183;">(</span><span style="color: #a0522d;">Sub</span>, <span style="color: #a0522d;">T</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- sublista<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>2, 3<span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>1, 2, 3, 4<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
    true.
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-org6081baf" class="outline-4">
<h4 id="org6081baf">4. Ejemplos adicionales y casos de uso</h4>
<div class="outline-text-4" id="text-org6081baf">
<p>
Prolog permite expresar fácilmente otras operaciones sobre listas,
como el filtrado de elementos que cumplen una condición específica
o el uso de listas en combinaciones y permutaciones.
</p>
</div>

<ul class="org-ul">
<li><a id="org2563d34"></a>a) Filtrar elementos mayores a un valor<br />
<div class="outline-text-5" id="text-org2563d34">
<p>
Definamos `filtrar<sub>mayores</sub>` para obtener elementos mayores a un valor `N`:
</p>

<div class="org-src-container">
<pre class="src src-prolog">    filtrar_mayores<span style="color: #707183;">(</span><span style="color: #a0522d;">_</span>, <span style="color: #7388d6;">[]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.                         
    filtrar_mayores<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-             
        <span style="color: #a0522d;">H</span> &gt; <span style="color: #a0522d;">N</span>,
        filtrar_mayores<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
    filtrar_mayores<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span> <span style="color: #a020f0;">|</span> <span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-                   
        filtrar_mayores<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo de uso:
</p>
<div class="org-src-container">
<pre class="src src-prolog">    ?- filtrar_mayores<span style="color: #707183;">(</span>2, <span style="color: #7388d6;">[</span>1, 3, 5, 2<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.
    <span style="color: #a0522d;">L</span> = <span style="color: #707183;">[</span>3, 5<span style="color: #707183;">]</span>.
</pre>
</div>


<ul class="org-ul">
<li>Cálculo del factorial en Prolog</li>
</ul>

<p>
El cálculo del factorial de un número \( N \) se define como el
producto de todos los números enteros positivos desde \( 1 \) hasta \(
N \). En Prolog, podemos implementar esta operación utilizando una
regla recursiva.
</p>
</div>
</li>
</ul>
</div>
</div>



<div id="outline-container-org9caec7c" class="outline-3">
<h3 id="org9caec7c">Ejercicios</h3>
<div class="outline-text-3" id="text-org9caec7c">
</div>
<div id="outline-container-orgb1192fa" class="outline-4">
<h4 id="orgb1192fa">Problema: Los hermanos y sus mascotas</h4>
<div class="outline-text-4" id="text-orgb1192fa">
<p>
Cuatro hermanos (Ana, Bruno, Carla y Daniel) tienen cada uno una
mascota diferente (perro, gato, loro y pez). Sabemos que:
</p>

<ul class="org-ul">
<li>Ana no tiene un perro ni un pez.</li>
<li>Bruno no tiene un gato.</li>
<li>Carla tiene un animal que no es el pez.</li>
<li>Daniel tiene un loro o un pez.</li>
<li>Pregunta: ¿Qué mascota tiene cada hermano?</li>
</ul>

<p>
Representación en Prolog: Define los hermanos y las mascotas como individuos.
Utiliza reglas y hechos basados en las pistas para determinar qué mascota tiene cada hermano.
</p>

<p>
Objetivo: Escribir un programa en Prolog que determine la asignación
correcta de mascotas para cada hermano en función de las pistas dadas.
</p>
</div>
</div>

<div id="outline-container-org2ebc57c" class="outline-4">
<h4 id="org2ebc57c">Solución</h4>
<div class="outline-text-4" id="text-org2ebc57c">
<div class="org-src-container">
<pre class="src src-prolog">
<span style="color: #b22222;">% </span><span style="color: #b22222;">Definimos los hermanos y las mascotas posibles</span>
<span style="color: #0000ff;">hermano</span><span style="color: #707183;">(</span>ana<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">hermano</span><span style="color: #707183;">(</span>bruno<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">hermano</span><span style="color: #707183;">(</span>carla<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">hermano</span><span style="color: #707183;">(</span>daniel<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">mascota</span><span style="color: #707183;">(</span>perro<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">mascota</span><span style="color: #707183;">(</span>gato<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">mascota</span><span style="color: #707183;">(</span>loro<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">mascota</span><span style="color: #707183;">(</span>pez<span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Regla que establece que cada hermano tiene una mascota &#250;nica</span>
<span style="color: #0000ff;">tiene_mascota</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Hermano</span>, <span style="color: #a0522d;">Mascota</span><span style="color: #707183;">)</span> :-
    hermano<span style="color: #707183;">(</span><span style="color: #a0522d;">Hermano</span><span style="color: #707183;">)</span>,
    mascota<span style="color: #707183;">(</span><span style="color: #a0522d;">Mascota</span><span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Restricciones espec&#237;ficas seg&#250;n las pistas</span>
<span style="color: #0000ff;">restricciones</span> :-
    tiene_mascota<span style="color: #707183;">(</span>ana, <span style="color: #a0522d;">MascotaAna</span><span style="color: #707183;">)</span>,
    <span style="color: #a0522d;">MascotaAna</span> \= perro,
    <span style="color: #a0522d;">MascotaAna</span> \= pez,

    tiene_mascota<span style="color: #707183;">(</span>bruno, <span style="color: #a0522d;">MascotaBruno</span><span style="color: #707183;">)</span>,
    <span style="color: #a0522d;">MascotaBruno</span> \= gato,

    tiene_mascota<span style="color: #707183;">(</span>carla, <span style="color: #a0522d;">MascotaCarla</span><span style="color: #707183;">)</span>,
    <span style="color: #a0522d;">MascotaCarla</span> \= pez,

    tiene_mascota<span style="color: #707183;">(</span>daniel, <span style="color: #a0522d;">MascotaDaniel</span><span style="color: #707183;">)</span>,
    <span style="color: #707183;">(</span><span style="color: #a0522d;">MascotaDaniel</span> = loro <span style="color: #a020f0;">;</span> <span style="color: #a0522d;">MascotaDaniel</span> = pez<span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Regla para asegurar que todos tienen mascotas distintas</span>
<span style="color: #0000ff;">todos_diferentes</span><span style="color: #707183;">(</span><span style="color: #a0522d;">MascotaAna</span>, <span style="color: #a0522d;">MascotaBruno</span>, <span style="color: #a0522d;">MascotaCarla</span>, <span style="color: #a0522d;">MascotaDaniel</span><span style="color: #707183;">)</span> :-
    <span style="color: #a0522d;">MascotaAna</span> \= <span style="color: #a0522d;">MascotaBruno</span>,
    <span style="color: #a0522d;">MascotaAna</span> \= <span style="color: #a0522d;">MascotaCarla</span>,
    <span style="color: #a0522d;">MascotaAna</span> \= <span style="color: #a0522d;">MascotaDaniel</span>,
    <span style="color: #a0522d;">MascotaBruno</span> \= <span style="color: #a0522d;">MascotaCarla</span>,
    <span style="color: #a0522d;">MascotaBruno</span> \= <span style="color: #a0522d;">MascotaDaniel</span>,
    <span style="color: #a0522d;">MascotaCarla</span> \= <span style="color: #a0522d;">MascotaDaniel</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Mostrar resultados</span>
<span style="color: #0000ff;">mostrar_resultados</span><span style="color: #707183;">(</span><span style="color: #a0522d;">MascotaAna</span>, <span style="color: #a0522d;">MascotaBruno</span>, <span style="color: #a0522d;">MascotaCarla</span>, <span style="color: #a0522d;">MascotaDaniel</span><span style="color: #707183;">)</span> :-
    format<span style="color: #707183;">(</span><span style="color: #8b2252;">'Ana tiene un ~w~n'</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">MascotaAna</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>,
    format<span style="color: #707183;">(</span><span style="color: #8b2252;">'Bruno tiene un ~w~n'</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">MascotaBruno</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>,
    format<span style="color: #707183;">(</span><span style="color: #8b2252;">'Carla tiene un ~w~n'</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">MascotaCarla</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>,
    format<span style="color: #707183;">(</span><span style="color: #8b2252;">'Daniel tiene un ~w~n'</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">MascotaDaniel</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Regla principal que resuelve el problema</span>
<span style="color: #0000ff;">resolver</span> :-
    tiene_mascota<span style="color: #707183;">(</span>ana, <span style="color: #a0522d;">MascotaAna</span><span style="color: #707183;">)</span>,
    tiene_mascota<span style="color: #707183;">(</span>bruno, <span style="color: #a0522d;">MascotaBruno</span><span style="color: #707183;">)</span>,
    tiene_mascota<span style="color: #707183;">(</span>carla, <span style="color: #a0522d;">MascotaCarla</span><span style="color: #707183;">)</span>,
    tiene_mascota<span style="color: #707183;">(</span>daniel, <span style="color: #a0522d;">MascotaDaniel</span><span style="color: #707183;">)</span>,
    restricciones,
    todos_diferentes<span style="color: #707183;">(</span><span style="color: #a0522d;">MascotaAna</span>, <span style="color: #a0522d;">MascotaBruno</span>, <span style="color: #a0522d;">MascotaCarla</span>, <span style="color: #a0522d;">MascotaDaniel</span><span style="color: #707183;">)</span>,
    mostrar_resultados<span style="color: #707183;">(</span><span style="color: #a0522d;">MascotaAna</span>, <span style="color: #a0522d;">MascotaBruno</span>, <span style="color: #a0522d;">MascotaCarla</span>, <span style="color: #a0522d;">MascotaDaniel</span><span style="color: #707183;">)</span>.

</pre>
</div>
</div>
</div>


<div id="outline-container-orgec3d5ab" class="outline-4">
<h4 id="orgec3d5ab">Problema: Los investigadores y sus descubrimientos</h4>
<div class="outline-text-4" id="text-orgec3d5ab">
<p>
Cinco investigadores (Alonso, Beatriz, Carlos, Diana y Eduardo) han hecho
descubrimientos importantes en cinco áreas diferentes de la ciencia
(astronomía, biología, química, física y geología) y cada uno es
originario de un país distinto (México, España, Canadá, Japón y
Alemania). Cada investigador tiene un instrumento favorito
(microscopio, telescopio, acelerador, sismógrafo y espectrómetro) y
una especialidad secundaria (botánica, genética, oceanografía,
paleontología y vulcanología).
</p>

<p>
Las siguientes pistas te ayudarán a deducir qué descubrimiento hizo
cada investigador, su país de origen, su instrumento favorito y su
especialidad secundaria:
</p>

<ul class="org-ul">
<li>Carlos no es de México ni de Canadá, y no estudia biología.</li>
<li>La persona que usa el telescopio es de Japón y trabaja en
astronomía, pero no es Diana.</li>
<li>Beatriz es experta en botánica y no es de España ni de Japón.</li>
<li>La persona que usa el microscopio trabaja en biología y no es de
Alemania ni de España.</li>
<li>El investigador de física es de México y utiliza el acelerador.</li>
<li>El especialista en genética usa el espectrómetro y no es Eduardo.</li>
<li>El investigador de Canadá se dedica a la geología.</li>
<li>Eduardo estudia vulcanología y no utiliza el telescopio.</li>
<li>Alonso es el experto en oceanografía.</li>
<li>El investigador de Alemania utiliza un sismógrafo.</li>
</ul>

<p>
Pregunta: ¿Cuál es el descubrimiento de cada investigador, su país de
origen, su instrumento favorito y su especialidad secundaria?
</p>
</div>
</div>
</div>


<div id="outline-container-orge5b1ca6" class="outline-3">
<h3 id="orge5b1ca6">Variables Anónimas en Prolog</h3>
<div class="outline-text-3" id="text-orge5b1ca6">
<p>
En Prolog, las variables anónimas se representan mediante el guion
bajo ( _ ). Estas variables son útiles cuando no necesitamos almacenar
un valor específico y solo queremos que el predicado se ejecute sin
importar el valor de esa variable.
</p>
</div>

<div id="outline-container-org96311f9" class="outline-4">
<h4 id="org96311f9">Características de las Variables Anónimas</h4>
<div class="outline-text-4" id="text-org96311f9">
<ul class="org-ul">
<li>Una variable anónima ( _ ) es una variable "sin nombre".</li>
<li>No almacena ningún valor.</li>
<li>Cada vez que aparece en una expresión, se trata como una variable
completamente nueva.</li>
<li>Es útil cuando una parte del predicado no es relevante y solo
queremos que coincida.</li>
</ul>
</div>
</div>

<div id="outline-container-org372ff31" class="outline-4">
<h4 id="org372ff31">Ejemplo</h4>
<div class="outline-text-4" id="text-org372ff31">
<p>
Supongamos que tenemos un predicado `padre/2`, que indica una relación
entre un padre y su hijo:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>juan, maria<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>carlos, pedro<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>juan, jose<span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Si queremos encontrar todos los hijos de Juan, podemos usar una
consulta de esta forma:
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- padre<span style="color: #707183;">(</span>juan, <span style="color: #a0522d;">Hijo</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Sin embargo, si solo queremos verificar si Juan tiene algún hijo, sin
importar quién sea, podemos utilizar la variable anónima:
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- padre<span style="color: #707183;">(</span>juan, <span style="color: #a0522d;">_</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Esta consulta devolverá `true` si Juan tiene al menos un hijo, ya que
no necesitamos el valor del hijo específico.
</p>
</div>
</div>

<div id="outline-container-org917daeb" class="outline-4">
<h4 id="org917daeb">Casos Comunes de Uso</h4>
<div class="outline-text-4" id="text-org917daeb">
<ul class="org-ul">
<li>Ignorar ciertos argumentos en un predicado.</li>
<li>Simplificar consultas en las que solo se desea verificar la
existencia de alguna condición.</li>
<li>Evitar que Prolog almacene valores innecesarios en la consulta.</li>
</ul>
</div>
</div>

<div id="outline-container-org46c74bf" class="outline-4">
<h4 id="org46c74bf">Ejercicio</h4>
<div class="outline-text-4" id="text-org46c74bf">
<p>
Intenta ejecutar las siguientes consultas para entender el uso de
variables anónimas:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #b22222;">% </span><span style="color: #b22222;">1. Consulta para verificar si Carlos tiene alg&#250;n hijo.  ?-</span>
<span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>carlos, <span style="color: #a0522d;">_</span><span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">2. Consulta para verificar si existe alguna relaci&#243;n padre-hijo en</span>
la base de datos.  ?- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">_</span>, <span style="color: #a0522d;">_</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Cada una de estas consultas ignorará los valores específicos y solo
verificará la existencia de la relación.
</p>
</div>
</div>
</div>





<div id="outline-container-orgadc5216" class="outline-3">
<h3 id="orgadc5216">Predicados Mitológicos en Programación Lógica</h3>
<div class="outline-text-3" id="text-orgadc5216">
</div>
<div id="outline-container-orgf2c4559" class="outline-4">
<h4 id="orgf2c4559">Introducción</h4>
<div class="outline-text-4" id="text-orgf2c4559">
<p>
En programación lógica, los predicados mitológicos son aquellos que
destacan por su utilidad, flexibilidad y elegancia en la solución de
problemas comunes o complejos. Estos predicados pueden resolver
múltiples casos con reglas generales, lo que les otorga un carácter
"mágico". Su uso es común en lenguajes como Prolog.
</p>
</div>
</div>

<div id="outline-container-org385bd47" class="outline-4">
<h4 id="org385bd47">Ejemplos Detallados de Predicados Mitológicos</h4>
<div class="outline-text-4" id="text-org385bd47">
</div>
<ul class="org-ul">
<li><a id="org8a660b0"></a>1. maplist<br />
<div class="outline-text-5" id="text-org8a660b0">
<p>
El predicado <b>maplist</b> aplica un predicado a cada elemento de una lista
y genera una lista transformada.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">maplist</span><span style="color: #707183;">(</span><span style="color: #a0522d;">_</span>, <span style="color: #7388d6;">[]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">maplist</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Predicado</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H1</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T1</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H2</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T2</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-
    call<span style="color: #707183;">(</span><span style="color: #a0522d;">Predicado</span>, <span style="color: #a0522d;">H1</span>, <span style="color: #a0522d;">H2</span><span style="color: #707183;">)</span>, maplist<span style="color: #707183;">(</span><span style="color: #a0522d;">Predicado</span>, <span style="color: #a0522d;">T1</span>, <span style="color: #a0522d;">T2</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo: Calcular el cuadrado de cada número en una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">cuadrado</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Y</span> is <span style="color: #a0522d;">X</span> * <span style="color: #a0522d;">X</span>.
?- maplist<span style="color: #707183;">(</span>cuadrado, <span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Resultados</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Resultados = [1, 4, 9].</span>
</pre>
</div>
</div>
</li>

<li><a id="org3ba7900"></a>2. permutacion<br />
<div class="outline-text-5" id="text-org3ba7900">
<p>
Genera todas las permutaciones posibles de una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">permutacion</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">permutacion</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">P</span><span style="color: #707183;">)</span> :- permutacion<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>, insertar<span style="color: #707183;">(</span><span style="color: #a0522d;">H</span>, <span style="color: #a0522d;">R</span>, <span style="color: #a0522d;">P</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">insertar</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">L</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">X</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">L</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">insertar</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :- insertar<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo: Enumerar las permutaciones de una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- permutacion<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">P</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">P = [1, 2, 3];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">P = [1, 3, 2];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">P = [2, 1, 3];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">...</span>
</pre>
</div>
</div>
</li>

<li><a id="org7392054"></a>3. append<br />
<div class="outline-text-5" id="text-org7392054">
<p>
El predicado <b>append</b> combina dos listas en una o las divide en dos partes.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">append</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">L</span>, <span style="color: #a0522d;">L</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">append</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">L</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-
    append<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">L</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo 1: Concatenar listas.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- append<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2<span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>3, 4<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Resultado</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Resultado = [1, 2, 3, 4].</span>
</pre>
</div>

<p>
Ejemplo 2: Dividir una lista en dos partes.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- append<span style="color: #707183;">(</span><span style="color: #a0522d;">L1</span>, <span style="color: #a0522d;">L2</span>, <span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">L1 = [];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">L2 = [1, 2, 3];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">L1 = [1];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">L2 = [2, 3];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">...</span>
</pre>
</div>
</div>
</li>

<li><a id="org81d10e4"></a>4. subconjunto<br />
<div class="outline-text-5" id="text-org81d10e4">
<p>
Genera todos los subconjuntos posibles de una lista, útil en problemas combinatorios.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">subconjunto</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">subconjunto</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">R</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-
<span style="color: #0000ff;">subconjunto</span><span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">subconjunto</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-
    subconjunto<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo: Generar subconjuntos.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- subconjunto<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">S</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">S = [];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">S = [1];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">S = [2];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">S = [1, 2];</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">...</span>
</pre>
</div>
</div>
</li>

<li><a id="orgc1fa2b3"></a>5. reverse<br />
<div class="outline-text-5" id="text-orgc1fa2b3">
<p>
Invierte los elementos de una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">reverse</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">reverse</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-
    reverse<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">RevT</span><span style="color: #707183;">)</span>,
    append<span style="color: #707183;">(</span><span style="color: #a0522d;">RevT</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Ejemplo: Invertir una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- reverse<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 2, 3<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [3, 2, 1].</span>
</pre>
</div>
</div>
</li>

<li><a id="org6918e82"></a>6. flatten<br />
<div class="outline-text-5" id="text-org6918e82">
<p>
Convierte una lista con estructuras anidadas en una lista plana.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">flatten</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">flatten</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-
    flatten<span style="color: #707183;">(</span><span style="color: #a0522d;">H</span>, <span style="color: #a0522d;">RH</span><span style="color: #707183;">)</span>,
    flatten<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>, <span style="color: #a0522d;">RT</span><span style="color: #707183;">)</span>,
    append<span style="color: #707183;">(</span><span style="color: #a0522d;">RH</span>, <span style="color: #a0522d;">RT</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">flatten</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">X</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :-
    <span style="color: #a0522d;">X</span> \= <span style="color: #707183;">[]</span>,
    <span style="color: #a0522d;">X</span> \= <span style="color: #707183;">[</span><span style="color: #a0522d;">_</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">_</span><span style="color: #707183;">]</span>.
</pre>
</div>

<p>
Ejemplo: Aplanar una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- flatten<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, <span style="color: #909183;">[</span>2, <span style="color: #709870;">[</span>3, 4<span style="color: #709870;">]</span><span style="color: #909183;">]</span>, 5<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [1, 2, 3, 4, 5].</span>
</pre>
</div>

<p>
Aplanar una lista vacía simplemente devuelve otra lista vacía.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- flatten<span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [].</span>
</pre>
</div>

<p>
Los elementos atómicos y las listas vacías no se modifican en el resultado.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- flatten<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, <span style="color: #909183;">[]</span>, <span style="color: #909183;">[</span>2, <span style="color: #709870;">[</span>3, <span style="color: #907373;">[]</span><span style="color: #709870;">]</span>, 4<span style="color: #909183;">]</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [1, 2, 3, 4].</span>
</pre>
</div>

<p>
Aplanar múltiples niveles de anidación.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- flatten<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #909183;">[</span>a, <span style="color: #709870;">[</span>b, c<span style="color: #709870;">]</span><span style="color: #909183;">]</span>, <span style="color: #909183;">[</span>d, <span style="color: #709870;">[</span>e, f<span style="color: #709870;">]</span><span style="color: #909183;">]</span>, g<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [a, b, c, d, e, f, g].</span>
</pre>
</div>
</div>
</li>

<li><a id="org0515c10"></a>7. findall<br />
<div class="outline-text-5" id="text-org0515c10">
<p>
El predicado <b>findall</b> recolecta todas las soluciones posibles de un
predicado y las devuelve en una lista. Es útil para realizar consultas
y almacenar resultados.
</p>


<p>
Ejemplo: Recolectar miembros de una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, member<span style="color: #7388d6;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #909183;">[</span>1, 2, 3<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Soluciones</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Soluciones = [1, 2, 3].</span>
</pre>
</div>

<p>
Ejemplo: Recuperar todos los elementos de una lista utilizando el predicado `member`.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, member<span style="color: #7388d6;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #909183;">[</span>1, 2, 3<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Resultados</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Resultados = [1, 2, 3].</span>
</pre>
</div>

<p>
Ejemplo : Recolectar pares ordenados donde el segundo elemento es el doble del primero.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">doble</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Y</span> is <span style="color: #a0522d;">X</span> * 2.
?- findall<span style="color: #707183;">(</span><span style="color: #7388d6;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #7388d6;">)</span>, <span style="color: #7388d6;">(</span>member<span style="color: #909183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #709870;">[</span>1, 2, 3<span style="color: #709870;">]</span><span style="color: #909183;">)</span>, doble<span style="color: #909183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Pares</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Pares = [(1, 2), (2, 4), (3, 6)].</span>
</pre>
</div>

<p>
Ejemplo: Usar el predicado <b>permutacion</b> para generar y recolectar permutaciones de una lista.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">P</span>, permutacion<span style="color: #7388d6;">(</span><span style="color: #909183;">[</span>1, 2, 3<span style="color: #909183;">]</span>, <span style="color: #a0522d;">P</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Permutaciones</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Permutaciones = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]].</span>
</pre>
</div>

<p>
Ejemplo: Recolectar los números en una lista que están en un rango definido.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">en_rango</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">X</span> &gt;= 10, <span style="color: #a0522d;">X</span> =&lt; 20.
?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">(</span>member<span style="color: #909183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #709870;">[</span>5, 10, 15, 20, 25<span style="color: #709870;">]</span><span style="color: #909183;">)</span>, en_rango<span style="color: #909183;">(</span><span style="color: #a0522d;">X</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Filtrados</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Filtrados = [10, 15, 20].</span>
</pre>
</div>

<p>
Ejemplo: Usar <b>findall</b> junto con <b>length</b> para contar cuántas soluciones tiene un predicado.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, member<span style="color: #7388d6;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #909183;">[</span>a, b, c, d<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Soluciones</span><span style="color: #707183;">)</span>, length<span style="color: #707183;">(</span><span style="color: #a0522d;">Soluciones</span>, <span style="color: #a0522d;">Total</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Soluciones = [a, b, c, d],</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">Total = 4.</span>
</pre>
</div>

<p>
Ejemplo:  Ejemplo 6: Uso combinado con <b>flatten</b>
Recolectar listas anidadas y luego aplanarlas.
</p>

<div class="org-src-container">
<pre class="src src-prolog">?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">SubLista</span>, member<span style="color: #7388d6;">(</span><span style="color: #a0522d;">SubLista</span>, <span style="color: #909183;">[</span><span style="color: #709870;">[</span>1, 2<span style="color: #709870;">]</span>, <span style="color: #709870;">[</span>3, <span style="color: #907373;">[</span>4, 5<span style="color: #907373;">]</span><span style="color: #709870;">]</span>, 6<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Listas</span><span style="color: #707183;">)</span>,
   flatten<span style="color: #707183;">(</span><span style="color: #a0522d;">Listas</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Listas = [[1, 2], [3, [4, 5]], 6],</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [1, 2, 3, 4, 5, 6].</span>
</pre>
</div>

<p>
Ejemplo: Recolectar todas las soluciones que cumplen una condición, como encontrar números primos en un rango.
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">es_primo</span><span style="color: #707183;">(</span><span style="color: #a0522d;">N</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">N</span> &gt; 1, \+ <span style="color: #707183;">(</span>between<span style="color: #7388d6;">(</span>2, <span style="color: #a0522d;">N1</span>, <span style="color: #a0522d;">N</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">N1</span> &lt; <span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">N</span> mod <span style="color: #a0522d;">N1</span> =:= 0<span style="color: #707183;">)</span>.
?- findall<span style="color: #707183;">(</span><span style="color: #a0522d;">Primo</span>, <span style="color: #7388d6;">(</span>between<span style="color: #909183;">(</span>1, 20, <span style="color: #a0522d;">Primo</span><span style="color: #909183;">)</span>, es\<span style="color: #a0522d;">_primo</span><span style="color: #909183;">(</span><span style="color: #a0522d;">Primo</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>, <span style="color: #a0522d;">Primos</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Primos = [2, 3, 5, 7, 11, 13, 17, 19].</span>
</pre>
</div>


<p>
Estos predicados <b>mitológicos</b> destacan en programación lógica por su
capacidad para abordar una amplia variedad de problemas. Al dominar
estos predicados, los programadores pueden escribir código más
elegante y eficiente, aprovechando la potencia de lenguajes como
Prolog para resolver problemas complejos de manera declarativa.
</p>
</div>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgc115569" class="outline-3">
<h3 id="orgc115569">Problemas con Predicados Mitológicos</h3>
<div class="outline-text-3" id="text-orgc115569">
</div>
<div id="outline-container-org33c2216" class="outline-4">
<h4 id="org33c2216">1. Aplanar una lista de listas anidadas</h4>
<div class="outline-text-4" id="text-org33c2216">
<p>
Utiliza el predicado <b>flatten</b> para transformar una estructura
anidada en una lista plana.
</p>

<p>
<b><b>Problema:</b></b>  
Dada una lista como <b>[1, [2, [3, 4], 5], [6]]</b>, genera <b>[1, 2, 3, 4, 5, 6]</b>.
</p>

<p>
<b><b>Predicado:</b></b>  
`flatten`.
</p>
</div>
</div>

<div id="outline-container-orgfb58e99" class="outline-4">
<h4 id="orgfb58e99">2. Encontrar todas las permutaciones de una lista</h4>
<div class="outline-text-4" id="text-orgfb58e99">
<p>
Utiliza *permutacion*` para generar todas las permutaciones posibles de una lista.
</p>

<p>
<b><b>Problema:</b></b>  
Dada la lista <b>[a, b, c]</b>, genera las permutaciones:
</p>
<ul class="org-ul">
<li>[a, b, c]</li>
<li>[a, c, b]</li>
<li>[b, a, c]</li>
<li>[b, c, a]</li>
<li>[c, a, b]</li>
<li>[c, b, a]</li>
</ul>

<p>
<b><b>Predicado:</b></b>  
`permutacion/2`.
</p>
</div>
</div>

<div id="outline-container-org45a658c" class="outline-4">
<h4 id="org45a658c">3. Generar subconjuntos de una lista</h4>
<div class="outline-text-4" id="text-org45a658c">
<p>
Utiliza <b>subconjunto</b> para encontrar todos los subconjuntos posibles de una lista.
</p>

<p>
<b><b>Problema:</b></b>  
Dada la lista <b>[1, 2, 3]</b>, genera:
</p>
<ul class="org-ul">
<li>[]</li>
<li>[1]</li>
<li>[2]</li>
<li>[3]</li>
<li>[1, 2]</li>
<li>[1, 3]</li>
<li>[2, 3]</li>
<li>[1, 2, 3]</li>
</ul>

<p>
<b><b>Predicado:</b></b>  
subconjunto.
</p>
</div>
</div>

<div id="outline-container-orgc7e66f0" class="outline-4">
<h4 id="orgc7e66f0">4. Encontrar todos los números en un rango que cumplen una condición</h4>
<div class="outline-text-4" id="text-orgc7e66f0">
<p>
Usa findall para encontrar números que cumplan una propiedad específica, como ser pares o primos.
</p>

<p>
<b><b>Problema:</b></b>  
Encuentra todos los números primos entre 1 y 20.
</p>

<p>
<b><b>Predicados:</b></b>  
<b>findall</b>, <b>es\<sub>primo</sub></b>.
</p>
</div>
</div>

<div id="outline-container-orgd978b95" class="outline-4">
<h4 id="orgd978b95">5. Concatenar dos listas</h4>
<div class="outline-text-4" id="text-orgd978b95">
<p>
Usa <b>append</b> para combinar dos listas en una sola.
</p>

<p>
<b><b>Problema:</b></b>  
Combina `[1, 2]` y `[3, 4]` en `[1, 2, 3, 4]`.
</p>

<p>
<b><b>Predicado:</b></b>  
<b>append</b>.
</p>
</div>
</div>

<div id="outline-container-orgb6201de" class="outline-4">
<h4 id="orgb6201de">6. Encontrar elementos únicos en una lista</h4>
<div class="outline-text-4" id="text-orgb6201de">
<p>
Usa <b>findall</b> y <b>member</b> para eliminar duplicados.
</p>

<p>
<b><b>Problema:</b></b>  
Dada la lista <b>[1, 2, 2, 3, 3, 3, 4]</b>, genera <b>[1, 2, 3, 4]</b>.
</p>

<p>
<b><b>Predicados:</b></b>  
<b>findall</b>, <b>member</b>.
</p>
</div>
</div>

<div id="outline-container-orgc352e1a" class="outline-4">
<h4 id="orgc352e1a">7. Calcular la potencia de un número</h4>
<div class="outline-text-4" id="text-orgc352e1a">
<p>
Usa un predicado recursivo y `findall/3` para calcular todas las potencias de un número hasta un límite.
</p>

<p>
<b><b>Problema:</b></b>  
Dado el número 2, calcula sus potencias hasta \( 2^5 \):  
</p>
<ul class="org-ul">
<li>[1, 2, 4, 8, 16, 32]</li>
</ul>

<p>
<b><b>Predicado:</b></b>  
<b>findall</b>.
</p>
</div>
</div>

<div id="outline-container-orge3d29ff" class="outline-4">
<h4 id="orge3d29ff">8. Alinear equipos en un torneo</h4>
<div class="outline-text-4" id="text-orge3d29ff">
<p>
Usa *permutacion*` para generar todas las alineaciones posibles de
equipos en un torneo.
</p>

<p>
<b><b>Problema:</b></b> Dado un conjunto de equipos <b>[A, B, C]</b>, genera todas las
combinaciones posibles de enfrentamientos.
</p>

<p>
<b><b>Predicado:</b></b>  
<b>permutacion</b>
</p>
</div>
</div>

<div id="outline-container-org36ce183" class="outline-4">
<h4 id="org36ce183">9. Resolver problemas de caminos</h4>
<div class="outline-text-4" id="text-org36ce183">
<p>
Encuentra todas las rutas posibles entre dos nodos en un grafo utilizando `findall/3`.
</p>

<p>
<b><b>Problema:</b></b>  
Dado un grafo representado como:
</p>
<ul class="org-ul">
<li>arco(a, b).</li>
<li>arco(b, c).</li>
<li>arco(c, d).</li>
<li>arco(a, d).</li>
</ul>

<p>
Encuentra todas las rutas de <b>a</b> a <b>d</b>.
</p>

<p>
<b><b>Predicados:</b></b>  
<b>findall</b>, predicado recursivo para buscar caminos.
</p>
</div>
</div>

<div id="outline-container-org1d501ed" class="outline-4">
<h4 id="org1d501ed">10. Generar combinaciones con repetición</h4>
<div class="outline-text-4" id="text-org1d501ed">
<p>
Usa <b>findall</b> para generar combinaciones posibles de elementos de una lista con repetición.
</p>

<p>
<b><b>Problema:</b></b>  
Dada la lista <b>[a, b]</b> y un tamaño 2, genera:
</p>
<ul class="org-ul">
<li>[a, a]</li>
<li>[a, b]</li>
<li>[b, a]</li>
<li>[b, b]</li>
</ul>

<p>
<b><b>Predicado:</b></b>  
<b>findall</b>.
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-orge55b451" class="outline-2">
<h2 id="orge55b451">Proyecto</h2>
<div class="outline-text-2" id="text-orge55b451">
<p>
ELIZA es uno de los primeros programas de inteligencia artificial,
desarrollado por Joseph Weizenbaum en el Instituto Tecnológico de
Massachusetts (MIT) en 1966. Su objetivo era simular una conversación
entre un ser humano y una computadora. ELIZA es particularmente
conocida por emular a un terapeuta Rogeriano, utilizando técnicas de
procesamiento de lenguaje natural muy básicas.
</p>

<p>
Funcionamiento: ELIZA utiliza patrones predefinidos para analizar y
generar respuestas. No "entiende" el significado de las palabras, sino
que simplemente las manipula con base en reglas definidas. Por
ejemplo, si alguien dice "Estoy triste", ELIZA podría responder "¿Por
qué estás triste?" mediante la detección de palabras clave y su
sustitución en plantillas de respuesta.
</p>

<p>
Importancia histórica: Aunque su capacidad era limitada, ELIZA
demostró el potencial de las interacciones humano-computadora. Su
desarrollo ayudó a abrir camino para futuras investigaciones en
procesamiento de lenguaje natural y chatbots modernos.
</p>

<p>
Limitaciones: ELIZA no tiene comprensión semántica ni memoria
contextual. Por lo tanto, sus respuestas pueden parecer desconectadas
en conversaciones más largas o complejas.
</p>
</div>


<div id="outline-container-orga048c4e" class="outline-3">
<h3 id="orga048c4e">Actividad</h3>
<div class="outline-text-3" id="text-orga048c4e">
<p>
Dado el texto anterior, utilizar los archivos de Dropbox eliza.pl y
eliza2.pl y extender la funcionalidad de <b>Eliza</b>, agregando lo visto en
clases además de añadir el árbol genealógico, el árbol de datos que
generaron con clisp adaptándolo a prolog y adaptar a modo pregunta los
siguientes problemas.
</p>


<p>
Problema de medicina: Investigadores y sus especialidades Cinco
médicos (Ana, Bruno, Carla, Diego y Elena) trabajan en cinco
especialidades médicas diferentes (cardiología, neurología, oncología,
pediatría y dermatología). Cada médico proviene de un hospital
diferente (General, Regional, Universitario, Privado y Militar),
prefiere un equipo médico (ecógrafo, resonancia, tomógrafo,
dermatoscopio y electrocardiógrafo) y tiene un interés de
investigación específico (genética, farmacología, inmunología,
bioética y microbiología).
</p>

<p>
Con las siguientes pistas, eliza debe  deducir la  especialidad médica, el hospital, el equipo favorito y el interés de investigación de cada médico:
</p>

<p>
Carla no trabaja en el Hospital General ni en el Privado, y no estudia neurología.
La persona que utiliza el electrocardiógrafo trabaja en cardiología en el Hospital Militar, pero no es Diego.
Bruno está interesado en farmacología, pero no trabaja en el Hospital Regional ni en el Militar.
La persona que utiliza el ecógrafo trabaja en pediatría y no es del Hospital Universitario ni del Militar.
El especialista en oncología trabaja en el Hospital General y utiliza un tomógrafo.
El médico interesado en inmunología usa el resonador magnético, pero no es Elena.
El médico del Hospital Regional se dedica a dermatología.
Elena está interesada en bioética y no utiliza el electrocardiógrafo.
Diego es el experto en microbiología.
El médico del Hospital Universitario utiliza un dermatoscopio.
Pregunta:
¿Cuál es la especialidad, el hospital, el equipo médico y el interés de investigación de cada médico
</p>


<p>
Generar los hechos necesarios para resolver el problema. 
</p>
</div>
</div>
</div>




<div id="outline-container-org4ca85ed" class="outline-2">
<h2 id="org4ca85ed">Examen final</h2>
<div class="outline-text-2" id="text-org4ca85ed">
</div>
<div id="outline-container-org45e0460" class="outline-3">
<h3 id="org45e0460">Problema 1: Los guardianes de los templos</h3>
<div class="outline-text-3" id="text-org45e0460">
<p>
Cuatro guardianes (Apolo, Hécate, Ares y Hermes) custodian templos
mitológicos asociados con diferentes elementos (fuego, agua, tierra y
aire). Sabemos que:
</p>
<ul class="org-ul">
<li>Apolo no cuida el templo de fuego ni el de tierra.</li>
<li>Hécate no cuida el templo de aire.</li>
<li>Ares no cuida el templo de agua ni de aire.</li>
<li>Hermes cuida el templo de fuego o de agua.</li>
</ul>
<p>
Pregunta: ¿Qué templo cuida cada guardián?
</p>
</div>
</div>
<div id="outline-container-org9bf5445" class="outline-3">
<h3 id="org9bf5445">Problemas 2: Las armas de los héroes Cuatro héroes mitológicos</h3>
<div class="outline-text-3" id="text-org9bf5445">
<p>
 Las armas de los héroes Cuatro héroes mitológicos (Aquiles, Perseo,
 Hércules y Teseo) poseen armas únicas (espada, lanza, arco y
 escudo). Sabemos que:
Aquiles no usa el escudo ni el arco.
Perseo no usa la espada.
Hércules no usa la lanza ni el escudo.
Teseo usa el arco o el escudo. Pregunta: ¿Qué arma pertenece a cada héroe?
</p>
</div>
</div>
<div id="outline-container-orgbdf0ccf" class="outline-3">
<h3 id="orgbdf0ccf">Problema 3: Las gemas de los titanes Cuatro titanes</h3>
<div class="outline-text-3" id="text-orgbdf0ccf">
<p>
(Cronos, Océano, Hiperión y Japeto) tienen cada uno una gema (zafiro,
rubí, esmeralda y diamante). Sabemos que:
Cronos no tiene el zafiro ni el diamante.
Océano no tiene el rubí.
Hiperión no tiene el zafiro ni el rubí.
Japeto tiene el diamante o la esmeralda. Pregunta: ¿Qué gema tiene cada titán?
</p>
</div>
</div>
</div>



<div id="outline-container-org1b435b3" class="outline-2">
<h2 id="org1b435b3">Respuestas Ejercicios</h2>
<div class="outline-text-2" id="text-org1b435b3">
</div>
<div id="outline-container-org9462ff3" class="outline-3">
<h3 id="org9462ff3">Problema 1: Los guardianes de los templos</h3>
<div class="outline-text-3" id="text-org9462ff3">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #b22222;">% </span><span style="color: #b22222;">Guardianes y sus templos</span>
<span style="color: #0000ff;">templo</span><span style="color: #707183;">(</span>aire<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">templo</span><span style="color: #707183;">(</span>tierra<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">templo</span><span style="color: #707183;">(</span>fuego<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">templo</span><span style="color: #707183;">(</span>agua<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">guardian</span><span style="color: #707183;">(</span>apolo<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">guardian</span><span style="color: #707183;">(</span>hecate<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">guardian</span><span style="color: #707183;">(</span>ares<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">guardian</span><span style="color: #707183;">(</span>hermes<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">templocuida</span><span style="color: #707183;">(</span>apolo, aire<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">templocuida</span><span style="color: #707183;">(</span>hecate, tierra<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">templocuida</span><span style="color: #707183;">(</span>ares, fuego<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">templocuida</span><span style="color: #707183;">(</span>hermes, fuego, agua<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">no_cuida</span><span style="color: #707183;">(</span>apolo, fuego, tierra <span style="color: #707183;">)</span>.
<span style="color: #0000ff;">no_cuida</span><span style="color: #707183;">(</span>hecate, aire, <span style="color: #a0522d;">_</span> <span style="color: #707183;">)</span>.
<span style="color: #0000ff;">no_cuida</span><span style="color: #707183;">(</span>ares, agua, aire<span style="color: #707183;">)</span>

<span style="color: #b22222;">% </span><span style="color: #b22222;">Consulta:</span>
 ?- templocuida<span style="color: #707183;">(</span><span style="color: #a0522d;">Guardi</span>&#225;n, <span style="color: #a0522d;">Templo</span><span style="color: #707183;">)</span>.
    cuida<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">_</span><span style="color: #707183;">)</span>:-
</pre>
</div>
</div>

<div id="outline-container-org2a2d05f" class="outline-4">
<h4 id="org2a2d05f">Prueba de escritorio (Unificación paso a paso)</h4>
<div class="outline-text-4" id="text-org2a2d05f">
<ol class="org-ol">
<li>Prolog busca en la base de hechos:
<ul class="org-ul">
<li>templo(apolo, aire). → <b>Guardián = apolo</b>, <b>Templo = aire</b></li>
<li>templo(hecate, tierra). → <b>Guardián = hecate</b>, <b>Templo = tierra</b></li>
<li>templo(ares, fuego). → <b>Guardián = ares</b>, <b>Templo = fuego</b></li>
<li>templo(hermes, agua). → <b>Guardián = hermes</b>, <b>Templo = agua</b></li>
</ul></li>

<li><p>
Resultado en Prolog:
</p>
<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #a0522d;">Guardi</span>&#225;n = apolo, <span style="color: #a0522d;">Templo</span> = aire<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">Guardi</span>&#225;n = hecate, <span style="color: #a0522d;">Templo</span> = tierra<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">Guardi</span>&#225;n = ares, <span style="color: #a0522d;">Templo</span> = fuego<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">Guardi</span>&#225;n = hermes, <span style="color: #a0522d;">Templo</span> = agua.
</pre>
</div></li>
</ol>

<p>
&#x2014;
</p>
</div>
</div>
</div>

<div id="outline-container-orga1768dd" class="outline-3">
<h3 id="orga1768dd">Problema 2: Las armas de los héroes</h3>
<div class="outline-text-3" id="text-orga1768dd">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #b22222;">% </span><span style="color: #b22222;">H&#233;roes y sus armas</span>
<span style="color: #0000ff;">arma</span><span style="color: #707183;">(</span>aquiles, lanza<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">arma</span><span style="color: #707183;">(</span>perseo, escudo<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">arma</span><span style="color: #707183;">(</span>hercules, espada<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">arma</span><span style="color: #707183;">(</span>teseo, arco<span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Consulta:</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">?- arma(H&#233;roe, Arma).</span>
</pre>
</div>
</div>

<div id="outline-container-orgae624fa" class="outline-4">
<h4 id="orgae624fa">Prueba de escritorio (Unificación paso a paso)</h4>
<div class="outline-text-4" id="text-orgae624fa">
<ol class="org-ol">
<li>Prolog busca en la base de hechos:
<ul class="org-ul">
<li>arma(aquiles, lanza). → <b>Héroe = aquiles</b>, <b>Arma = lanza</b></li>
<li>arma(perseo, escudo). → <b>Héroe = perseo</b>, <b>Arma = escudo</b></li>
<li>arma(hercules, espada). → <b>Héroe = hercules</b>, <b>Arma = espada</b></li>
<li>arma(teseo, arco). → <b>Héroe = teseo</b>, <b>Arma = arco</b></li>
</ul></li>

<li><p>
Resultado en Prolog:
</p>
<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #a0522d;">H</span>&#233;roe = aquiles, <span style="color: #a0522d;">Arma</span> = lanza<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">H</span>&#233;roe = perseo, <span style="color: #a0522d;">Arma</span> = escudo<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">H</span>&#233;roe = hercules, <span style="color: #a0522d;">Arma</span> = espada<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">H</span>&#233;roe = teseo, <span style="color: #a0522d;">Arma</span> = arco.
</pre>
</div></li>
</ol>

<p>
&#x2014;
</p>
</div>
</div>
</div>

<div id="outline-container-orgc18b51d" class="outline-3">
<h3 id="orgc18b51d">Problema 3: Las gemas de los titanes</h3>
<div class="outline-text-3" id="text-orgc18b51d">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #b22222;">% </span><span style="color: #b22222;">Titanes y sus gemas</span>
<span style="color: #0000ff;">gema</span><span style="color: #707183;">(</span>cronos, rubi<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">gema</span><span style="color: #707183;">(</span>oceano, zafiro<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">gema</span><span style="color: #707183;">(</span>hiperion, esmeralda<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">gema</span><span style="color: #707183;">(</span>japeto, diamante<span style="color: #707183;">)</span>.

<span style="color: #b22222;">% </span><span style="color: #b22222;">Consulta:</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">?- gema(X Titan, Y  Gema).</span>
</pre>
</div>
</div>

<div id="outline-container-org9d91fd7" class="outline-4">
<h4 id="org9d91fd7">Prueba de escritorio (Unificación paso a paso)</h4>
<div class="outline-text-4" id="text-org9d91fd7">
<ol class="org-ol">
<li>Prolog busca en la base de hechos:
<ul class="org-ul">
<li>gema(cronos, rubi). → <b>Titán = cronos</b>, <b>Gema = rubi</b></li>
<li>gema(oceano, zafiro). → <b>Titán = oceano</b>, <b>Gema = zafiro</b></li>
<li>gema(hiperion, esmeralda). → <b>Titán = hiperion</b>, <b>Gema = esmeralda</b></li>
<li>gema(japeto, diamante). → <b>Titán = japeto</b>, <b>Gema = diamante</b></li>
</ul></li>

<li><p>
Resultado en Prolog:
</p>
<div class="org-src-container">
<pre class="src src-prolog">   <span style="color: #a0522d;">Tit</span>&#225;n = cronos, <span style="color: #a0522d;">Gema</span> = rubi<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">Tit</span>&#225;n = oceano, <span style="color: #a0522d;">Gema</span> = zafiro<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">Tit</span>&#225;n = hiperion, <span style="color: #a0522d;">Gema</span> = esmeralda<span style="color: #a020f0;">;</span>
   <span style="color: #a0522d;">Tit</span>&#225;n = japeto, <span style="color: #a0522d;">Gema</span> = diamante.
</pre>
</div></li>
</ol>
</div>
</div>



<div id="outline-container-org4834c28" class="outline-4">
<h4 id="org4834c28">Tabla resumen de la solución</h4>
<div class="outline-text-4" id="text-org4834c28">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Guardianes</th>
<th scope="col" class="org-left">Templo</th>
<th scope="col" class="org-left">Héroes</th>
<th scope="col" class="org-left">Arma</th>
<th scope="col" class="org-left">Titanes</th>
<th scope="col" class="org-left">Gema</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Apolo</td>
<td class="org-left">Aire</td>
<td class="org-left">Aquiles</td>
<td class="org-left">Lanza</td>
<td class="org-left">Cronos</td>
<td class="org-left">Rubí</td>
</tr>

<tr>
<td class="org-left">Hécate</td>
<td class="org-left">Tierra</td>
<td class="org-left">Perseo</td>
<td class="org-left">Escudo</td>
<td class="org-left">Océano</td>
<td class="org-left">Zafiro</td>
</tr>

<tr>
<td class="org-left">Ares</td>
<td class="org-left">Fuego</td>
<td class="org-left">Hércules</td>
<td class="org-left">Espada</td>
<td class="org-left">Hiperión</td>
<td class="org-left">Esmeralda</td>
</tr>

<tr>
<td class="org-left">Hermes</td>
<td class="org-left">Agua</td>
<td class="org-left">Teseo</td>
<td class="org-left">Arco</td>
<td class="org-left">Japeto</td>
<td class="org-left">Diamante</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>





<div id="outline-container-org6582199" class="outline-2">
<h2 id="org6582199">Ejercicios</h2>
</div>

<div id="outline-container-org2b97236" class="outline-2">
<h2 id="org2b97236">Ejercicios de Lisp: car, cdr y condicionales</h2>
<div class="outline-text-2" id="text-org2b97236">
<p>
Estos ejercicios están diseñados para practicar el uso de `car`, `cdr`
y condicionales en Common Lisp.
</p>
</div>

<div id="outline-container-orgb6d73af" class="outline-3">
<h3 id="orgb6d73af">Ejercicio 1: Primer elemento de una lista</h3>
<div class="outline-text-3" id="text-orgb6d73af">
<p>
Implementa una función que devuelva el primer elemento de una lista dada.
</p>
</div>
</div>


<div id="outline-container-org7cec33e" class="outline-3">
<h3 id="org7cec33e">Ejercicio 2: Segundo elemento de una lista</h3>
<div class="outline-text-3" id="text-org7cec33e">
<p>
Escribe una función que devuelva el segundo elemento de una lista.
</p>

<p>
#+END<sub>SRC</sub>
</p>
</div>
</div>

<div id="outline-container-org42f3b04" class="outline-3">
<h3 id="org42f3b04">Ejercicio 3: Último elemento de una lista</h3>
<div class="outline-text-3" id="text-org42f3b04">
<p>
Escribe una función que devuelva el último elemento de una lista.
</p>
</div>
</div>


<div id="outline-container-org0f67a6d" class="outline-3">
<h3 id="org0f67a6d">Ejercicio 4: Longitud de una lista</h3>
<div class="outline-text-3" id="text-org0f67a6d">
<p>
Implementa una función que calcule la cantidad de elementos en una lista.
</p>
</div>
</div>


<div id="outline-container-orgbbeef23" class="outline-3">
<h3 id="orgbbeef23">Ejercicio 5: Suma de una lista de números</h3>
<div class="outline-text-3" id="text-orgbbeef23">
<p>
Crea una función que sume todos los elementos de una lista de números.
</p>
</div>
</div>


<div id="outline-container-orgc0a2efb" class="outline-3">
<h3 id="orgc0a2efb">Ejercicio 6: Verificar si un elemento está en una lista</h3>
<div class="outline-text-3" id="text-orgc0a2efb">
<p>
Escribe una función que determine si un elemento está en una lista.
</p>
</div>
</div>

<div id="outline-container-org5595192" class="outline-3">
<h3 id="org5595192">Ejercicio 7: Invertir una lista</h3>
<div class="outline-text-3" id="text-org5595192">
<p>
Escribe una función para invertir el orden de los elementos de una lista.
</p>
</div>
</div>


<div id="outline-container-org1ead6b1" class="outline-3">
<h3 id="org1ead6b1">Ejercicio 8: Eliminar todas las ocurrencias de un elemento</h3>
<div class="outline-text-3" id="text-org1ead6b1">
<p>
Implementa una función que elimine todas las ocurrencias de un elemento en una lista.
</p>
</div>
</div>


<div id="outline-container-org886ea8c" class="outline-3">
<h3 id="org886ea8c">Ejercicio 9: Obtener el enésimo elemento de una lista</h3>
<div class="outline-text-3" id="text-org886ea8c">
<p>
Escribe una función que devuelva el elemento enésimo de una lista.
</p>
</div>
</div>


<div id="outline-container-org1f38de8" class="outline-3">
<h3 id="org1f38de8">Ejercicio 10: Concatenar dos listas</h3>
<div class="outline-text-3" id="text-org1f38de8">
<p>
Implementa una función que concatene dos listas.
</p>
</div>
</div>
</div>


<div id="outline-container-orga5b35cc" class="outline-2">
<h2 id="orga5b35cc">Eliza</h2>
<div class="outline-text-2" id="text-orga5b35cc">
</div>
<div id="outline-container-org13b3284" class="outline-3">
<h3 id="org13b3284">Introducción</h3>
<div class="outline-text-3" id="text-org13b3284">
<p>
Este apartado explica el funcionamiento del chatbot <b>Eliza</b> implementado
en Prolog. Eliza simula una conversación humana básica mediante
patrones de entrada y respuestas predefinidas.
</p>
</div>
</div>

<div id="outline-container-org747eb9d" class="outline-3">
<h3 id="org747eb9d">Estructura general del programa</h3>
<div class="outline-text-3" id="text-org747eb9d">
<p>
El programa está compuesto por:
</p>
<ol class="org-ol">
<li>Una interfaz de entrada principal.</li>
<li>Un conjunto de reglas para detectar cuándo terminar la
conversación.</li>
<li>Plantillas (templates) que definen cómo responder a ciertos
patrones de entrada.</li>
<li>Predicados auxiliares como <code>match/2</code>, <code>replace0/5</code>, y conocimiento del
mundo (gustos, acciones, familia, etc.).</li>
</ol>
</div>
</div>

<div id="outline-container-orgd5c2220" class="outline-3">
<h3 id="orgd5c2220">Predicado principal</h3>
<div class="outline-text-3" id="text-orgd5c2220">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">eliza</span> :-
    writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'Hola, mi nombre es Eliza tu chatbot,'</span><span style="color: #707183;">)</span>,
    writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'por favor ingresa tu consulta,'</span><span style="color: #707183;">)</span>,
    writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'usar solo min&#250;sculas sin . al final:'</span><span style="color: #707183;">)</span>,
    readln<span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>,
    eliza<span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.
</pre>
</div>

<p>
Este predicado inicia la interacción. Lee una línea de entrada como
lista y llama recursivamente a sí mismo con esa entrada.
</p>
</div>
</div>

<div id="outline-container-org0597738" class="outline-3">
<h3 id="org0597738">Casos base para terminar</h3>
<div class="outline-text-3" id="text-org0597738">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Input</span> == <span style="color: #707183;">[</span><span style="color: #8b2252;">'Adios'</span><span style="color: #707183;">]</span>, writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'Adios. espero poder verte ayudado.'</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Input</span> == <span style="color: #707183;">[</span><span style="color: #8b2252;">'adios'</span>, <span style="color: #8b2252;">'.'</span><span style="color: #707183;">]</span>, writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'Adios. espero poder verte ayudado.'</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Input</span> == <span style="color: #707183;">[</span><span style="color: #8b2252;">'Bye'</span>, <span style="color: #8b2252;">'.'</span><span style="color: #707183;">]</span>, writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'Bye bye .'</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Input</span> == <span style="color: #707183;">[</span><span style="color: #8b2252;">'bye'</span>, <span style="color: #8b2252;">'.'</span><span style="color: #707183;">]</span>, writeln<span style="color: #707183;">(</span><span style="color: #8b2252;">'Bye bye .'</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.
</pre>
</div>

<p>
Estas reglas manejan la salida del programa cuando el usuario quiere
terminar.
</p>
</div>
</div>

<div id="outline-container-orgd528a59" class="outline-3">
<h3 id="orgd528a59">Mecanismo de respuesta</h3>
<div class="outline-text-3" id="text-orgd528a59">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :-
    template<span style="color: #707183;">(</span><span style="color: #a0522d;">Stim</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">IndStim</span><span style="color: #707183;">)</span>,
    match<span style="color: #707183;">(</span><span style="color: #a0522d;">Stim</span>, <span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>,
    replace0<span style="color: #707183;">(</span><span style="color: #a0522d;">IndStim</span>, <span style="color: #a0522d;">Input</span>, 0, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>,
    writeln<span style="color: #707183;">(</span><span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>,
    readln<span style="color: #707183;">(</span><span style="color: #a0522d;">Input1</span><span style="color: #707183;">)</span>,
    eliza<span style="color: #707183;">(</span><span style="color: #a0522d;">Input1</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.
</pre>
</div>

<p>
Este es el núcleo del chatbot. Para cada entrada:
</p>
<ol class="org-ol">
<li>Se busca una plantilla que coincida con <code>Input</code>.</li>
<li>Se reemplazan partes de la entrada dentro de la respuesta.</li>
<li>Se imprime la respuesta y se lee la siguiente entrada.</li>
</ol>
</div>
</div>





<div id="outline-container-org7d97a79" class="outline-3">
<h3 id="org7d97a79">Plantillas de diálogo</h3>
<div class="outline-text-3" id="text-org7d97a79">
<p>
Cada plantilla tiene la forma:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #a0522d;">InputPattern</span>, <span style="color: #a0522d;">ResponsePattern</span>, <span style="color: #a0522d;">IndexList</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Donde:
</p>
<ul class="org-ul">
<li><code>InputPattern</code> es un patrón que debe hacer <b>match</b> con lo que el usuario escribe.</li>
<li><code>ResponsePattern</code> es la respuesta generada, con variables (números) a reemplazar.</li>
<li><code>IndexList</code> indica qué posiciones del input se insertarán en la respuesta.</li>
</ul>

<p>
Ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>hola, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, como, estas, soy, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, <span style="color: #8b2252;">'.'</span><span style="color: #7388d6;">]</span>,
         <span style="color: #7388d6;">[</span>hola , 1, <span style="color: #8b2252;">'como estas tu yo soy'</span>, 0 , <span style="color: #8b2252;">'como esta tu ?'</span><span style="color: #7388d6;">]</span>,
         <span style="color: #7388d6;">[</span>1, 5<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Significa:
</p>
<ul class="org-ul">
<li>Si el input tiene la forma “hola X como estas soy Y .”</li>
<li>La respuesta será: “hola Y como estas tu yo soy X como esta tu ?”</li>
</ul>
</div>
</div>

<div id="outline-container-orgfd50c02" class="outline-3">
<h3 id="orgfd50c02">Predicado <code>replace0/5</code></h3>
<div class="outline-text-3" id="text-orgfd50c02">
<p>
Este predicado reemplaza los valores numéricos en la respuesta por
palabras del input:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">I</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">Index</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>:-
    nth0<span style="color: #707183;">(</span><span style="color: #a0522d;">I</span>, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">Atom</span><span style="color: #707183;">)</span>,
    length<span style="color: #707183;">(</span><span style="color: #a0522d;">Index</span>, <span style="color: #a0522d;">M</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">M</span> &gt; 0,
    select<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">Atom</span>, <span style="color: #a0522d;">R1</span><span style="color: #707183;">)</span>,
    <span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> + 1,
    replace0<span style="color: #707183;">(</span><span style="color: #a0522d;">Index</span>, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">N1</span>, <span style="color: #a0522d;">R1</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>, <span style="color: #a020f0;">!</span>.

<span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">_</span>, <span style="color: #a0522d;">_</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">Resp</span><span style="color: #707183;">)</span>.
</pre>
</div>
</div>
</div>


<div id="outline-container-org3c0f673" class="outline-3">
<h3 id="org3c0f673">Parámetros</h3>
<div class="outline-text-3" id="text-org3c0f673">
<ul class="org-ul">
<li><code>[I|Index]</code>: Lista de índices que indican las posiciones en la entrada
de usuario cuyos valores deben insertarse en la respuesta.</li>
<li><code>Input</code>: Lista de palabras ingresadas por el usuario.</li>
<li><code>N</code>: Contador que se usa para reemplazar la variable correspondiente en la respuesta (<code>Resp</code>).</li>
<li><code>Resp</code>: Plantilla de respuesta con variables representadas como números (e.g., 0, 1).</li>
<li><code>R</code>: Resultado final de la respuesta, con las variables reemplazadas.</li>
</ul>
</div>
</div>

<div id="outline-container-org2527f46" class="outline-3">
<h3 id="org2527f46">Detalle de ejecución</h3>
<div class="outline-text-3" id="text-org2527f46">
<ol class="org-ol">
<li><code>nth0(I, Input, Atom)</code>  
Obtiene el elemento <code>Atom</code> de la lista <code>Input</code> en la posición <code>I</code>.</li>

<li><code>length(Index, M), M &gt; 0</code>  
Asegura que aún hay más índices por procesar.</li>

<li><code>select(N, Resp, Atom, R1)</code> Reemplaza la primera aparición de <code>N</code> en
<code>Resp</code> con <code>Atom</code>, devolviendo la nueva lista <code>R1</code>.</li>

<li><code>N1 is N + 1</code>  
Se incrementa el contador para reemplazar la siguiente variable.</li>

<li><code>replace0(Index, Input, N1, R1, R)</code>  
Llamada recursiva para continuar el proceso con los siguientes índices.</li>

<li><code>!</code>  
Corte lógico: impide backtracking.</li>
</ol>



<p>
<b><b>Ejemplo de uso:</b></b>
</p>

<p>
<b><b>Consulta:</b></b>
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #b22222;">% </span><span style="color: #b22222;">Input del usuario:</span>
<span style="color: #a0522d;">Input</span> = <span style="color: #707183;">[</span>hola, juan, soy, maria<span style="color: #707183;">]</span>,

<span style="color: #b22222;">% </span><span style="color: #b22222;">Plantilla de respuesta:</span>
<span style="color: #a0522d;">Resp</span> = <span style="color: #707183;">[</span>hola, 1, <span style="color: #8b2252;">'como estas'</span>, 0<span style="color: #707183;">]</span>,

<span style="color: #b22222;">% </span><span style="color: #b22222;">&#205;ndices donde extraer palabras del input:</span>
<span style="color: #a0522d;">Index</span> = <span style="color: #707183;">[</span>1, 3<span style="color: #707183;">]</span>,

<span style="color: #b22222;">% </span><span style="color: #b22222;">Llamamos al predicado:</span>
<span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Index</span>, <span style="color: #a0522d;">Input</span>, 0, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
<b><b>Resultado esperado:</b></b>
</p>

<pre class="example">
R = [hola, maria, 'como estas', juan]
</pre>



<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">Input</span> = <span style="color: #707183;">[</span>hola, juan, como, estas, soy, maria, <span style="color: #8b2252;">'.'</span><span style="color: #707183;">]</span>,
<span style="color: #a0522d;">Resp</span> = <span style="color: #707183;">[</span>hola , 1, <span style="color: #8b2252;">'como estas tu yo soy'</span>, 0 , <span style="color: #8b2252;">'como esta tu ?'</span><span style="color: #707183;">]</span>,
<span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 5<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Input</span>, 0, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #b22222;">% </span><span style="color: #b22222;">Resultado:</span>
<span style="color: #b22222;">% </span><span style="color: #b22222;">R = [hola, maria, 'como estas tu yo soy', juan, 'como esta tu ?']</span>
</pre>
</div>
</div>
</div>



<div id="outline-container-orgf0b2148" class="outline-3">
<h3 id="orgf0b2148">Corrida completa del código replace0/5</h3>
<div class="outline-text-3" id="text-orgf0b2148">
</div>
<div id="outline-container-org7063d99" class="outline-4">
<h4 id="org7063d99">Llamada inicial</h4>
<div class="outline-text-4" id="text-org7063d99">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>2<span style="color: #7388d6;">]</span>,
         <span style="color: #7388d6;">[</span>hola, soy, juan, y, estudio<span style="color: #7388d6;">]</span>,
         0,
         <span style="color: #7388d6;">[</span>hola, 1, yo, soy, eliza<span style="color: #7388d6;">]</span>,
         <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfc3ee10" class="outline-3">
<h3 id="orgfc3ee10">Análisis del patrón</h3>
<div class="outline-text-3" id="text-orgfc3ee10">
<ul class="org-ul">
<li>Index = [2]</li>
<li>Hay más de un índice → M &gt; 0</li>
<li>Por lo tanto, <b><b>se utiliza la cláusula recursiva completa</b></b>, que incluye:</li>
</ul>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> + 1
</pre>
</div>
</div>
</div>

<div id="outline-container-org640bad3" class="outline-3">
<h3 id="org640bad3">Paso 1 — Sustitución del índice 1</h3>
<div class="outline-text-3" id="text-org640bad3">
<ul class="org-ul">
<li>I = 2</li>
<li>nth0(2, Input, Atom) → Atom = juan</li>
<li>N = 0  (placeholder que toca reemplazar)</li>
<li>Resp actual = [hola, 1, yo, soy, eliza]</li>
</ul>

<p>
Se ejecuta:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">select</span><span style="color: #707183;">(</span>0, <span style="color: #7388d6;">[</span>hola, 1, yo, soy, 0<span style="color: #7388d6;">]</span>, soy, <span style="color: #a0522d;">R1</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Sustituyendo el placeholder <b><b>0</b></b> por <b><b>soy</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">R1</span> = <span style="color: #707183;">[</span>hola, 1, yo, soy, soy<span style="color: #707183;">]</span>
</pre>
</div>

<p>
Ahora viene el incremento:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> + 1   &#8594;   <span style="color: #a0522d;">N1</span> = 1
</pre>
</div>
</div>
</div>

<div id="outline-container-org53af7a0" class="outline-3">
<h3 id="org53af7a0">Llamada recursiva con el nuevo N1</h3>
<div class="outline-text-3" id="text-org53af7a0">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>4<span style="color: #7388d6;">]</span>,
         <span style="color: #7388d6;">[</span>hola, soy, juan, y, estudio<span style="color: #7388d6;">]</span>,
         1,
         <span style="color: #7388d6;">[</span>hola, 1, yo, soy, soy<span style="color: #7388d6;">]</span>,
         <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>
</div>
</div>


<div id="outline-container-org83550b8" class="outline-3">
<h3 id="org83550b8">Paso 2 — Último índice</h3>
<div class="outline-text-3" id="text-org83550b8">
<p>
Ahora:
</p>

<ul class="org-ul">
<li>Index = [4]</li>
<li>length([4], M) → M = 0  
→ Esto significa que <b><b>ya no se usa</b></b>:</li>
</ul>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">N1</span> is <span style="color: #a0522d;">N</span> + 1
</pre>
</div>
</div>

<div id="outline-container-orgc09b8a4" class="outline-4">
<h4 id="orgc09b8a4">Esta llamada usa la cláusula “final” (no recursiva)**.</h4>
<div class="outline-text-4" id="text-orgc09b8a4">
<ul class="org-ul">
<li>I = 4</li>
<li>nth0(4, Input, Atom) → Atom = estudio</li>
<li>N = 1</li>
<li>Resp actual = [hola, 1, yo, soy, soy]</li>
</ul>

<p>
Se ejecuta:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">select</span><span style="color: #707183;">(</span>1, <span style="color: #7388d6;">[</span>hola, juan, yo, soy, eliza<span style="color: #7388d6;">]</span>, estudio, <span style="color: #a0522d;">R1</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Reemplazando el placeholder <b><b>1</b></b>:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span>hola, juan, yo, soy, eliza<span style="color: #707183;">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge815b30" class="outline-4">
<h4 id="orge815b30">Resultado final:</h4>
<div class="outline-text-4" id="text-orge815b30">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span>hola, juan, yo, soy, eliza<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</div>



<div id="outline-container-org2911b43" class="outline-4">
<h4 id="org2911b43">Árbol de derivación completo con momentos exactos de N + 1</h4>
<div class="outline-text-4" id="text-org2911b43">
<pre class="example" id="orgbe06279">
                                   replace0([2], Input, 0, Resp, R)
          input      hola, soy, juan, y, estudio   |
                                                   |
                           ------------------------------------   
                           |                                               |
                I=1 → Atom = juan                                  replace0([4], Input, 1, R1, R)
                Placeholder 0                                      (Aquí Index = [], M = 0)
                Se reemplaza →                                    → NO se ejecuta N1 is N + 1
                R1 = [hola, 1, yo, soy, eliza]                       |
                                                                   
                     *** Aquí se ejecuta N1 is N + 1 ***  ________ |
                     N1 = 1                                        |
                                                                   v
                                                   R = [hola, juan, yo, soy, eliza]
</pre>
</div>
</div>



<div id="outline-container-org4525169" class="outline-4">
<h4 id="org4525169">Resumen claro</h4>
<div class="outline-text-4" id="text-org4525169">
<ul class="org-ul">
<li>Se usa <b><b>N1 is N + 1</b></b> cuando:
<ul class="org-ul">
<li>hay más índices por procesar (M &gt; 0)</li>
<li>estás en el caso recursivo</li>
</ul></li>

<li>NO se usa cuando:
<ul class="org-ul">
<li>es el último índice (M = 0)</li>
</ul></li>
</ul>
</div>
</div>



<div id="outline-container-orgf6486a3" class="outline-4">
<h4 id="orgf6486a3">Resultado final del proceso</h4>
<div class="outline-text-4" id="text-orgf6486a3">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span>hola, estudio, yo, soy, soy<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</div>
</div>




<div id="outline-container-org3b959fe" class="outline-3">
<h3 id="org3b959fe">Conocimiento del mundo</h3>
<div class="outline-text-3" id="text-org3b959fe">
<p>
<b><b>Familia:</b></b>
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>juan, pedro<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>pedro, luis<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>, padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #a0522d;">X</span>, <span style="color: #8b2252;">'si es abuelo de'</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">]</span>.
<span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- \+padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #a0522d;">X</span>, <span style="color: #8b2252;">'no es abuelo de'</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">]</span>.
</pre>
</div>

<p>
<b><b>Gustos:</b></b>
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>apples<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>ponies<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>zombies<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>manzanas<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>computadoras<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>carros<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">likes</span><span style="color: #707183;">(</span>fiestas<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">elizaLikes</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- likes<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #8b2252;">'Yeah'</span>, i, like, <span style="color: #a0522d;">X</span><span style="color: #707183;">]</span>.
<span style="color: #0000ff;">elizaLikes</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- \+likes<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #8b2252;">'Nope'</span>, i, do, not, like, <span style="color: #a0522d;">X</span><span style="color: #707183;">]</span>.
</pre>
</div>

<p>
<b><b>Acciones:</b></b>
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">does</span><span style="color: #707183;">(</span>study<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">does</span><span style="color: #707183;">(</span>cook<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">does</span><span style="color: #707183;">(</span>work<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">elizaDoes</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- does<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #8b2252;">'Yes'</span>, i, <span style="color: #a0522d;">X</span>, and, i, love, it<span style="color: #707183;">]</span>.
<span style="color: #0000ff;">elizaDoes</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- \+does<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #8b2252;">'No'</span>, i, do, not, <span style="color: #a0522d;">X</span> ,<span style="color: #8b2252;">'.'</span>, it, is, too, hard, for, me<span style="color: #707183;">]</span>.
</pre>
</div>

<p>
<b><b>Identidad:</b></b>
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">eres</span><span style="color: #707183;">(</span>chatbot<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">eres</span><span style="color: #707183;">(</span>maquina<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">elizaEres</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- eres<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #8b2252;">'Yes'</span>, i, <span style="color: #a0522d;">X</span>, and, i, love, it<span style="color: #707183;">]</span>.
<span style="color: #0000ff;">elizaEres</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- \+eres<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span><span style="color: #8b2252;">'No'</span>, i, am, not, <span style="color: #a0522d;">X</span><span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</div>

<div id="outline-container-org5a4276f" class="outline-3">
<h3 id="org5a4276f">Plantillas especiales con <b>flags</b></h3>
<div class="outline-text-3" id="text-org5a4276f">
<p>
Las plantillas con respuestas <code>flagLike</code>, <code>flagDo</code>, <code>flagEres</code>, <code>flagfam</code>,
etc., delegan la respuesta a otro predicado.
</p>

<p>
Ejemplo:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>te, gustan, las, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, <span style="color: #a0522d;">_</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>flagLike<span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>3<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Esto activa el predicado <code>elizaLikes/2</code> que genera la respuesta según si
Eliza "gusta" de esa cosa.
</p>
</div>
</div>

<div id="outline-container-org5572d7c" class="outline-3">
<h3 id="org5572d7c">Respuestas genéricas</h3>
<div class="outline-text-3" id="text-org5572d7c">
<p>
Cuando no hay coincidencia con ninguna plantilla, Eliza responde con
una frase por defecto:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #a0522d;">_</span>, <span style="color: #7388d6;">[</span><span style="color: #8b2252;">'Please'</span>, explain, a, little, more, <span style="color: #8b2252;">'.'</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[]</span><span style="color: #707183;">)</span>.
</pre>
</div>
</div>
</div>


<div id="outline-container-orgdea1552" class="outline-3">
<h3 id="orgdea1552">Plantilla involucrada</h3>
<div class="outline-text-3" id="text-orgdea1552">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>eliza, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, es, abuelo, de, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, <span style="color: #8b2252;">'?'</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>flagfam<span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span>1,5<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Esta plantilla significa que, si la entrada del usuario se parece a:
</p>

<pre class="example" id="org9958d4c">
eliza juan es abuelo de pedro ?
</pre>

<p>
Entonces:
</p>

<ul class="org-ul">
<li>Input = [eliza, juan, es, abuelo, de, pedro, '?']</li>
<li>Stim = [eliza, s(<span class="underline">), es, abuelo, de, s(</span>), '?']</li>
<li>Resp = [flagfam]</li>
<li>IndStim = [1, 5] ; capturamos las posiciones 1 (juan) y 5 (pedro)</li>
</ul>
</div>
</div>

<div id="outline-container-orgcdc2426" class="outline-3">
<h3 id="orgcdc2426">¿Qué sucede en el código?</h3>
<div class="outline-text-3" id="text-orgcdc2426">
<p>
Cuando se detecta `Resp = [flagfam]`, y ya se han capturado las variables, se hace esto:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1, 5<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Input</span>, 0, <span style="color: #7388d6;">[</span>flagfam<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto significa:
</p>

<ul class="org-ul">
<li>nth0(1, Input, X) → X = juan</li>
<li>nth0(5, Input, Y) → Y = pedro</li>
</ul>

<p>
Como `Resp = [flagfam]`, se entra a la cláusula especial:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #a0522d;">_</span>, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">_</span>, <span style="color: #7388d6;">[</span>flagfam<span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>:-
    nth0<span style="color: #707183;">(</span>1, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>,
    nth0<span style="color: #707183;">(</span>5, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>,
    elizafam<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #a0522d;">Y</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
Entonces se ejecuta:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span>juan, pedro, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgda060a7" class="outline-3">
<h3 id="orgda060a7">Base de conocimiento familiar</h3>
<div class="outline-text-3" id="text-orgda060a7">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>juan, pedro<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>pedro, luis<span style="color: #707183;">)</span>.

<span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span>,<span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>:- padre<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Z</span><span style="color: #707183;">)</span>, padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span>=<span style="color: #707183;">[</span><span style="color: #a0522d;">X</span>, <span style="color: #8b2252;">'si es abuelo de'</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">]</span>.       
<span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>,<span style="color: #a0522d;">Y</span>,<span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>:- \+padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>, padre<span style="color: #707183;">(</span><span style="color: #a0522d;">Z</span>,<span style="color: #a0522d;">Y</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">R</span>=<span style="color: #707183;">[</span><span style="color: #a0522d;">X</span>, <span style="color: #8b2252;">'no es abuelo de'</span>, <span style="color: #a0522d;">Y</span><span style="color: #707183;">]</span>.         
</pre>
</div>
</div>
</div>

<div id="outline-container-org81c84f4" class="outline-3">
<h3 id="org81c84f4">Ejemplo válido</h3>
<div class="outline-text-3" id="text-org81c84f4">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span>juan, luis, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>
&#8594; <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span>juan, <span style="color: #8b2252;">'si es abuelo de'</span>, luis<span style="color: #707183;">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org1b11a72" class="outline-3">
<h3 id="org1b11a72">Ejemplo que no cumple</h3>
<div class="outline-text-3" id="text-org1b11a72">
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">elizafam</span><span style="color: #707183;">(</span>juan, pedro, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>
&#8594; <span style="color: #a0522d;">No</span> cumple la primera regla
&#8594; <span style="color: #a0522d;">Entra</span> en la segunda
&#8594; <span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span>juan, <span style="color: #8b2252;">'no es abuelo de'</span>, pedro<span style="color: #707183;">]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga1cd99e" class="outline-3">
<h3 id="orga1cd99e">Ejemplo completo</h3>
<div class="outline-text-3" id="text-orga1cd99e">
</div>
<div id="outline-container-org9c827b3" class="outline-4">
<h4 id="org9c827b3">Entrada del usuario:</h4>
<div class="outline-text-4" id="text-org9c827b3">
<pre class="example" id="org572f006">
eliza juan es abuelo de pedro ?
</pre>
</div>
</div>

<div id="outline-container-orgb803cca" class="outline-4">
<h4 id="orgb803cca">Flujo del programa:</h4>
<div class="outline-text-4" id="text-orgb803cca">
<ul class="org-ul">
<li>Se hace match con Stim</li>
<li>Se detecta `flagfam`</li>
<li>Se extraen `juan` y `pedro` (posiciones 1 y 5)</li>
<li>Se llama a `elizafam(juan, pedro, R)`</li>
<li><p>
Se genera la respuesta:
</p>
<pre class="example" id="orgaca25ee">
  juan no es abuelo de pedro
</pre></li>
</ul>
</div>
</div>
</div>
</div>








<div id="outline-container-org7d54c66" class="outline-2">
<h2 id="org7d54c66">Ejercicios prolog</h2>
<div class="outline-text-2" id="text-org7d54c66">
<p>
Acertijo de los Científicos y sus Laboratorios Cinco científicos
trabajan en un centro de investigación. Cada uno tiene un laboratorio
en un color diferente y se especializa en una rama distinta de la
ciencia. Además, cada científico usa un tipo diferente de equipo y
prefiere una bebida específica mientras trabaja.
</p>

<p>
colores(rojo).
colores(azul).
colores(verde).
colores(negro).
colores(blanco).
colores(amarillo).
colores(naraja).
especialidades(biologia).
especialidades(fisica).
especialidades(quimica).
especialidades(matematicas).
especialidades(biologia).
especialidades(computación).
equipo(espectrómetro).
equipo(microscopio).
equipo(centrifuga).
equipo(osciloscopio).
equipo(computadora).
equipo(pipeta).
equipo(balanza).
bebida(te).
bebida(agua).
bebida(cafe).
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">especialidad</th>
<th scope="col" class="org-left">color laboratorio</th>
<th scope="col" class="org-left">bebida</th>
<th scope="col" class="org-left">equipo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">cientifico</td>
<td class="org-left">biologia</td>
<td class="org-left">rojo</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">cientifico2</td>
<td class="org-left">fisica</td>
<td class="org-left">azul</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">cientifico3</td>
<td class="org-left">quimico</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">espectrofotometro, microscopio</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">cientifico4</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">verde</td>
<td class="org-left">te</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">cientifico5</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>




<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Lab3</th>
<th scope="col" class="org-left">Lab1</th>
<th scope="col" class="org-left">Lab2</th>
<th scope="col" class="org-left">Lab4</th>
<th scope="col" class="org-left">Lab5</th>
<th scope="col" class="org-left">Lab6</th>
<th scope="col" class="org-left">Lab7</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bebida</td>
<td class="org-left">agua</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">cafe</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">te</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">color</td>
<td class="org-left">negro</td>
<td class="org-left">rojo</td>
<td class="org-left">azul</td>
<td class="org-left">naranja</td>
<td class="org-left">blanco</td>
<td class="org-left">verde</td>
<td class="org-left">amarillo</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">esp</td>
<td class="org-left">químico</td>
<td class="org-left">biologia</td>
<td class="org-left">físico</td>
<td class="org-left">matemática</td>
<td class="org-left">computacion</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">herr</td>
<td class="org-left">microscopio, espec</td>
<td class="org-left">pipeta balanza</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">laptop</td>
<td class="org-left">osciloscopio</td>
<td class="org-left">centrifuga</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>





<p>
Pistas
</p>
<ul class="org-ul">
<li>El científico en el laboratorio rojo investiga en Biología.</li>
<li>El físico trabaja en el laboratorio azul.</li>
<li>El químico usa un microscopio.</li>
<li>La persona en el laboratorio verde toma té.</li>
<li>El laboratorio verde está a la derecha del laboratorio blanco.</li>
<li>El científico que usa un espectrofotómetro investiga en Química.</li>
<li>El investigador del laboratorio amarillo usa una centrífuga.</li>
<li>El científico en el laboratorio del centro toma café.</li>
<li>El investigador del laboratorio naranja trabaja en Matemáticas.</li>
<li>El científico en el primer laboratorio usa un microscopio.</li>
<li>El científico que usa una pipeta trabaja junto al que investiga en Física.</li>
<li>El científico que usa una balanza trabaja junto al que usa un espectrofotómetro.</li>
<li>El investigador que trabaja en Ciencias de la Computación usa una laptop.</li>
<li>Uno de los científicos usa un osciloscopio.</li>
<li>El científico en el laboratorio negro bebe agua.</li>

<li>Preguntas a responder con Prolog</li>
<li>¿En qué laboratorio trabaja el científico de Química?</li>
<li>¿Quién usa la pipeta?</li>
<li>¿Cuál es la bebida preferida del científico que investiga en Matemáticas?</li>
</ul>
</div>
</div>

<div id="outline-container-org61b9f19" class="outline-2">
<h2 id="org61b9f19">Respuestas</h2>
<div class="outline-text-2" id="text-org61b9f19">
<p>
% Definimos los colores de los laboratorios
color(rojo).
color(azul).
color(verde).
color(blanco).
color(amarillo).
color(naranja).
color(negro).
</p>

<p>
% Especialidades científicas
especialidad(biologia).
especialidad(fisica).
especialidad(quimica).
especialidad(matematicas).
especialidad(computacion).
</p>

<p>
% Equipos usados en los laboratorios
equipo(microscopio).
equipo(espectrofotometro).
equipo(centrifuga).
equipo(pipeta).
equipo(balanza).
equipo(laptop).
equipo(osciloscopio).
</p>

<p>
% Bebidas preferidas
bebida(te).
bebida(cafe).
bebida(agua).
</p>

<p>
% Relación entre colores, especialidades, equipos y bebidas
hecho(laboratorio(rojo, biologia, _ , _)).
hecho(laboratorio(azul, fisica, <span class="underline">,  _)).
hecho(laboratorio( _</span>, quimica, microscopio, _)).
hecho(laboratorio(verde, <span class="underline">, _, te)).
hecho(laboratorio(</span>, quimica, espectrofotometro, _)).
hecho(laboratorio(amarillo, <span class="underline">, centrifuga, _)).
hecho(laboratorio(</span>, matematicas, <span class="underline">, _)).
hecho(laboratorio(</span>, computacion, laptop, <span class="underline">)).
hecho(laboratorio(</span>, _, osciloscopio, _)).
hecho(laboratorio(negro, _, _, agua)).
</p>

<p>
% Definir que un laboratorio está a la derecha de otro en la lista
derecha(X, Y, [Y, X | <span class="underline">]).
derecha(X, Y, [</span> | Resto]) :- derecha(X, Y, Resto).
</p>

<p>
% Definir que un laboratorio está junto a otro (a la izquierda o derecha)
junto<sub>a</sub>(X, Y, Lista) :- derecha(X, Y, Lista).
junto<sub>a</sub>(X, Y, Lista) :- derecha(Y, X, Lista).
</p>

<p>
% Definir que un laboratorio está en el centro de la lista
centro(X, [_, _, X, _, _]).
</p>

<p>
% Definir que un laboratorio está en la primera posición
primero(X, [X | _]).
</p>

<p>
% Definir la solución organizando los laboratorios
solucion(Labs) :-
    Labs = [
        laboratorio(A, B, C, D),
        laboratorio(E, F, G, H),
        laboratorio(I, J, K, L),
        laboratorio(M, N, O, P),
        laboratorio(Q, R, S, T)
    ],
</p>

<p>
% Aplicamos los hechos
hecho(laboratorio(rojo, biologia, _, _)), member(laboratorio(rojo, biologia, _, _), Labs),
hecho(laboratorio(azul, fisica, <span class="underline">, _)), member(laboratorio(azul, fisica, _, _), Labs),
hecho(laboratorio(</span>, quimica, microscopio, <span class="underline">)), member(laboratorio(</span>, quimica, microscopio, _), Labs),
hecho(laboratorio(verde, <span class="underline">, _, te)), member(laboratorio(verde, _, _, te), Labs),
hecho(laboratorio(</span>, quimica, espectrofotometro, <span class="underline">)), member(laboratorio(</span>, quimica, espectrofotometro, _), Labs),
hecho(laboratorio(amarillo, <span class="underline">, centrifuga, _)), member(laboratorio(amarillo, _, centrifuga, _), Labs),
hecho(laboratorio(</span>, matematicas, <span class="underline">, _)), member(laboratorio(</span>, matematicas, <span class="underline">, _), Labs),
hecho(laboratorio(</span>, computacion, laptop, <span class="underline">)), member(laboratorio(</span>, computacion, laptop, <span class="underline">), Labs),
hecho(laboratorio(</span>, <span class="underline">, osciloscopio, _)), member(laboratorio(</span>, _, osciloscopio, _), Labs),
hecho(laboratorio(negro, _, _, agua)), member(laboratorio(negro, _, _, agua), Labs),
</p>

<p>
% Aplicamos restricciones espaciales
derecha(laboratorio(verde, <span class="underline">, _, _), laboratorio(blanco, _, _, _), Labs),
centro(laboratorio(</span>, <span class="underline">, _, cafe), Labs),
primero(laboratorio(</span>, <span class="underline">, microscopio, _), Labs),
junto<sub>a</sub>(laboratorio(</span>, <span class="underline">, pipeta, _), laboratorio(</span>, fisica, <span class="underline">, _), Labs),
junto<sub>a</sub>(laboratorio(</span>, <span class="underline">, balanza, _), laboratorio(</span>, _, espectrofotometro, _), Labs).
</p>
</div>
</div>



<div id="outline-container-org422c46e" class="outline-2">
<h2 id="org422c46e">Logica</h2>
</div>
<div id="outline-container-org3d27b33" class="outline-2">
<h2 id="org3d27b33">Acertijo de los Laboratorios</h2>
<div class="outline-text-2" id="text-org3d27b33">
<p>
El apartado detalla el razonamiento paso a paso para resolver el
acertijo de los laboratorios en base a reglas de inferencia y
eliminación.
</p>
</div>

<div id="outline-container-orge85436f" class="outline-3">
<h3 id="orge85436f">Paso 1: Información Inicial</h3>
<div class="outline-text-3" id="text-orge85436f">
<p>
Sabemos las siguientes reglas:
</p>

<ol class="org-ol">
<li>El laboratorio rojo es de biología → <code>Rojo = Biología</code></li>
<li>El laboratorio azul es de física → <code>Azul = Física</code></li>
<li>El laboratorio verde toma té → <code>Verde = Té</code></li>
<li>El laboratorio verde está a la derecha del laboratorio blanco → <code>Blanco ⬅️ Verde</code></li>
<li>El laboratorio amarillo usa una centrífuga → <code>Amarillo = Centrífuga</code></li>
<li>El laboratorio en el centro toma café → <code>Centro (posición 3 o 4) = Café</code></li>
<li>El laboratorio negro toma agua → <code>Negro = Agua</code></li>
</ol>

<p>
Organizamos los datos en una tabla inicial:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Posición</th>
<th scope="col" class="org-left">Color</th>
<th scope="col" class="org-left">Información Inicial</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">?</td>
<td class="org-left">Primer laboratorio usa microscopio</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Azul</td>
<td class="org-left">Física</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Rojo</td>
<td class="org-left">Biología, toma café</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">Verde</td>
<td class="org-left">Toma té</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Blanco</td>
<td class="org-left">Está a la izquierda del verde</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Negro</td>
<td class="org-left">Toma agua</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">?</td>
<td class="org-left">Último color disponible</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org154711f" class="outline-3">
<h3 id="org154711f">Paso 2: Determinar los colores faltantes</h3>
<div class="outline-text-3" id="text-org154711f">
<p>
Faltan dos colores: <code>Amarillo</code> y <code>Naranja</code>.
</p>

<ul class="org-ul">
<li>Como sabemos que <code>Amarillo usa una centrífuga</code>, y que <code>la posición 1
  usa microscopio</code>, <code>Amarillo no puede estar en la posición 1</code>.</li>
<li>Por lo tanto, <code>Amarillo debe estar en la posición 7</code>.</li>
<li>Finalmente, el último color disponible para la posición 1 es <code>Naranja</code>.</li>
</ul>

<p>
Esto nos da la siguiente tabla completa de colores:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Posición</th>
<th scope="col" class="org-left">Color</th>
<th scope="col" class="org-left">Información Confirmada</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">Naranja</td>
<td class="org-left">Microscopio</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Azul</td>
<td class="org-left">Física</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Rojo</td>
<td class="org-left">Biología, Café</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">Verde</td>
<td class="org-left">Té</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Blanco</td>
<td class="org-left">Centrífuga</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Negro</td>
<td class="org-left">Agua</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Amarillo</td>
<td class="org-left">Última opción</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-org50a0ebe" class="outline-3">
<h3 id="org50a0ebe">Paso 3: Confirmación de Reglas</h3>
<div class="outline-text-3" id="text-org50a0ebe">
<p>
Verificamos si las reglas se cumplen:
</p>

<ol class="org-ol">
<li>El laboratorio verde está a la derecha del blanco  (Blanco en posición 5, Verde en posición 4)</li>
<li>El laboratorio amarillo usa una centrífuga  (Amarillo = Posición 7, ya asignado)</li>
<li>El laboratorio negro toma agua  (Negro = Posición 6, agua ya asignada)</li>
</ol>

<p>
Como todas las reglas son correctas, la solución final es:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Posición</th>
<th scope="col" class="org-left">Color</th>
<th scope="col" class="org-left">Especialidad</th>
<th scope="col" class="org-left">Equipo</th>
<th scope="col" class="org-left">Bebida</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-left">Naranja</td>
<td class="org-left">Computación</td>
<td class="org-left">Microscopio</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">Azul</td>
<td class="org-left">Física</td>
<td class="org-left">Pipeta</td>
<td class="org-left">?</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">Rojo</td>
<td class="org-left">Biología</td>
<td class="org-left">Balanza</td>
<td class="org-left">Café</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">Verde</td>
<td class="org-left">Química</td>
<td class="org-left">Espectrofotómetro</td>
<td class="org-left">Té</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">Blanco</td>
<td class="org-left">Ingeniería</td>
<td class="org-left">Centrífuga</td>
<td class="org-left">Jugo</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">Negro</td>
<td class="org-left">Astronomía</td>
<td class="org-left">Osciloscopio</td>
<td class="org-left">Agua</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">Amarillo</td>
<td class="org-left">Matemáticas</td>
<td class="org-left">Laptop</td>
<td class="org-left">?</td>
</tr>
</tbody>
</table>



<p>
Puedes hacer mediante la unificación la corrida del factorial en prolog  ? 
</p>
</div>
</div>
</div>








<div id="outline-container-org3073530" class="outline-2">
<h2 id="org3073530">Examen</h2>
<div class="outline-text-2" id="text-org3073530">
<ol class="org-ol">
<li>¿Qué es la unificación en Prolog y cómo se diferencia de la
asignación en otros lenguajes de programación?</li>
</ol>


<ol class="org-ol">
<li>Explica el concepto de backtracking en Prolog y cómo afecta la
búsqueda de soluciones.</li>

<li>Describe la diferencia entre un hecho, una regla y una consulta en
Prolog, proporcionando un ejemplo de cada uno.</li>

<li>¿Cuál es el propósito del predicado cut (!), y cómo afecta el flujo
de ejecución de un programa en Prolog?</li>

<li>¿Qué representa el término "_" (guion bajo) en Prolog? ¿En qué
situaciones es útil?</li>

<li>Explica cómo funcionan las listas en Prolog. ¿Cómo se define una
lista y cómo se accede a su cabeza y cola?</li>

<li>Describe la diferencia entre los predicados is/2, <code>, y =</code> en
Prolog. ¿Cuándo se usa cada uno?</li>

<li>¿Cómo puedes implementar recursión en Prolog para sumar los
elementos de una lista?</li>

<li>¿Qué papel juega el orden de las cláusulas en Prolog? ¿Puede
influir en el resultado de una consulta?</li>

<li>¿Cómo puedes representar relaciones familiares (padre, abuelo,
hermano) en Prolog usando hechos y reglas?</li>
</ol>
</div>
</div>


<div id="outline-container-orge8e8530" class="outline-2">
<h2 id="orge8e8530">Examen Prolog — Respuestas</h2>
<div class="outline-text-2" id="text-orge8e8530">
<p>
&#x2014;
</p>

<p>
<b>1. ¿Cuál de los siguientes términos es un átomo válido en Prolog?</b>
A) MiVariable   B) mi<sub>constante</sub><sub>1</sub>   C) _OtraCosa   D) 123<sub>numero</sub>
</p>

<p>
<b><b>Respuesta correcta:</b></b> B) mi<sub>constante</sub><sub>1</sub>
</p>


<p>
Un átomo es un nombre en minúsculas, o una cadena entre comillas.  
Los que empiezan con mayúscula son variables (A).  
Los que empiezan con guion bajo son variables anónimas o nombradas (C).  
Los que comienzan con número NO son átomos válidos (D).
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">es_atomo</span><span style="color: #707183;">(</span>mi_constante_1<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">padre</span><span style="color: #707183;">(</span>juan<span style="color: #707183;">)</span><span style="color: #b22222;">% </span><span style="color: #b22222;">v&#225;lido</span>
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>2. ¿Resultado de [X,2] = [1,Y]?</b>
A) X=[1],Y=[2]  B) X=1,Y=2  C) Falla  D) X=1,Y=[2]
</p>

<p>
<b><b>Respuesta correcta:</b></b> B) X = 1, Y = 2
</p>


<p>
La unificación compara elemento por elemento:
</p>
<ul class="org-ul">
<li>X unifica con 1</li>
<li>2 unifica con Y → Y = 2</li>
</ul>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- <span style="color: #707183;">[</span><span style="color: #a0522d;">X</span>,2<span style="color: #707183;">]</span> = <span style="color: #707183;">[</span>1,<span style="color: #a0522d;">Y</span><span style="color: #707183;">]</span>.
<span style="color: #a0522d;">X</span> = 1, <span style="color: #a0522d;">Y</span> = 2.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>3. Meta [H|T] = [a,b,c,d]</b>  
A) &#x2026; B) H=a,T=[b,c,d] C) &#x2026; D) &#x2026;
</p>

<p>
<b><b>Respuesta correcta:</b></b> B
</p>


<p>
El operador | separa cabeza y cola:
</p>
<ul class="org-ul">
<li>H = a</li>
<li>T = [b,c,d]</li>
</ul>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- <span style="color: #707183;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #707183;">]</span> = <span style="color: #707183;">[</span>a,b,c,d<span style="color: #707183;">]</span>.
<span style="color: #a0522d;">H</span> = a,
<span style="color: #a0522d;">T</span> = <span style="color: #707183;">[</span>b, b, c, d<span style="color: #707183;">]</span>.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>4. Cláusula base correcta de longitud(L,N)</b>  
A) []→1 B) [_] →1 C) recursiva D) []→0
</p>

<p>
<b><b>Respuesta correcta:</b></b> D) longitud([],0)
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">longitud</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>,0<span style="color: #707183;">)</span>.
<span style="color: #0000ff;">longitud</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>,<span style="color: #a0522d;">N</span><span style="color: #707183;">)</span> :- longitud<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>,<span style="color: #a0522d;">N1</span><span style="color: #707183;">)</span>, <span style="color: #a0522d;">N</span> is <span style="color: #a0522d;">N1</span> + 1.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>5. Declaración verdadera sin cuerpo:</b>
A) Regla  B) Cláusula  C) Hecho  D) Meta
</p>

<p>
<b><b>Respuesta correcta:</b></b> C) Hecho
</p>


<p>
Un hecho describe un enunciado verdadero sin condiciones.
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">gato</span><span style="color: #707183;">(</span>felix<span style="color: #707183;">)</span>.  <span style="color: #b22222;">% </span><span style="color: #b22222;">hecho</span>
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>6. Aridad del predicado persona(nombre('Ana'), edad(25), sexo(f)).</b>
A)1 B)2 C)3 D)4
</p>

<p>
<b><b>Respuesta correcta:</b></b> C) 3
</p>


<p>
La aridad es el número de argumentos.
</p>

<p>
&#x2014;
</p>

<p>
<b>7. Efecto del operador de corte (!)</b>
A) &#x2026; B) &#x2026; C) Poda alternativas D) &#x2026;
</p>

<p>
<b><b>Respuesta correcta:</b></b> C
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">ejemplo</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">X</span>=1, <span style="color: #a020f0;">!</span>.
<span style="color: #0000ff;">ejemplo</span><span style="color: #707183;">(</span>2<span style="color: #707183;">)</span>.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>8. Predicado que evalúa expresiones aritméticas</b>
A) X=2+3 B) X==2+3 C) X is 2+3 D) &#x2026;
</p>

<p>
<b><b>Respuesta correcta:</b></b> C
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- <span style="color: #a0522d;">X</span> is 2+3.
<span style="color: #a0522d;">X</span> = 5.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>9. ¿Qué proceso deshace unificación al fallar?</b>
A) Forward chaining B) GC C) Backtracking D) Stack overflow
</p>

<p>
<b><b>Respuesta correcta:</b></b> C
</p>

<p>
&#x2014;
</p>

<p>
<b>10. Uso del guion bajo (_)</b>
A) nada B) variable anónima C) último elemento D) átomo
</p>

<p>
<b><b>Respuesta correcta:</b></b> B
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- miembro<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span>, <span style="color: #7388d6;">[</span>a,<span style="color: #a0522d;">_</span>,c<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
<span style="color: #a0522d;">X</span> = a <span style="color: #a020f0;">;</span>
<span style="color: #a0522d;">X</span> = c.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>11. ¿Qué pasa si fail aparece después de !?</b>
A) &#x2026; B) &#x2026; C) La regla falla y el backtracking se detiene D)
</p>

<p>
<b><b>Respuesta correcta:</b></b> C
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">p</span> :- a, <span style="color: #a020f0;">!</span>, fail.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>12. Negación por fallo (NAF)</b>
A) \= B) == C) \+ D) !
</p>

<p>
<b><b>Respuesta correcta:</b></b> C) \+
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">no_existe</span><span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span> :- \+ hecho<span style="color: #707183;">(</span><span style="color: #a0522d;">X</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>13. Cabeza en c(X) :- a(X), b(X).</b>
A) &#x2026; B) c(X) C) :- D) a(X)
</p>

<p>
<b><b>Respuesta correcta:</b></b> B
</p>

<p>
&#x2014;
</p>

<p>
<b>14. Operador para verificar identidad estructural</b>
A) <code>=</code> B) is C) <code>==</code> D) \
</p>

<p>
<b><b>Respuesta correcta:</b></b> C) ==
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- a<span style="color: #707183;">(</span>b<span style="color: #707183;">)</span> == a<span style="color: #707183;">(</span>b<span style="color: #707183;">)</span>.
true.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>15. Functor de persona(nombre(luis),30).</b>
A) nombre B) persona C) luis D) 30
</p>

<p>
<b><b>Respuesta correcta:</b></b> B
</p>

<p>
&#x2014;
</p>

<p>
<b>16. Predicado para agregar hecho al inicio</b>
A) retract B) assertz C) dynamic D) asserta
</p>

<p>
<b><b>Respuesta correcta:</b></b> D) asserta
</p>

<p>
&#x2014;
</p>

<p>
<b>17. Predicados para imprimir texto y nueva línea</b>
A) read B) print C) write, nl D) display, enter
</p>

<p>
<b><b>Respuesta correcta:</b></b> C
</p>

<p>
&#x2014;
</p>

<p>
<b>18. Unificación [a,b,c] = [X|[]]</b>
A) imposible B) X=[a,b,c] C) falla D) X=a
</p>

<p>
<b><b>Respuesta correcta:</b></b> C
</p>

<p>
Explicación: la lista derecha exige solo un elemento.
</p>

<p>
&#x2014;
</p>

<p>
<b>19. Recursión de cola</b>
A) llamada recursiva al final B) &#x2026; C) &#x2026; D) &#x2026;
</p>

<p>
<b><b>Respuesta correcta:</b></b> A
</p>

<p>
<b><b>Ejemplo (optimizable):</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">suma</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>,<span style="color: #a0522d;">Acc</span>,<span style="color: #a0522d;">Acc</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">suma</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">H</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">T</span><span style="color: #7388d6;">]</span>,<span style="color: #a0522d;">Acc</span>,<span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Acc1</span> is <span style="color: #a0522d;">Acc</span>+<span style="color: #a0522d;">H</span>, suma<span style="color: #707183;">(</span><span style="color: #a0522d;">T</span>,<span style="color: #a0522d;">Acc1</span>,<span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
&#x2014;
</p>

<p>
<b>20. Predicado que combina listas</b>
A) concatenate B) join C) append D) sum<sub>list</sub>
</p>

<p>
<b><b>Respuesta correcta:</b></b> C) append/3
</p>

<p>
<b><b>Ejemplo:</b></b>
</p>
<div class="org-src-container">
<pre class="src src-prolog">?- append<span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>1,2<span style="color: #7388d6;">]</span>,<span style="color: #7388d6;">[</span>3,4<span style="color: #7388d6;">]</span>,<span style="color: #a0522d;">R</span><span style="color: #707183;">)</span>.
<span style="color: #a0522d;">R</span> = <span style="color: #707183;">[</span>1,2,3,4<span style="color: #707183;">]</span>.
</pre>
</div>
</div>
</div>


<div id="outline-container-org2ee93e5" class="outline-2">
<h2 id="org2ee93e5">Acertijo Lógico Examen</h2>
<div class="outline-text-2" id="text-org2ee93e5">
</div>
<div id="outline-container-orgc7129ae" class="outline-3">
<h3 id="orgc7129ae">Descripción General</h3>
<div class="outline-text-3" id="text-orgc7129ae">
<p>
Cinco investigadores trabajan en un laboratorio de biología molecular.  
Cada uno tiene:
</p>
<ul class="org-ul">
<li>una especialidad distinta,</li>
<li>un horario distinto,</li>
<li>una bebida que prefiere,</li>
<li>un equipo de laboratorio distinto,</li>
<li>y un país de origen diferente.</li>
</ul>

<p>
Tu tarea es usar Prolog para deducir quién tiene qué atributos.
</p>
</div>
</div>

<div id="outline-container-orgd823d3d" class="outline-3">
<h3 id="orgd823d3d">Entidades</h3>
<div class="outline-text-3" id="text-orgd823d3d">
<p>
<b><b>Investigadores</b></b>
</p>
<ol class="org-ol">
<li>Ana</li>
<li>Bruno</li>
<li>Carlos</li>
<li>Diana</li>
<li>Elisa</li>
</ol>

<p>
<b><b>Especialidades</b></b>
</p>
<ul class="org-ul">
<li>Genética</li>
<li>Microbiología</li>
<li>Bioquímica</li>
<li>Inmunología</li>
<li>Neurociencia</li>
</ul>

<p>
<b><b>Horarios</b></b>
</p>
<ul class="org-ul">
<li>6am</li>
<li>8am</li>
<li>10am</li>
<li>12pm</li>
<li>14pm</li>
</ul>

<p>
<b><b>Bebidas</b></b>
</p>
<ul class="org-ul">
<li>Café</li>
<li>Té</li>
<li>Jugo</li>
<li>Mate</li>
<li>Agua</li>
</ul>

<p>
<b><b>Equipos</b></b>
</p>
<ul class="org-ul">
<li>Microscopio</li>
<li>Centrífuga</li>
<li>PCR</li>
<li>Espectrómetro</li>
<li>Incubadora</li>
</ul>

<p>
<b><b>Países</b></b>
</p>
<ul class="org-ul">
<li>México</li>
<li>Chile</li>
<li>España</li>
<li>Argentina</li>
<li>Perú</li>
</ul>
</div>
</div>

<div id="outline-container-orgea390e2" class="outline-3">
<h3 id="orgea390e2">Reglas del Acertijo</h3>
<div class="outline-text-3" id="text-orgea390e2">
<ol class="org-ol">
<li>El investigador de Genética llega a las 6am.</li>
<li>Ana no trabaja ni en Genética ni en Neurociencia.</li>
<li>La persona que usa la Centrífuga bebe Té.</li>
<li>La investigadora de Perú llega a las 10am.</li>
<li>Carlos usa el Espectrómetro.</li>
<li>Quien bebe Café llega dos horas antes que quien bebe Jugo.</li>
<li>La persona que trabaja en Inmunología usa PCR.</li>
<li>La especialista en Bioquímica es de Chile.</li>
<li>La Incubadora es utilizada por alguien que llega a las 14pm.</li>
<li>El investigador de Argentina bebe Mate.</li>
<li>Elisa no bebe Té ni Café.</li>
<li>Diana trabaja en Microbiología.</li>
<li>El que llega a las 8am usa el Microscopio.</li>
<li>Bruno no es de México.</li>
<li>La persona de España trabaja en Neurociencia.</li>
<li>El usuario del equipo PCR llega después que el especialista en Microbiología.</li>
<li>El de México usa el equipo que NO es Microscopio ni Incubadora.</li>
<li>La persona que bebe Agua no usa ni PCR ni Espectrómetro.</li>
<li>El especialista en Neurociencia llega después de la persona que bebe Jugo.</li>
<li>El de Perú NO bebe Agua.</li>
</ol>
</div>
</div>

<div id="outline-container-orgceae74d" class="outline-3">
<h3 id="orgceae74d">Preguntas para resolver con Prolog</h3>
<div class="outline-text-3" id="text-orgceae74d">
<ol class="org-ol">
<li>¿A qué hora llega cada investigador?</li>
<li>¿Qué especialidad tiene cada uno?</li>
<li>¿Qué bebida prefiere cada investigador?</li>
<li>¿Qué equipo usa cada quien?</li>
<li>¿De qué país es cada uno?</li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org2fb8b57" class="outline-2">
<h2 id="org2fb8b57">Eliza Lisp</h2>
<div class="outline-text-2" id="text-org2fb8b57">
<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #b22222;">;;;; </span><span style="color: #b22222;">eliza.lisp -- N&#250;cleo ELIZA traducido desde Prolog </span>
<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">- Templates similares a los de Prolog</span>
<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">- match que acepta elementos atom (coinciden exactamente) y (s) como wildcard para 1 token</span>
<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">- replace-resp que sustituye enteros en la respuesta por tokens del input seg&#250;n indices</span>
<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">- handlers gen&#233;ricos para flags</span>

<span style="color: #707183;">(</span>in-package <span style="color: #483d8b;">:cl-user</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span>defparameter *punct-chars* <span style="color: #8b2252;">".,;:()?!\"'"</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">clean-and-tokenize</span> <span style="color: #7388d6;">(</span>line<span style="color: #7388d6;">)</span>
  <span style="color: #8b2252;">"Convierte a min&#250;sculas, reemplaza puntuaci&#243;n por espacios y separa en tokens (strings)."</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>lower <span style="color: #907373;">(</span>string-downcase line<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>clean <span style="color: #907373;">(</span>coerce
                 <span style="color: #6276ba;">(</span>map 'string <span style="color: #858580;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #80a880;">(</span>c<span style="color: #80a880;">)</span>
                                <span style="color: #80a880;">(</span><span style="color: #a020f0;">if</span> <span style="color: #887070;">(</span>search <span style="color: #707183;">(</span>string c<span style="color: #707183;">)</span> *punct-chars*<span style="color: #887070;">)</span> #\Space c<span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
                      lower<span style="color: #6276ba;">)</span>
                 'string<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>remove <span style="color: #8b2252;">""</span> <span style="color: #709870;">(</span>mapcar <span style="color: #907373;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #6276ba;">(</span>s<span style="color: #6276ba;">)</span> s<span style="color: #907373;">)</span>
                       <span style="color: #907373;">(</span>split-sequence:split-sequence #\Space clean<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">-- Templates --</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Cada template es una lista: (stim resp indices)</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Stim: lista de elementos donde:</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">- un s&#237;mbolo (ej: 'hola) debe coincidir con el token exacto</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">- la forma (s) representa el s(_) de Prolog: coincide con un token cualquiera</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Resp: lista con strings y/o s&#237;mbolos; si aparece un n&#250;mero entero K en Resp,</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">indica un placeholder que ser&#225; sustituido por el token en Input en</span>
<span style="color: #b22222;">;;       </span><span style="color: #b22222;">la posici&#243;n indicada por indices[K].</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Indices: lista de enteros que indican posiciones en Input para extraer.</span>
<span style="color: #b22222;">;; </span><span style="color: #b22222;">Ejemplo inspirado en tu Prolog:</span>
<span style="color: #707183;">(</span>defparameter *templates*
  <span style="color: #7388d6;">(</span>list
   <span style="color: #b22222;">;; </span><span style="color: #b22222;">template([hola, s(_), como, estas, soy, s(_), '</span><span style="color: #008b8b;">.</span><span style="color: #b22222;">'],</span>
   <span style="color: #b22222;">;;          </span><span style="color: #b22222;">[hola , 1, 'como estas tu yo soy', 0 , 'como esta tu ?'],</span>
   <span style="color: #b22222;">;;          </span><span style="color: #b22222;">[1, 5]).</span>
   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'hola <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> 'como 'estas 'soy <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"hola"</span> 1 <span style="color: #8b2252;">"como estas tu yo soy"</span> 0 <span style="color: #8b2252;">"como esta tu ?"</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 1 5<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #b22222;">;; </span><span style="color: #b22222;">template([hola, s(_), soy, s(_), '</span><span style="color: #008b8b;">.</span><span style="color: #b22222;">'],</span>
   <span style="color: #b22222;">;;        </span><span style="color: #b22222;">[hola, 1, ' mi nombre es', 0 , 'en que te puedo ayudar'],</span>
   <span style="color: #b22222;">;;        </span><span style="color: #b22222;">[1, 3] ).</span>
   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'hola <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> 'soy <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"hola"</span> 1 <span style="color: #8b2252;">"mi nombre es"</span> 0 <span style="color: #8b2252;">"en que te puedo ayudar"</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 1 3<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #b22222;">;; </span><span style="color: #b22222;">algunos templates m&#225;s simples:</span>
   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'hola <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"Hola"</span> <span style="color: #8b2252;">"como"</span> <span style="color: #8b2252;">"estas"</span> <span style="color: #8b2252;">"tu"</span> <span style="color: #8b2252;">"?"</span><span style="color: #709870;">)</span>
         nil<span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'buendia <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"Buendia"</span> <span style="color: #8b2252;">"Como"</span> <span style="color: #8b2252;">"estas"</span> <span style="color: #8b2252;">"tu"</span> <span style="color: #8b2252;">"?"</span><span style="color: #709870;">)</span>
         nil<span style="color: #909183;">)</span>

   <span style="color: #b22222;">;; </span><span style="color: #b22222;">ejemplos con flags (se manejan despu&#233;s con handlers gen&#233;ricos)</span>
   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'te 'gustan 'las <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 'flagLike<span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 3<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'tu 'eres <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 'flagDo<span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 2<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'que 'eres 'tu <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 'flagIs<span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 2<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #b22222;">;; </span><span style="color: #b22222;">fallback</span>
   <span style="color: #909183;">(</span>list nil <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"Please"</span> <span style="color: #8b2252;">"explain"</span> <span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"little"</span> <span style="color: #8b2252;">"more"</span> <span style="color: #8b2252;">"."</span><span style="color: #709870;">)</span> nil<span style="color: #909183;">)</span>
   <span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">-- Match --</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">element-match-p</span> <span style="color: #7388d6;">(</span>templ-el token<span style="color: #7388d6;">)</span>
  <span style="color: #8b2252;">"Comprueba si un elemento de template coincide con token.</span>
<span style="color: #8b2252;">   templ-el puede ser:</span>
<span style="color: #8b2252;">     - un s&#237;mbolo: compara igualdad con token</span>
<span style="color: #8b2252;">     - la lista (s): wildcard que acepta cualquier token (si hay token)</span>
<span style="color: #8b2252;">     - NIL en template significa '</span><span style="color: #008b8b;">aceptar</span><span style="color: #8b2252;">' (match siempre si template vac&#237;o)"</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">cond</span>
    <span style="color: #909183;">(</span><span style="color: #709870;">(</span>null templ-el<span style="color: #709870;">)</span> t<span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #709870;">(</span><span style="color: #a020f0;">and</span> <span style="color: #907373;">(</span>consp templ-el<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>eq <span style="color: #6276ba;">(</span>first templ-el<span style="color: #6276ba;">)</span> 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span>not <span style="color: #907373;">(</span>null token<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>                 <span style="color: #b22222;">; </span><span style="color: #b22222;">s(_) =&gt; debe haber un token para casar</span>
    <span style="color: #909183;">(</span><span style="color: #709870;">(</span>symbolp templ-el<span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span><span style="color: #a020f0;">and</span> token <span style="color: #907373;">(</span>string= <span style="color: #6276ba;">(</span>symbol-name templ-el<span style="color: #6276ba;">)</span> token<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>t nil<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">match-template</span> <span style="color: #7388d6;">(</span>stim input<span style="color: #7388d6;">)</span>
  <span style="color: #8b2252;">"Intenta emparejar stim con input.</span>
<span style="color: #8b2252;">   Reglas:</span>
<span style="color: #8b2252;">   - si stim es NIL entonces coincide (como en Prolog: match([], _):- true).</span>
<span style="color: #8b2252;">   - avanza por los elementos de stim e input; (s) consume EXACTAMENTE 1 token.</span>
<span style="color: #8b2252;">   - si un elemento simb&#243;lico no coincide, falla.</span>
<span style="color: #8b2252;">   Devuelve T o NIL."</span>
  <span style="color: #7388d6;">(</span>labels <span style="color: #909183;">(</span><span style="color: #709870;">(</span>rec <span style="color: #907373;">(</span>slist ilist<span style="color: #907373;">)</span>
             <span style="color: #907373;">(</span><span style="color: #a020f0;">cond</span>
               <span style="color: #b22222;">;; </span><span style="color: #b22222;">si stim vac&#237;o -&gt; &#233;xito (Prolog permit&#237;a esto)</span>
               <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>null slist<span style="color: #858580;">)</span> t<span style="color: #6276ba;">)</span>
               <span style="color: #b22222;">;; </span><span style="color: #b22222;">si stim no vac&#237;o pero input vac&#237;o -&gt; fallo (no hay tokens para comparar)</span>
               <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>null ilist<span style="color: #858580;">)</span>
                <span style="color: #b22222;">;; </span><span style="color: #b22222;">excepci&#243;n: si todos los elementos restantes de slist son nil o s&#243;lo wildcards?</span>
                nil<span style="color: #6276ba;">)</span>
               <span style="color: #6276ba;">(</span>t
                <span style="color: #858580;">(</span><span style="color: #a020f0;">let</span> <span style="color: #80a880;">(</span><span style="color: #887070;">(</span>se <span style="color: #707183;">(</span>first slist<span style="color: #707183;">)</span><span style="color: #887070;">)</span> <span style="color: #887070;">(</span>it <span style="color: #707183;">(</span>first ilist<span style="color: #707183;">)</span><span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
                  <span style="color: #80a880;">(</span><span style="color: #a020f0;">if</span> <span style="color: #887070;">(</span>element-match-p se it<span style="color: #887070;">)</span>
                      <span style="color: #887070;">(</span>rec <span style="color: #707183;">(</span>rest slist<span style="color: #707183;">)</span> <span style="color: #707183;">(</span>rest ilist<span style="color: #707183;">)</span><span style="color: #887070;">)</span>
                      nil<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>rec stim input<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">-- Replace / Build response --</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-token-at</span> <span style="color: #7388d6;">(</span>input pos<span style="color: #7388d6;">)</span>
  <span style="color: #8b2252;">"Devuelve token en input por &#237;ndice; si se sale, devuelve \"\"."</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span><span style="color: #a020f0;">and</span> input <span style="color: #709870;">(</span>&gt;= pos 0<span style="color: #709870;">)</span> <span style="color: #709870;">(</span>&lt; pos <span style="color: #907373;">(</span>length input<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      <span style="color: #909183;">(</span>nth pos input<span style="color: #909183;">)</span>
      <span style="color: #8b2252;">""</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-response-from-resp</span> <span style="color: #7388d6;">(</span>resp indices input<span style="color: #7388d6;">)</span>
  <span style="color: #8b2252;">"Construye la respuesta final:</span>
<span style="color: #8b2252;">   - si resp contiene un entero k -&gt; sustituir por token en input en posici&#243;n indices[k]"</span>
  <span style="color: #7388d6;">(</span>mapcan
   <span style="color: #909183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #709870;">(</span>e<span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span><span style="color: #a020f0;">cond</span>
       <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>integerp e<span style="color: #6276ba;">)</span>
        <span style="color: #6276ba;">(</span><span style="color: #a020f0;">let</span> <span style="color: #858580;">(</span><span style="color: #80a880;">(</span>idx <span style="color: #887070;">(</span><span style="color: #a020f0;">if</span> <span style="color: #707183;">(</span><span style="color: #a020f0;">and</span> indices <span style="color: #7388d6;">(</span>&gt;= e 0<span style="color: #7388d6;">)</span> <span style="color: #7388d6;">(</span>&lt; e <span style="color: #909183;">(</span>length indices<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
                       <span style="color: #707183;">(</span>nth e indices<span style="color: #707183;">)</span>
                       nil<span style="color: #887070;">)</span><span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
          <span style="color: #858580;">(</span><span style="color: #a020f0;">if</span> idx
              <span style="color: #80a880;">(</span>list <span style="color: #887070;">(</span>get-token-at input idx<span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
              <span style="color: #80a880;">(</span>list <span style="color: #8b2252;">""</span><span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>            <span style="color: #b22222;">; </span><span style="color: #b22222;">si algo falla, string vac&#237;o</span>
       <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>symbolp e<span style="color: #6276ba;">)</span>
        <span style="color: #6276ba;">(</span>list <span style="color: #858580;">(</span>symbol-name e<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
       <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>stringp e<span style="color: #6276ba;">)</span> <span style="color: #6276ba;">(</span>list e<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
       <span style="color: #907373;">(</span>t <span style="color: #6276ba;">(</span>list <span style="color: #858580;">(</span>princ-to-string e<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
   resp<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">-- Handlers gen&#233;ricos para flags (porque NO tenemos los predicados likes/does/.. ) --</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">handle-flag</span> <span style="color: #909183;">(</span>flag indices input<span style="color: #909183;">)</span>
  <span style="color: #8b2252;">"Respuestas gen&#233;ricas para los flag* usados en tus templates."</span>
  <span style="color: #909183;">(</span><span style="color: #a020f0;">let</span> <span style="color: #709870;">(</span><span style="color: #907373;">(</span>arg-token <span style="color: #6276ba;">(</span><span style="color: #a020f0;">and</span> indices <span style="color: #858580;">(</span>&gt; <span style="color: #80a880;">(</span>length indices<span style="color: #80a880;">)</span> 0<span style="color: #858580;">)</span>
                        <span style="color: #858580;">(</span>get-token-at input <span style="color: #80a880;">(</span>first indices<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
    <span style="color: #709870;">(</span>case flag
      <span style="color: #907373;">(</span>flagLike <span style="color: #6276ba;">(</span><span style="color: #a020f0;">if</span> arg-token
                    <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"can't"</span> <span style="color: #8b2252;">"tell"</span> <span style="color: #8b2252;">"if"</span> <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"like"</span> arg-token<span style="color: #858580;">)</span>
                    <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"don't"</span> <span style="color: #8b2252;">"have"</span> <span style="color: #8b2252;">"preferences"</span> <span style="color: #8b2252;">"here."</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
      <span style="color: #907373;">(</span>flagDo <span style="color: #6276ba;">(</span><span style="color: #a020f0;">if</span> arg-token
                  <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"sometimes"</span> <span style="color: #8b2252;">"do"</span> arg-token<span style="color: #858580;">)</span>
                  <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"do"</span> <span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"few"</span> <span style="color: #8b2252;">"things."</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
      <span style="color: #907373;">(</span>flagIs <span style="color: #6276ba;">(</span><span style="color: #a020f0;">if</span> arg-token
                  <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"am"</span> <span style="color: #8b2252;">"a"</span> arg-token<span style="color: #858580;">)</span>
                  <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"am"</span> <span style="color: #8b2252;">"Eliza"</span> <span style="color: #8b2252;">"."</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
      <span style="color: #907373;">(</span>flagEres <span style="color: #6276ba;">(</span><span style="color: #a020f0;">if</span> arg-token
                    <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"Yes,"</span> <span style="color: #8b2252;">"you"</span> <span style="color: #8b2252;">"are"</span> arg-token<span style="color: #858580;">)</span>
                    <span style="color: #858580;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"am"</span> <span style="color: #8b2252;">"not"</span> <span style="color: #8b2252;">"sure."</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
      <span style="color: #907373;">(</span>flagfam <span style="color: #6276ba;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"cannot"</span> <span style="color: #8b2252;">"compute"</span> <span style="color: #8b2252;">"family"</span> <span style="color: #8b2252;">"without"</span> <span style="color: #8b2252;">"facts."</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
      <span style="color: #907373;">(</span>t <span style="color: #6276ba;">(</span>list <span style="color: #8b2252;">"Please"</span> <span style="color: #8b2252;">"explain"</span> <span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"little"</span> <span style="color: #8b2252;">"more"</span> <span style="color: #8b2252;">"."</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Versi&#243;n auxiliar que busca la primer template que haga match</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-matching-template</span> <span style="color: #909183;">(</span>input<span style="color: #909183;">)</span>
  <span style="color: #8b2252;">"Busca en *templates* la primer template cuyo stim haga match con input.</span>
<span style="color: #8b2252;">   Devuelve la plantilla (stim resp indices) o NIL."</span>
  <span style="color: #909183;">(</span>find-if <span style="color: #709870;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #907373;">(</span>tpl<span style="color: #907373;">)</span>
             <span style="color: #907373;">(</span><span style="color: #a020f0;">let</span> <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>stim <span style="color: #80a880;">(</span>first tpl<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span>
               <span style="color: #6276ba;">(</span><span style="color: #a020f0;">if</span> <span style="color: #858580;">(</span>null stim<span style="color: #858580;">)</span>
                   t
                   <span style="color: #858580;">(</span>match-template stim input<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
           *templates*<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Funci&#243;n de respuesta dada una entrada tokenizada</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">respond-to</span> <span style="color: #909183;">(</span>input<span style="color: #909183;">)</span>
  <span style="color: #909183;">(</span><span style="color: #a020f0;">let</span> <span style="color: #709870;">(</span><span style="color: #907373;">(</span>tpl <span style="color: #6276ba;">(</span>find-matching-template input<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
    <span style="color: #709870;">(</span><span style="color: #a020f0;">when</span> tpl
      <span style="color: #907373;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>resp <span style="color: #80a880;">(</span>second tpl<span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
             <span style="color: #858580;">(</span>indices <span style="color: #80a880;">(</span>third tpl<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span>
        <span style="color: #b22222;">;; </span><span style="color: #b22222;">si resp empieza por un flag simb&#243;lico, usar handler</span>
        <span style="color: #6276ba;">(</span><span style="color: #a020f0;">if</span> <span style="color: #858580;">(</span><span style="color: #a020f0;">and</span> <span style="color: #80a880;">(</span>consp resp<span style="color: #80a880;">)</span> <span style="color: #80a880;">(</span>symbolp <span style="color: #887070;">(</span>first resp<span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
                 <span style="color: #80a880;">(</span>find <span style="color: #887070;">(</span>first resp<span style="color: #887070;">)</span> '<span style="color: #887070;">(</span>flagLike flagDo flagIs flagEres flagfam<span style="color: #887070;">)</span><span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
            <span style="color: #858580;">(</span><span style="color: #a020f0;">let</span> <span style="color: #80a880;">(</span><span style="color: #887070;">(</span>handled <span style="color: #707183;">(</span>handle-flag <span style="color: #7388d6;">(</span>first resp<span style="color: #7388d6;">)</span> indices input<span style="color: #707183;">)</span><span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
              <span style="color: #80a880;">(</span>format t <span style="color: #8b2252;">"~{~a~^ ~}~%"</span> handled<span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">si no es un flag, construir la respuesta</span>
            <span style="color: #858580;">(</span><span style="color: #a020f0;">let</span> <span style="color: #80a880;">(</span><span style="color: #887070;">(</span>built <span style="color: #707183;">(</span>build-response-from-resp resp indices input<span style="color: #707183;">)</span><span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
              <span style="color: #80a880;">(</span>format t <span style="color: #8b2252;">"~{~a~^ ~}~%"</span> built<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">-- Loop principal --</span>
<span style="color: #7388d6;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">eliza-loop</span> <span style="color: #909183;">()</span>
  <span style="color: #909183;">(</span>format t <span style="color: #8b2252;">"Hola, mi nombre es Eliza, tu chatbot.~%por favor ingresa tu consulta (min&#250;sculas, sin punto al final preferible).~%"</span><span style="color: #909183;">)</span>
  <span style="color: #909183;">(</span>loop
     <span style="color: #709870;">(</span>format t <span style="color: #8b2252;">"~%&gt; "</span><span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>line <span style="color: #858580;">(</span>read-line *query-io* nil nil<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
       <span style="color: #907373;">(</span><span style="color: #a020f0;">when</span> <span style="color: #6276ba;">(</span>null line<span style="color: #6276ba;">)</span> <span style="color: #6276ba;">(</span>return<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span> <span style="color: #b22222;">; </span><span style="color: #b22222;">fin si EOF</span>
       <span style="color: #907373;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>tokens <span style="color: #80a880;">(</span>clean-and-tokenize line<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span>
         <span style="color: #6276ba;">(</span><span style="color: #a020f0;">cond</span>
           <span style="color: #858580;">(</span><span style="color: #80a880;">(</span><span style="color: #a020f0;">or</span> <span style="color: #887070;">(</span><span style="color: #a020f0;">and</span> tokens <span style="color: #707183;">(</span>string= <span style="color: #7388d6;">(</span>first tokens<span style="color: #7388d6;">)</span> <span style="color: #8b2252;">"adios"</span><span style="color: #707183;">)</span><span style="color: #887070;">)</span>
                <span style="color: #887070;">(</span><span style="color: #a020f0;">and</span> tokens <span style="color: #707183;">(</span>string= <span style="color: #7388d6;">(</span>first tokens<span style="color: #7388d6;">)</span> <span style="color: #8b2252;">"bye"</span><span style="color: #707183;">)</span><span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
            <span style="color: #80a880;">(</span>format t <span style="color: #8b2252;">"Adios. espero poder verte ayudado.~%"</span><span style="color: #80a880;">)</span>
            <span style="color: #80a880;">(</span>return<span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
           <span style="color: #858580;">(</span>t <span style="color: #80a880;">(</span>respond-to tokens<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Para ejecutar: (eliza-loop)</span>

</pre>
</div>
</div>
</div>



<div id="outline-container-org834163a" class="outline-2">
<h2 id="org834163a">Implementando ELIZA en Common Lisp</h2>
</div>

<div id="outline-container-orgc1e441e" class="outline-2">
<h2 id="orgc1e441e">Introducción</h2>
<div class="outline-text-2" id="text-orgc1e441e">
<ul class="org-ul">
<li>El sistema de <b>templates</b> (plantillas de entrada–respuesta)</li>
<li>La función <code>match/2</code> que compara <b>input</b> con <b>stim</b></li>
<li>La función <code>replace0/5</code> para sustituir los índices en la respuesta</li>
<li>El ciclo principal de interacción del chatbot</li>
</ul>
</div>
</div>


<div id="outline-container-org0ea45ad" class="outline-2">
<h2 id="org0ea45ad">Diferencias conceptuales entre Prolog y Lisp</h2>
<div class="outline-text-2" id="text-org0ea45ad">
<p>
Prolog es:
</p>
<ul class="org-ul">
<li>declarativo</li>
<li>basado en hechos y reglas</li>
<li>usa unificación y <b>backtracking</b> automático</li>
<li>las listas son estructuras fundamentales de coincidencia</li>
</ul>

<p>
Common Lisp es:
</p>
<ul class="org-ul">
<li>imperativo/funcional</li>
<li>no tiene motor lógico incorporado</li>
<li>el programador implementa manualmente las reglas</li>
</ul>

<p>
Esto implica:
</p>

<p>
<b><b>Cada predicado Prolog debe convertirse en una función Lisp.</b></b>
<b><b>Cada plantilla debe procesarse explícitamente.</b></b>
</p>

<p>
Por ejemplo, en Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">match</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>hola, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, soy, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En Lisp debemos programar la función que recorra ambas listas y detecte:
</p>

<ul class="org-ul">
<li>símbolos que deben coincidir exactamente</li>
<li><code>s(_)</code> representado como un comodín que coincide con cualquier token</li>
</ul>
</div>
</div>

<div id="outline-container-orgb7e3159" class="outline-2">
<h2 id="orgb7e3159">Representación de Templates en Lisp</h2>
<div class="outline-text-2" id="text-orgb7e3159">
<p>
En Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>hola, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, soy, s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span>, <span style="color: #8b2252;">'.'</span><span style="color: #7388d6;">]</span>,
         <span style="color: #7388d6;">[</span>hola, 1, <span style="color: #8b2252;">'mi nombre es'</span>, 0 , <span style="color: #8b2252;">'en que te puedo ayudar'</span><span style="color: #7388d6;">]</span>,
         <span style="color: #7388d6;">[</span>1, 3<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En Common Lisp lo representamos como una lista con tres partes:
</p>

<ol class="org-ol">
<li>La <b>stim</b> (condición de entrada)</li>
<li>La <b>resp</b> (lista con textos y números que serán reemplazados)</li>
<li>La lista de <b>índices</b> que indica qué posiciones del input usar</li>
</ol>

<p>
Ejemplo en Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>list
  <span style="color: #7388d6;">(</span>list 'hola <span style="color: #909183;">(</span>list 's<span style="color: #909183;">)</span> 'soy <span style="color: #909183;">(</span>list 's<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span>   <span style="color: #b22222;">; stim</span>
  <span style="color: #7388d6;">(</span>list <span style="color: #8b2252;">"hola"</span> 1 <span style="color: #8b2252;">"mi nombre es"</span> 0 <span style="color: #8b2252;">"en que te puedo ayudar"</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>list 1 3<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
El `(list 's)` representa el comodín <code>s(_)</code> de Prolog.
</p>
</div>
</div>

<div id="outline-container-org9bb2d54" class="outline-2">
<h2 id="org9bb2d54">Tokenización del input</h2>
<div class="outline-text-2" id="text-org9bb2d54">
<p>
Prolog ya trabaja tokenizado porque <code>readln/1</code> produce una lista de átomos.
</p>

<p>
En Lisp debemos tokenizar manualmente:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">clean-and-tokenize</span> <span style="color: #7388d6;">(</span>line<span style="color: #7388d6;">)</span>
  <span style="color: #8b2252;">"Convierte un string a tokens limpios."</span>
  ...
<span style="color: #707183;">)</span>
</pre>
</div>

<p>
El tokenizer elimina signos de puntuación y baja todo a minúsculas.
</p>
</div>
</div>

<div id="outline-container-orgde263f0" class="outline-2">
<h2 id="orgde263f0">Implementación del MATCH (equivalente a match/2 en Prolog)</h2>
<div class="outline-text-2" id="text-orgde263f0">
<p>
La regla de Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">match</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[]</span>, <span style="color: #a0522d;">_</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">match</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">S</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">Stim</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">I</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">Input</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">S</span> == <span style="color: #a0522d;">I</span>, match<span style="color: #707183;">(</span><span style="color: #a0522d;">Stim</span>, <span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>.
<span style="color: #0000ff;">match</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span>s<span style="color: #909183;">(</span><span style="color: #a0522d;">_</span><span style="color: #909183;">)</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">Stim</span><span style="color: #7388d6;">]</span>, <span style="color: #7388d6;">[</span><span style="color: #a0522d;">_</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">Input</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span> :- match<span style="color: #707183;">(</span><span style="color: #a0522d;">Stim</span>, <span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En Lisp:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">match-template</span> <span style="color: #7388d6;">(</span>stim input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">labels</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>rec <span style="color: #907373;">(</span>slist ilist<span style="color: #907373;">)</span> ...<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>rec stim input<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
La función <code>element-match-p</code> maneja:
</p>

<ul class="org-ul">
<li>coincidencia exacta</li>
<li>comodín (s)</li>
</ul>
</div>
</div>

<div id="outline-container-org8f89260" class="outline-2">
<h2 id="org8f89260">Implementación del replace0 (equivalente a replace0/5)</h2>
<div class="outline-text-2" id="text-org8f89260">
<p>
En Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span><span style="color: #7388d6;">[</span><span style="color: #a0522d;">I</span><span style="color: #a020f0;">|</span><span style="color: #a0522d;">Index</span><span style="color: #7388d6;">]</span>, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">R</span><span style="color: #707183;">)</span> :-
    nth0<span style="color: #707183;">(</span><span style="color: #a0522d;">I</span>, <span style="color: #a0522d;">Input</span>, <span style="color: #a0522d;">Atom</span><span style="color: #707183;">)</span>,
    select<span style="color: #707183;">(</span><span style="color: #a0522d;">N</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">Atom</span>, <span style="color: #a0522d;">R1</span><span style="color: #707183;">)</span>,
    ...
</pre>
</div>

<p>
En Lisp implementamos una sustitución basada en:
</p>

<ul class="org-ul">
<li>índices</li>
<li>valores numéricos en la respuesta (0,1,2…)</li>
<li>reemplazo por tokens del input</li>
</ul>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-response-from-resp</span> <span style="color: #7388d6;">(</span>resp indices input<span style="color: #7388d6;">)</span>
  ...
<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Ejemplo:
</p>

<ul class="org-ul">
<li>Resp: <code>("hola" 1 "soy" 0)</code></li>
<li>Indices: <code>(3 5)</code></li>
<li>Input: <code>("hola" "eduardo" "soy" "programador")</code></li>
</ul>

<p>
Resultado:
</p>

<p>
<code>hola programador soy eduardo</code>
</p>

<p>
Porque:
</p>
<ul class="org-ul">
<li>índice 1 → input[5]</li>
<li>índice 0 → input[3]</li>
</ul>
</div>
</div>

<div id="outline-container-org6f6ea2f" class="outline-2">
<h2 id="org6f6ea2f">Manejo de FLAGS</h2>
<div class="outline-text-2" id="text-org6f6ea2f">
<p>
Aunque en tu Prolog hay flags como:
</p>

<ul class="org-ul">
<li>flagLike</li>
<li>flagDo</li>
<li>flagIs</li>
<li>flagEres</li>
<li>flagfam</li>
</ul>

<p>
En la opción 2 pediste NO incluir base de conocimiento.
</p>

<p>
Así que implementamos un handler genérico:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">handle-flag</span> <span style="color: #7388d6;">(</span>flag indices input<span style="color: #7388d6;">)</span>
  ...
<span style="color: #707183;">)</span>
</pre>
</div>

<p>
Esto permite que el programa funcione
sin tener hechos tipo <code>likes/1</code> o <code>padre/2</code>.
</p>
</div>
</div>

<div id="outline-container-org819be53" class="outline-2">
<h2 id="org819be53">Búsqueda de la plantilla correcta</h2>
<div class="outline-text-2" id="text-org819be53">
<p>
En Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">template</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Stim</span>, <span style="color: #a0522d;">Resp</span>, <span style="color: #a0522d;">Index</span><span style="color: #707183;">)</span>,
<span style="color: #0000ff;">match</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Stim</span>, <span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span>,
<span style="color: #0000ff;">replace0</span><span style="color: #707183;">(</span>...<span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En Lisp usamos <code>find-if</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-matching-template</span> <span style="color: #7388d6;">(</span>input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>find-if
    <span style="color: #909183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #709870;">(</span>tpl<span style="color: #709870;">)</span> <span style="color: #709870;">(</span>match-template <span style="color: #907373;">(</span>first tpl<span style="color: #907373;">)</span> input<span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    *templates*<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf113257" class="outline-2">
<h2 id="orgf113257">Ciclo principal (loop) equivalente al <code>eliza/1</code> de Prolog</h2>
<div class="outline-text-2" id="text-orgf113257">
<p>
En Prolog:
</p>

<div class="org-src-container">
<pre class="src src-prolog"><span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :- <span style="color: #a0522d;">Input</span> == <span style="color: #707183;">[</span><span style="color: #8b2252;">'Adios'</span><span style="color: #707183;">]</span>, ...
<span style="color: #0000ff;">eliza</span><span style="color: #707183;">(</span><span style="color: #a0522d;">Input</span><span style="color: #707183;">)</span> :-
    template<span style="color: #707183;">(</span>...<span style="color: #707183;">)</span>,
    match<span style="color: #707183;">(</span>...<span style="color: #707183;">)</span>,
    replace0<span style="color: #707183;">(</span>...<span style="color: #707183;">)</span>,
    eliza<span style="color: #707183;">(</span><span style="color: #a0522d;">Input1</span><span style="color: #707183;">)</span>.
</pre>
</div>

<p>
En Lisp usamos un bucle <code>loop</code>:
</p>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">eliza-loop</span> <span style="color: #7388d6;">()</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">loop</span>
    <span style="color: #909183;">(</span>format t <span style="color: #8b2252;">"&gt; "</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #a020f0;">let</span> <span style="color: #709870;">(</span><span style="color: #907373;">(</span>line <span style="color: #6276ba;">(</span>read-line<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span><span style="color: #a020f0;">let</span> <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>tokens <span style="color: #858580;">(</span>clean-and-tokenize line<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
        <span style="color: #907373;">(</span><span style="color: #a020f0;">cond</span>
          <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>string= <span style="color: #80a880;">(</span>first tokens<span style="color: #80a880;">)</span> <span style="color: #8b2252;">"adios"</span><span style="color: #858580;">)</span> ...<span style="color: #6276ba;">)</span>
          <span style="color: #6276ba;">(</span>t <span style="color: #858580;">(</span>respond-to tokens<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org563fe51" class="outline-2">
<h2 id="org563fe51">Código completo (NÚCLEO de ELIZA)</h2>
<div class="outline-text-2" id="text-org563fe51">
<div class="org-src-container">
<pre class="src src-lisp">
<span style="color: #707183;">(</span><span style="color: #a020f0;">in-package</span> <span style="color: #483d8b;">:cl-user</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*punct-chars*</span> <span style="color: #8b2252;">".,;:()?!\"'"</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">clean-and-tokenize</span> <span style="color: #7388d6;">(</span>line<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>lower <span style="color: #907373;">(</span>string-downcase line<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>clean <span style="color: #907373;">(</span>coerce
                 <span style="color: #6276ba;">(</span>map 'string <span style="color: #858580;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #80a880;">(</span>c<span style="color: #80a880;">)</span>
                                <span style="color: #80a880;">(</span><span style="color: #a020f0;">if</span> <span style="color: #887070;">(</span>search <span style="color: #707183;">(</span>string c<span style="color: #707183;">)</span> *punct-chars*<span style="color: #887070;">)</span> #\Space c<span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
                      lower<span style="color: #6276ba;">)</span>
                 'string<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>remove <span style="color: #8b2252;">""</span> <span style="color: #709870;">(</span>split-sequence:split-sequence #\Space clean<span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">element-match-p</span> <span style="color: #7388d6;">(</span>templ-el token<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">cond</span>
    <span style="color: #909183;">(</span><span style="color: #709870;">(</span>null templ-el<span style="color: #709870;">)</span> t<span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #709870;">(</span>and <span style="color: #907373;">(</span>consp templ-el<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>eq <span style="color: #6276ba;">(</span>first templ-el<span style="color: #6276ba;">)</span> 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span>not <span style="color: #907373;">(</span>null token<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #709870;">(</span>symbolp templ-el<span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span>and token <span style="color: #907373;">(</span>string= <span style="color: #6276ba;">(</span>symbol-name templ-el<span style="color: #6276ba;">)</span> token<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>t nil<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">match-template</span> <span style="color: #7388d6;">(</span>stim input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">labels</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>rec <span style="color: #907373;">(</span>slist ilist<span style="color: #907373;">)</span>
             <span style="color: #907373;">(</span><span style="color: #a020f0;">cond</span>
               <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>null slist<span style="color: #858580;">)</span> t<span style="color: #6276ba;">)</span>
               <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>null ilist<span style="color: #858580;">)</span> nil<span style="color: #6276ba;">)</span>
               <span style="color: #6276ba;">(</span>t
                <span style="color: #858580;">(</span><span style="color: #a020f0;">let</span> <span style="color: #80a880;">(</span><span style="color: #887070;">(</span>se <span style="color: #707183;">(</span>first slist<span style="color: #707183;">)</span><span style="color: #887070;">)</span>
                      <span style="color: #887070;">(</span>it <span style="color: #707183;">(</span>first ilist<span style="color: #707183;">)</span><span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
                  <span style="color: #80a880;">(</span><span style="color: #a020f0;">if</span> <span style="color: #887070;">(</span>element-match-p se it<span style="color: #887070;">)</span>
                      <span style="color: #887070;">(</span>rec <span style="color: #707183;">(</span>rest slist<span style="color: #707183;">)</span> <span style="color: #707183;">(</span>rest ilist<span style="color: #707183;">)</span><span style="color: #887070;">)</span>
                      nil<span style="color: #80a880;">)</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span>rec stim input<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">get-token-at</span> <span style="color: #7388d6;">(</span>input pos<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">if</span> <span style="color: #909183;">(</span>and input <span style="color: #709870;">(</span>&gt;= pos 0<span style="color: #709870;">)</span> <span style="color: #709870;">(</span>&lt; pos <span style="color: #907373;">(</span>length input<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
      <span style="color: #909183;">(</span>nth pos input<span style="color: #909183;">)</span>
      <span style="color: #8b2252;">""</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">build-response-from-resp</span> <span style="color: #7388d6;">(</span>resp indices input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>mapcan
   <span style="color: #909183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #709870;">(</span>e<span style="color: #709870;">)</span>
     <span style="color: #709870;">(</span><span style="color: #a020f0;">cond</span>
       <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>integerp e<span style="color: #6276ba;">)</span>
        <span style="color: #6276ba;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #858580;">(</span><span style="color: #80a880;">(</span>idx <span style="color: #887070;">(</span>nth e indices<span style="color: #887070;">)</span><span style="color: #80a880;">)</span>
               <span style="color: #80a880;">(</span>tok <span style="color: #887070;">(</span>get-token-at input idx<span style="color: #887070;">)</span><span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
          <span style="color: #858580;">(</span>list tok<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
       <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>symbolp e<span style="color: #6276ba;">)</span> <span style="color: #6276ba;">(</span>list <span style="color: #858580;">(</span>symbol-name e<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
       <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>stringp e<span style="color: #6276ba;">)</span> <span style="color: #6276ba;">(</span>list e<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
       <span style="color: #907373;">(</span>t <span style="color: #6276ba;">(</span>list <span style="color: #858580;">(</span>princ-to-string e<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
   resp<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">handle-flag</span> <span style="color: #7388d6;">(</span>flag indices input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>arg-token <span style="color: #907373;">(</span>and indices <span style="color: #6276ba;">(</span>get-token-at input <span style="color: #858580;">(</span>first indices<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #a020f0;">case</span> flag
      <span style="color: #709870;">(</span>flagLike <span style="color: #907373;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"cannot"</span> <span style="color: #8b2252;">"tell"</span> <span style="color: #8b2252;">"if"</span> <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"like"</span> arg-token<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>flagDo   <span style="color: #907373;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"sometimes"</span> <span style="color: #8b2252;">"do"</span> arg-token<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>flagIs   <span style="color: #907373;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"am"</span> <span style="color: #8b2252;">"a"</span> arg-token<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>flagEres <span style="color: #907373;">(</span>list <span style="color: #8b2252;">"Yes,"</span> <span style="color: #8b2252;">"you"</span> <span style="color: #8b2252;">"are"</span> arg-token<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>flagfam  <span style="color: #907373;">(</span>list <span style="color: #8b2252;">"I"</span> <span style="color: #8b2252;">"cannot"</span> <span style="color: #8b2252;">"compute"</span> <span style="color: #8b2252;">"family"</span> <span style="color: #8b2252;">"facts"</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span>t        <span style="color: #907373;">(</span>list <span style="color: #8b2252;">"Please"</span> <span style="color: #8b2252;">"explain"</span> <span style="color: #8b2252;">"more"</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #b22222;">;; </span><span style="color: #b22222;">Templates</span>
<span style="color: #707183;">(</span><span style="color: #a020f0;">defparameter</span> <span style="color: #a0522d;">*templates*</span>
  <span style="color: #7388d6;">(</span>list
   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'hola <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> 'como 'estas 'soy <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"hola"</span> 1 <span style="color: #8b2252;">"como estas tu yo soy"</span> 0 <span style="color: #8b2252;">"como esta tu ?"</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 1 5<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'hola <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> 'soy <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"hola"</span> 1 <span style="color: #8b2252;">"mi nombre es"</span> 0 <span style="color: #8b2252;">"en que te puedo ayudar"</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 1 3<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'hola <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"Hola"</span> <span style="color: #8b2252;">"como"</span> <span style="color: #8b2252;">"estas"</span> <span style="color: #8b2252;">"tu"</span> <span style="color: #8b2252;">"?"</span><span style="color: #709870;">)</span>
         nil<span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'buendia <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"Buendia"</span> <span style="color: #8b2252;">"Como"</span> <span style="color: #8b2252;">"estas"</span> <span style="color: #8b2252;">"tu"</span> <span style="color: #8b2252;">"?"</span><span style="color: #709870;">)</span>
         nil<span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'te 'gustan 'las <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 'flagLike<span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 3<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'tu 'eres <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span> <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 'flagDo<span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 2<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list <span style="color: #709870;">(</span>list 'que 'eres 'tu <span style="color: #907373;">(</span>list 's<span style="color: #907373;">)</span><span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 'flagIs<span style="color: #709870;">)</span>
         <span style="color: #709870;">(</span>list 2<span style="color: #709870;">)</span><span style="color: #909183;">)</span>

   <span style="color: #909183;">(</span>list nil
         <span style="color: #709870;">(</span>list <span style="color: #8b2252;">"Please"</span> <span style="color: #8b2252;">"explain"</span> <span style="color: #8b2252;">"a"</span> <span style="color: #8b2252;">"little"</span> <span style="color: #8b2252;">"more"</span> <span style="color: #8b2252;">"."</span><span style="color: #709870;">)</span>
         nil<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">find-matching-template</span> <span style="color: #7388d6;">(</span>input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span>find-if <span style="color: #909183;">(</span><span style="color: #a020f0;">lambda</span> <span style="color: #709870;">(</span>tpl<span style="color: #709870;">)</span>
             <span style="color: #709870;">(</span><span style="color: #a020f0;">let</span> <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>stim <span style="color: #858580;">(</span>first tpl<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
               <span style="color: #907373;">(</span><span style="color: #a020f0;">if</span> <span style="color: #6276ba;">(</span>null stim<span style="color: #6276ba;">)</span> t <span style="color: #6276ba;">(</span>match-template stim input<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
           *templates*<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">respond-to</span> <span style="color: #7388d6;">(</span>input<span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">let</span> <span style="color: #909183;">(</span><span style="color: #709870;">(</span>tpl <span style="color: #907373;">(</span>find-matching-template input<span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span>
    <span style="color: #909183;">(</span><span style="color: #a020f0;">let</span> <span style="color: #709870;">(</span><span style="color: #907373;">(</span>resp <span style="color: #6276ba;">(</span>second tpl<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
          <span style="color: #907373;">(</span>indices <span style="color: #6276ba;">(</span>third tpl<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
      <span style="color: #709870;">(</span><span style="color: #a020f0;">if</span> <span style="color: #907373;">(</span>and <span style="color: #6276ba;">(</span>symbolp <span style="color: #858580;">(</span>first resp<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span>
               <span style="color: #6276ba;">(</span>member <span style="color: #858580;">(</span>first resp<span style="color: #858580;">)</span> '<span style="color: #858580;">(</span>flagLike flagDo flagIs flagEres flagfam<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
          <span style="color: #907373;">(</span>format t <span style="color: #8b2252;">"~{~a~^ ~}~%"</span> <span style="color: #6276ba;">(</span>handle-flag <span style="color: #858580;">(</span>first resp<span style="color: #858580;">)</span> indices input<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
          <span style="color: #907373;">(</span>format t <span style="color: #8b2252;">"~{~a~^ ~}~%"</span>
                  <span style="color: #6276ba;">(</span>build-response-from-resp resp indices input<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>

<span style="color: #707183;">(</span><span style="color: #a020f0;">defun</span> <span style="color: #0000ff;">eliza-loop</span> <span style="color: #7388d6;">()</span>
  <span style="color: #7388d6;">(</span>format t <span style="color: #8b2252;">"Hola, soy Eliza.~%Escribe algo:~%"</span><span style="color: #7388d6;">)</span>
  <span style="color: #7388d6;">(</span><span style="color: #a020f0;">loop</span>
     <span style="color: #909183;">(</span>format t <span style="color: #8b2252;">"~%&gt; "</span><span style="color: #909183;">)</span>
     <span style="color: #909183;">(</span><span style="color: #a020f0;">let*</span> <span style="color: #709870;">(</span><span style="color: #907373;">(</span>line <span style="color: #6276ba;">(</span>read-line *query-io* nil nil<span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
       <span style="color: #709870;">(</span><span style="color: #a020f0;">when</span> <span style="color: #907373;">(</span>null line<span style="color: #907373;">)</span> <span style="color: #907373;">(</span><span style="color: #a020f0;">return</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span>
       <span style="color: #709870;">(</span><span style="color: #a020f0;">let</span> <span style="color: #907373;">(</span><span style="color: #6276ba;">(</span>tokens <span style="color: #858580;">(</span>clean-and-tokenize line<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span>
         <span style="color: #907373;">(</span><span style="color: #a020f0;">cond</span>
           <span style="color: #6276ba;">(</span><span style="color: #858580;">(</span>or <span style="color: #80a880;">(</span>string= <span style="color: #887070;">(</span>first tokens<span style="color: #887070;">)</span> <span style="color: #8b2252;">"adios"</span><span style="color: #80a880;">)</span>
                <span style="color: #80a880;">(</span>string= <span style="color: #887070;">(</span>first tokens<span style="color: #887070;">)</span> <span style="color: #8b2252;">"bye"</span><span style="color: #80a880;">)</span><span style="color: #858580;">)</span>
            <span style="color: #858580;">(</span>format t <span style="color: #8b2252;">"Adios, espero ayudarte.~%"</span><span style="color: #858580;">)</span>
            <span style="color: #858580;">(</span><span style="color: #a020f0;">return</span><span style="color: #858580;">)</span><span style="color: #6276ba;">)</span>
           <span style="color: #6276ba;">(</span>t <span style="color: #858580;">(</span>respond-to tokens<span style="color: #858580;">)</span><span style="color: #6276ba;">)</span><span style="color: #907373;">)</span><span style="color: #709870;">)</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org754cfaa" class="outline-2">
<h2 id="org754cfaa">Cómo ejecutar ELIZA</h2>
<div class="outline-text-2" id="text-org754cfaa">
<ol class="org-ol">
<li>Guarda el archivo en <code>eliza.lisp</code></li>
<li>Abre SBCL o CLISP</li>
<li>Carga el archivo:</li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>load <span style="color: #8b2252;">"eliza.lisp"</span><span style="color: #707183;">)</span>
</pre>
</div>

<ol class="org-ol">
<li>Ejecuta el loop:</li>
</ol>

<div class="org-src-container">
<pre class="src src-lisp"><span style="color: #707183;">(</span>eliza-loop<span style="color: #707183;">)</span>
</pre>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
La salida del libro es tacataca
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Eduardo Alcaraz</p>
<p class="date">Created: 2025-12-01 lun 09:33</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
